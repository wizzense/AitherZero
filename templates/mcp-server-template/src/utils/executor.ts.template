/**
 * Command Executor Utility
 * 
 * Provides functions for executing shell commands safely.
 * Includes proper error handling and output capture.
 */

import { promisify } from 'util';
import { exec as execCallback } from 'child_process';
import { logDebug, logError } from './logger.js';

const exec = promisify(execCallback);

export interface CommandResult {
  stdout: string;
  stderr: string;
  exitCode: number;
}

/**
 * Execute a shell command
 * 
 * @param command - The command to execute
 * @param cwd - Working directory for command execution
 * @param timeout - Timeout in milliseconds (default: 30000)
 * @returns Command result with stdout, stderr, and exit code
 */
export async function executeCommand(
  command: string,
  cwd?: string,
  timeout: number = 30000
): Promise<CommandResult> {
  logDebug(`Executing command: ${command}`);
  logDebug(`Working directory: ${cwd || process.cwd()}`);
  
  try {
    const { stdout, stderr } = await exec(command, {
      cwd: cwd || process.cwd(),
      timeout,
      maxBuffer: 10 * 1024 * 1024, // 10MB buffer
    });
    
    logDebug(`Command succeeded with stdout length: ${stdout.length}`);
    
    return {
      stdout: stdout.trim(),
      stderr: stderr.trim(),
      exitCode: 0,
    };
  } catch (error: any) {
    logError(`Command failed: ${command}`, error);
    
    return {
      stdout: error.stdout || '',
      stderr: error.stderr || error.message,
      exitCode: error.code || 1,
    };
  }
}

/**
 * Execute a command with streaming output (for long-running commands)
 * 
 * Note: This is a placeholder. Implement if you need streaming.
 * Streaming requires different handling and may not work with all MCP clients.
 */
export async function executeCommandStreaming(
  command: string,
  cwd?: string
): Promise<CommandResult> {
  // TODO: Implement streaming execution if needed
  // For now, fall back to regular execution
  return executeCommand(command, cwd);
}

/**
 * [DEPRECATED] Do not use string sanitization for shell commands.
 * 
 * String sanitization is insufficient for preventing command injection.
 * Instead, use safe command execution patterns:
 * - Use buildCommand() with proper argument escaping
 * - Use spawn() with array arguments instead of exec()
 * - Avoid shell execution entirely when possible
 * 
 * This function is kept for backwards compatibility but should not be used.
 * It will be removed in a future version.
 * 
 * @deprecated Use buildCommand() or spawn with array arguments instead
 */
export function sanitizeCommand(input: string): string {
  console.warn('[DEPRECATED] sanitizeCommand() is deprecated. Use buildCommand() or spawn with array arguments instead.');
  // Remove potentially dangerous characters
  // This is a basic example - adjust for your use case
  return input.replace(/[;&|`$(){}[\]]/g, '');
}

/**
 * Build a command with safe argument escaping
 * 
 * Example: buildCommand('echo', ['hello', 'world']) => 'echo "hello" "world"'
 */
export function buildCommand(executable: string, args: string[]): string {
  const escapedArgs = args.map(arg => `"${arg.replace(/"/g, '\\"')}"`);
  return `${executable} ${escapedArgs.join(' ')}`;
}
