name: CI - Continuous Integration

on:
  push:
    branches: [ main, develop, 'release/**' ]
  pull_request:
    branches: [ main, develop ]
  merge_group:
    types: [checks_requested]
  workflow_dispatch:
    inputs:
      debug_enabled:
        type: boolean
        description: 'Run the build with tmate debugging enabled'
        required: false
        default: false

# Cancel in-progress runs for the same workflow
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1
  DOTNET_CLI_TELEMETRY_OPTOUT: 1
  DOTNET_NOLOGO: true
  PSCORE_VERSION: '7.4.5'  # Pin PowerShell version for consistency

jobs:
  # Job to analyze what changed and determine what needs to be tested
  analyze-changes:
    name: Analyze Changes
    runs-on: ubuntu-latest
    outputs:
      has-powershell-changes: ${{ steps.filter.outputs.powershell }}
      has-workflow-changes: ${{ steps.filter.outputs.workflows }}
      has-docs-changes: ${{ steps.filter.outputs.docs }}
      has-terraform-changes: ${{ steps.filter.outputs.terraform }}
      affected-modules: ${{ steps.analyze.outputs.modules }}
      test-matrix: ${{ steps.matrix.outputs.matrix }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for accurate diff
        
    - name: Detect file changes
      uses: dorny/paths-filter@v3
      id: filter
      with:
        filters: |
          powershell:
            - '**/*.ps1'
            - '**/*.psm1'
            - '**/*.psd1'
          workflows:
            - '.github/workflows/**'
          docs:
            - '**/*.md'
            - 'docs/**'
          terraform:
            - '**/*.tf'
            - '**/*.tfvars'
            
    - name: Analyze affected modules
      id: analyze
      shell: pwsh
      run: |
        $changes = git diff --name-only ${{ github.event.before || 'HEAD~1' }} ${{ github.sha }}
        $modules = @()
        
        foreach ($change in $changes) {
          if ($change -match 'aither-core/modules/([^/]+)/') {
            $modules += $matches[1]
          }
        }
        
        $uniqueModules = $modules | Select-Object -Unique | ConvertTo-Json -Compress
        echo "modules=$uniqueModules" >> $env:GITHUB_OUTPUT
        
    - name: Generate dynamic test matrix
      id: matrix
      shell: pwsh
      run: |
        # Dynamic matrix based on changes
        $matrix = @{
          os = @('ubuntu-latest', 'windows-latest', 'macos-latest')
          pwsh_version = @('7.4.5')
        }
        
        # If critical changes, test on more PS versions
        if ('${{ steps.filter.outputs.powershell }}' -eq 'true') {
          $matrix.pwsh_version += '7.3.12', '7.2.20'
        }
        
        $matrixJson = $matrix | ConvertTo-Json -Compress
        echo "matrix=$matrixJson" >> $env:GITHUB_OUTPUT

  # Code quality and linting
  code-quality:
    name: Code Quality (${{ matrix.check }})
    runs-on: ubuntu-latest
    needs: analyze-changes
    if: needs.analyze-changes.outputs.has-powershell-changes == 'true'
    strategy:
      fail-fast: false
      matrix:
        check:
          - psscriptanalyzer
          - formatting
          - complexity
          - best-practices
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    # PowerShell is pre-installed on GitHub runners
        
    - name: Cache PowerShell modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/share/powershell/Modules
          ~/Documents/PowerShell/Modules
          ~/AppData/Local/PackageManagement
        key: ${{ runner.os }}-psmodules-${{ matrix.check }}-${{ hashFiles('**/requirements.psd1') }}
        restore-keys: |
          ${{ runner.os }}-psmodules-${{ matrix.check }}-
          ${{ runner.os }}-psmodules-
          
    - name: Install analysis tools
      shell: pwsh
      run: |
        $modules = @('PSScriptAnalyzer', 'Pester', 'PSCodeHealth')
        foreach ($module in $modules) {
          if (!(Get-Module -ListAvailable -Name $module)) {
            Install-Module -Name $module -Force -AllowClobber -Scope CurrentUser
          }
        }
        
    - name: Run PSScriptAnalyzer
      if: matrix.check == 'psscriptanalyzer'
      shell: pwsh
      run: |
        $results = Invoke-ScriptAnalyzer -Path . -Recurse -ReportSummary -Settings @{
          IncludeRules = @('*')
          ExcludeRules = @(
            'PSUseShouldProcessForStateChangingFunctions',
            'PSAvoidUsingWriteHost'
          )
          Severity = @('Error', 'Warning', 'Information')
        }
        
        if ($results) {
          $results | Format-Table -AutoSize
          $errors = ($results | Where-Object Severity -eq 'Error').Count
          $warnings = ($results | Where-Object Severity -eq 'Warning').Count
          
          Write-Host "Found $errors errors and $warnings warnings"
          
          # Create GitHub annotations
          foreach ($issue in $results) {
            $annotation = switch ($issue.Severity) {
              'Error' { '::error' }
              'Warning' { '::warning' }
              default { '::notice' }
            }
            Write-Host "$annotation file=$($issue.ScriptPath),line=$($issue.Line),col=$($issue.Column)::$($issue.RuleName): $($issue.Message)"
          }
          
          if ($errors -gt 0) {
            throw "PSScriptAnalyzer found $errors errors"
          }
        }
        
    - name: Check code formatting
      if: matrix.check == 'formatting'
      shell: pwsh
      run: |
        # Check for consistent formatting
        $files = Get-ChildItem -Path . -Include *.ps1,*.psm1,*.psd1 -Recurse
        $issues = 0
        
        foreach ($file in $files) {
          $content = Get-Content $file.FullName -Raw
          
          # Check for tabs vs spaces (enforce 4 spaces)
          if ($content -match '\t') {
            Write-Warning "$($file.FullName) contains tabs (should use 4 spaces)"
            $issues++
          }
          
          # Check for trailing whitespace
          $lines = Get-Content $file.FullName
          for ($i = 0; $i -lt $lines.Count; $i++) {
            if ($lines[$i] -match '\s+$') {
              Write-Warning "$($file.FullName):$($i+1) has trailing whitespace"
              $issues++
            }
          }
          
          # Check line endings (CRLF on Windows, LF elsewhere)
          if ($IsWindows) {
            if ($content -notmatch '\r\n') {
              Write-Warning "$($file.FullName) should use CRLF line endings"
              $issues++
            }
          } else {
            if ($content -match '\r\n') {
              Write-Warning "$($file.FullName) should use LF line endings"
              $issues++
            }
          }
        }
        
        if ($issues -gt 0) {
          throw "Found $issues formatting issues"
        }
        
    - name: Analyze code complexity
      if: matrix.check == 'complexity'
      shell: pwsh
      run: |
        # Measure code health metrics
        Import-Module PSCodeHealth
        
        $report = Invoke-PSCodeHealth -Path . -HtmlReportPath code-health.html
        
        # Check thresholds
        $metrics = @{
          'Cyclomatic Complexity' = 10
          'Nesting Depth' = 4
          'Lines of Code' = 100
        }
        
        $violations = 0
        foreach ($function in $report.FunctionHealthRecords) {
          foreach ($metric in $metrics.GetEnumerator()) {
            $value = $function."$($metric.Key)"
            if ($value -gt $metric.Value) {
              Write-Warning "$($function.FunctionName): $($metric.Key) is $value (threshold: $($metric.Value))"
              $violations++
            }
          }
        }
        
        # Upload report
        Write-Host "::notice::Code health report generated"
        
        if ($violations -gt 0) {
          Write-Warning "Found $violations complexity violations"
        }
        
    - name: Check best practices
      if: matrix.check == 'best-practices'
      shell: pwsh
      run: |
        $issues = 0
        
        # Check for proper error handling
        $files = Get-ChildItem -Path . -Include *.ps1,*.psm1 -Recurse
        foreach ($file in $files) {
          $content = Get-Content $file.FullName -Raw
          
          # Check for try-catch around critical operations
          if ($content -match 'Invoke-WebRequest|Invoke-RestMethod' -and 
              $content -notmatch 'try\s*{[^}]*(?:Invoke-WebRequest|Invoke-RestMethod)') {
            Write-Warning "$($file.Name): Web requests should be wrapped in try-catch"
            $issues++
          }
          
          # Check for proper module imports
          if ($content -match 'Import-Module' -and $content -notmatch 'Import-Module.*-Force') {
            Write-Warning "$($file.Name): Import-Module should use -Force parameter"
            $issues++
          }
          
          # Check for hardcoded paths
          if ($content -match 'C:\\|/home/|/Users/') {
            Write-Warning "$($file.Name): Contains hardcoded paths"
            $issues++
          }
        }
        
        if ($issues -gt 0) {
          Write-Warning "Found $issues best practice violations"
        }
        
    - name: Upload analysis results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: code-quality-${{ matrix.check }}
        path: |
          *.html
          *.xml
          *.sarif
        retention-days: 30

  # Main test job with matrix strategy
  test:
    name: Test - ${{ matrix.os }} / PS ${{ matrix.pwsh_version }}
    runs-on: ${{ matrix.os }}
    needs: [analyze-changes, code-quality]
    if: |
      always() && 
      (needs.code-quality.result == 'success' || needs.code-quality.result == 'skipped')
    strategy:
      fail-fast: true
      matrix: ${{ fromJson(needs.analyze-changes.outputs.test-matrix) }}
      max-parallel: 3
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    # PowerShell is pre-installed on GitHub runners
        
    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/share/powershell/Modules
          ~/.nuget/packages
          ~/AppData/Local/PackageManagement/NuGet
          ~/Documents/PowerShell/Modules
          ~/.config/powershell
        key: ${{ runner.os }}-ps${{ matrix.pwsh_version }}-deps-${{ hashFiles('**/requirements.psd1', '**/packages.config') }}-v2
        restore-keys: |
          ${{ runner.os }}-ps${{ matrix.pwsh_version }}-deps-
          ${{ runner.os }}-deps-
          
    - name: Install test dependencies
      shell: pwsh
      run: |
        # Install Pester if not present
        if (!(Get-Module -ListAvailable -Name Pester | Where-Object Version -ge 5.0.0)) {
          Install-Module -Name Pester -MinimumVersion 5.0.0 -Force -AllowClobber -Scope CurrentUser
        }
        
        # Install other test dependencies
        @('PSScriptAnalyzer', 'Assert', 'PesterMatchExactly') | ForEach-Object {
          if (!(Get-Module -ListAvailable -Name $_)) {
            Install-Module -Name $_ -Force -AllowClobber -Scope CurrentUser
          }
        }
        
    - name: Run unit tests
      shell: pwsh
      run: |
        $config = New-PesterConfiguration
        $config.Run.Path = './tests'
        $config.Run.PassThru = $true
        $config.CodeCoverage.Enabled = $true
        $config.CodeCoverage.Path = './aither-core/**/*.ps1'
        $config.CodeCoverage.OutputFormat = 'JaCoCo'
        $config.CodeCoverage.OutputPath = 'coverage.xml'
        $config.TestResult.Enabled = $true
        $config.TestResult.OutputFormat = 'JUnitXml'
        $config.TestResult.OutputPath = 'test-results.xml'
        $config.Output.Verbosity = 'Detailed'
        
        # Set timeout for CI
        $config.Run.Timeout = 1800  # 30 minutes
        
        $results = Invoke-Pester -Configuration $config
        
        # Generate summary
        Write-Host "`n📊 Test Summary:" -ForegroundColor Cyan
        Write-Host "  Total: $($results.TotalCount)" -ForegroundColor White
        Write-Host "  Passed: $($results.PassedCount)" -ForegroundColor Green
        Write-Host "  Failed: $($results.FailedCount)" -ForegroundColor Red
        Write-Host "  Skipped: $($results.SkippedCount)" -ForegroundColor Yellow
        Write-Host "  Code Coverage: $([math]::Round($results.CodeCoverage.CoveragePercent, 2))%" -ForegroundColor Magenta
        
        # Fail if tests failed or coverage too low
        if ($results.FailedCount -gt 0) {
          throw "$($results.FailedCount) tests failed"
        }
        
        if ($results.CodeCoverage.CoveragePercent -lt 60) {
          Write-Warning "Code coverage is below 60% threshold"
        }
        
    - name: Run integration tests
      if: matrix.os != 'macos-latest'  # Skip integration tests on macOS (no Hyper-V)
      shell: pwsh
      run: |
        # Run integration tests separately
        if (Test-Path './tests/Integration') {
          $config = New-PesterConfiguration
          $config.Run.Path = './tests/Integration'
          $config.Run.PassThru = $true
          $config.TestResult.Enabled = $true
          $config.TestResult.OutputFormat = 'JUnitXml'
          $config.TestResult.OutputPath = 'integration-test-results.xml'
          
          $results = Invoke-Pester -Configuration $config
          
          if ($results.FailedCount -gt 0) {
            throw "$($results.FailedCount) integration tests failed"
          }
        }
        
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.os }}-ps${{ matrix.pwsh_version }}
        path: |
          test-results.xml
          integration-test-results.xml
          coverage.xml
        retention-days: 30
        
    - name: Upload coverage to Codecov
      if: matrix.os == 'ubuntu-latest' && matrix.pwsh_version == env.PSCORE_VERSION
      uses: codecov/codecov-action@v4
      with:
        files: ./coverage.xml
        flags: unittests
        name: codecov-${{ matrix.os }}
        
    - name: Test module loading
      shell: pwsh
      run: |
        # Test that all modules can be imported
        $modules = Get-ChildItem -Path ./aither-core/modules -Directory
        $failed = 0
        
        foreach ($module in $modules) {
          Write-Host "Testing module: $($module.Name)" -ForegroundColor Cyan
          try {
            Import-Module $module.FullName -Force -ErrorAction Stop
            Write-Host "  ✅ Module loaded successfully" -ForegroundColor Green
            
            # Check exported commands
            $commands = Get-Command -Module $module.Name
            Write-Host "  📦 Exported $($commands.Count) commands" -ForegroundColor Gray
          }
          catch {
            Write-Host "  ❌ Failed to load module: $_" -ForegroundColor Red
            $failed++
          }
        }
        
        if ($failed -gt 0) {
          throw "$failed modules failed to load"
        }
        
    - name: Performance benchmarks
      if: matrix.os == 'ubuntu-latest' && github.event_name == 'pull_request'
      shell: pwsh
      run: |
        # Run performance benchmarks
        $baseline = @{
          'Module Load Time' = 500  # milliseconds
          'Script Execution' = 1000  # milliseconds
          'Memory Usage' = 100  # MB
        }
        
        # Measure module load time
        $loadTime = Measure-Command {
          Get-ChildItem -Path ./aither-core/modules -Directory | ForEach-Object {
            Import-Module $_.FullName -Force
          }
        }
        
        Write-Host "Module load time: $($loadTime.TotalMilliseconds)ms"
        
        if ($loadTime.TotalMilliseconds -gt $baseline['Module Load Time']) {
          Write-Warning "Module load time exceeds baseline"
        }
        
    - name: Setup tmate session
      if: ${{ github.event_name == 'workflow_dispatch' && inputs.debug_enabled }}
      uses: mxschmitt/action-tmate@v3
      with:
        limit-access-to-actor: true

  # Build validation
  build-test:
    name: Build Test - ${{ matrix.platform }}
    runs-on: ubuntu-latest
    needs: test
    strategy:
      matrix:
        platform: [windows, linux, macos]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    # PowerShell is pre-installed on GitHub runners
        
    - name: Test build process
      shell: pwsh
      run: |
        Write-Host "Testing ${{ matrix.platform }} build..." -ForegroundColor Yellow
        
        # Get version
        $version = Get-Content ./VERSION -Raw -ErrorAction SilentlyContinue | ForEach-Object { $_.Trim() }
        if (-not $version) { $version = "0.0.1-ci" }
        
        # Run build
        ./build/Build-Package.ps1 -Platform ${{ matrix.platform }} -Version $version
        
        # Verify output
        $expectedFile = if ('${{ matrix.platform }}' -eq 'windows') {
          "build/output/AitherZero-v$version-windows.zip"
        } else {
          "build/output/AitherZero-v$version-${{ matrix.platform }}.tar.gz"
        }
        
        if (Test-Path $expectedFile) {
          $size = (Get-Item $expectedFile).Length / 1MB
          Write-Host "✅ Build successful: $expectedFile ($([math]::Round($size, 2)) MB)" -ForegroundColor Green
          
          # Validate package contents
          if ('${{ matrix.platform }}' -eq 'windows') {
            $items = @(Expand-Archive -Path $expectedFile -DestinationPath ./test-extract -PassThru)
          } else {
            New-Item -ItemType Directory -Path ./test-extract -Force
            tar -xzf $expectedFile -C ./test-extract
            $items = Get-ChildItem ./test-extract -Recurse
          }
          
          # Check critical files exist
          $required = @('Start-AitherZero.ps1', 'aither-core/aither-core.ps1', 'VERSION', 'README.md')
          foreach ($req in $required) {
            if (-not ($items | Where-Object { $_.FullName -like "*$req" })) {
              throw "Required file missing from package: $req"
            }
          }
          
          Write-Host "✅ Package validation passed" -ForegroundColor Green
        } else {
          throw "Build failed: $expectedFile not found"
        }
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-${{ matrix.platform }}
        path: build/output/*
        retention-days: 7

  # Documentation validation
  docs-check:
    name: Documentation Check
    runs-on: ubuntu-latest
    needs: analyze-changes
    if: needs.analyze-changes.outputs.has-docs-changes == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js (for markdown linting)
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Cache npm dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.npm
          node_modules
        key: ${{ runner.os }}-npm-docs-${{ hashFiles('**/package-lock.json') }}-v2
        restore-keys: |
          ${{ runner.os }}-npm-docs-
          
    - name: Install markdown linter
      run: npm install -g markdownlint-cli
      
    - name: Lint markdown files
      run: |
        # Create markdownlint config
        cat > .markdownlint.json << 'EOF'
        {
          "default": true,
          "MD013": { "line_length": 120 },
          "MD033": false,
          "MD041": false
        }
        EOF
        
        markdownlint '**/*.md' --ignore node_modules
        
    - name: Check for broken links
      uses: gaurav-nelson/github-action-markdown-link-check@v1
      with:
        use-quiet-mode: 'yes'
        config-file: '.markdown-link-check.json'
        
    - name: Validate PowerShell help
      shell: pwsh
      run: |
        # Check that all exported functions have comment-based help
        $modules = Get-ChildItem -Path ./aither-core/modules -Directory
        $missing = 0
        
        foreach ($module in $modules) {
          Import-Module $module.FullName -Force -ErrorAction SilentlyContinue
          $functions = Get-Command -Module $module.Name -CommandType Function
          
          foreach ($func in $functions) {
            $help = Get-Help $func.Name -ErrorAction SilentlyContinue
            if (-not $help.Synopsis -or $help.Synopsis -eq $func.Name) {
              Write-Warning "$($func.Name): Missing synopsis in comment-based help"
              $missing++
            }
          }
        }
        
        if ($missing -gt 0) {
          Write-Warning "Found $missing functions without proper help documentation"
        }

  # Summary job that runs after all tests
  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [code-quality, test, build-test, docs-check]
    if: always()
    
    steps:
    - name: Check results
      shell: pwsh
      run: |
        $results = @{
          'code-quality' = '${{ needs.code-quality.result }}'
          'test' = '${{ needs.test.result }}'
          'build-test' = '${{ needs.build-test.result }}'
          'docs-check' = '${{ needs.docs-check.result }}'
        }
        
        Write-Host "`n📊 CI Summary:" -ForegroundColor Cyan
        $failed = 0
        
        foreach ($job in $results.GetEnumerator()) {
          $emoji = switch ($job.Value) {
            'success' { '✅' }
            'failure' { '❌'; $failed++ }
            'cancelled' { '⚠️' }
            'skipped' { '⏭️' }
            default { '❓' }
          }
          Write-Host "$emoji $($job.Key): $($job.Value)"
        }
        
        if ($failed -gt 0) {
          Write-Host "`n❌ CI Failed: $failed job(s) failed" -ForegroundColor Red
          exit 1
        } else {
          Write-Host "`n✅ CI Passed: All checks successful!" -ForegroundColor Green
        }
        
    - name: Post PR comment with results
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const results = {
            'code-quality': '${{ needs.code-quality.result }}',
            'test': '${{ needs.test.result }}',
            'build-test': '${{ needs.build-test.result }}',
            'docs-check': '${{ needs.docs-check.result }}'
          };
          
          let body = '## 🤖 CI Results\n\n';
          body += '| Check | Status |\n';
          body += '|-------|--------|\n';
          
          for (const [check, result] of Object.entries(results)) {
            const emoji = result === 'success' ? '✅' : 
                         result === 'failure' ? '❌' : 
                         result === 'skipped' ? '⏭️' : '⚠️';
            body += `| ${check} | ${emoji} ${result} |\n`;
          }
          
          body += '\n[View full CI logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})';
          
          // Find existing comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('🤖 CI Results')
          );
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
          }