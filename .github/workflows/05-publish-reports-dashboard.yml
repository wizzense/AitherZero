---
name: [Dashboard] Publish Test Reports & Dashboard to GitHub Pages

# Publish comprehensive test reports, dashboards, and PR-specific status to GitHub Pages
# Integrates with test-execution.yml and generates navigable reports for each PR
'on':
  # Triggered on PR events for complete ecosystem deployment
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: [main, dev, develop, dev-staging, ring-0, ring-0-integrations, ring-1, ring-1-integrations, ring-2]
  
  # Triggered after test execution completes
  workflow_run:
    workflows: ["üß™ Test Execution (Complete Suite)"]
    types: [completed]
    branches: [main, dev, develop, dev-staging, ring-0, ring-0-integrations, ring-1, ring-1-integrations, ring-2]
  
  # Manual trigger
  workflow_dispatch:
    inputs:
      force_publish:
        description: 'Force publish even if no changes detected'
        type: boolean
        default: true
      pr_number:
        description: 'PR number for PR-specific publishing (leave empty for main)'
        type: string
        required: false

permissions:
  contents: write
  pages: write
  id-token: write
  actions: read
  pull-requests: write
  issues: write

concurrency:
  group: publish-reports-dashboard-${{ github.ref }}
  cancel-in-progress: true

jobs:
  collect-reports:
    name:  Collect Test Reports and Generate Dashboard
    runs-on: ubuntu-latest
    timeout-minutes: 8
    outputs:
      pr-number: ${{ steps.extract-pr-context.outputs.pr-number || github.event.pull_request.number }}
      pr-title: ${{ steps.extract-pr-context.outputs.pr-title || github.event.pull_request.title }}
      pr-branch: ${{ steps.extract-pr-context.outputs.pr-branch || github.event.pull_request.head.ref }}
      pr-base: ${{ steps.extract-pr-context.outputs.pr-base || github.event.pull_request.base.ref }}
      has-pr: ${{ steps.extract-pr-context.outputs.has-pr == 'true' || github.event.pull_request != '' }}
      branch-path-prefix: ${{ steps.determine-branch-path.outputs.path-prefix }}
      deployment-url-base: ${{ steps.determine-branch-path.outputs.url-base }}

    steps:
      - name:  Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref || github.event.repository.default_branch }}
          fetch-depth: 0

      - name:  Extract PR Context from workflow_run
        id: extract-pr-context
        if: github.event.workflow_run
        uses: actions/github-script@v7
        with:
          script: |
            // Extract PR information from workflow_run event
            const workflowRun = context.payload.workflow_run;
            
            if (workflowRun && workflowRun.pull_requests && workflowRun.pull_requests.length > 0) {
              const pr = workflowRun.pull_requests[0];
              core.info(`Found PR #${pr.number} in workflow_run event`);
              
              // Fetch full PR details from GitHub API to get title and state
              const { data: prData } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              core.setOutput('pr-number', pr.number.toString());
              core.setOutput('pr-title', prData.title);
              core.setOutput('pr-branch', pr.head.ref);
              core.setOutput('pr-base', pr.base.ref);
              core.setOutput('pr-state', prData.state);
              core.setOutput('has-pr', 'true');
              
              core.info(`PR Details: #${pr.number} - ${prData.title}`);
              core.info(`Branch: ${pr.head.ref} ‚Üí ${pr.base.ref}`);
            } else {
              core.info('No PR context found in workflow_run event');
              core.setOutput('has-pr', 'false');
            }

      - name:  Determine Branch-Specific Deployment Path
        id: determine-branch-path
        shell: pwsh
        env:
          PR_BASE: ${{ steps.extract-pr-context.outputs.pr-base || github.event.pull_request.base.ref || 'main' }}
        run: |
          $baseBranch = $env:PR_BASE
          Write-Host "[URLs] Determining deployment path for base branch: $baseBranch" -ForegroundColor Cyan
          
          # Map base branch to deployment path prefix
          $pathPrefix = switch ($baseBranch) {
            'main'        { '' }
            'dev'         { 'dev/' }
            'dev-staging' { 'dev-staging/' }
            'develop'     { 'develop/' }
            'ring-0'      { 'ring-0/' }
            'ring-1'      { 'ring-1/' }
            'ring-2'      { 'ring-2/' }
            default       { '' }  # Default to root for unknown branches
          }
          
          # Determine URL base for GitHub Pages
          $repoName = "$env:GITHUB_REPOSITORY" -replace '.*/(.*)$', '$1'
          $repoOwner = "$env:GITHUB_REPOSITORY" -replace '(.*)/.*$', '$1'
          
          if ($pathPrefix) {
            $urlBase = "https://${repoOwner}.github.io/${repoName}/${pathPrefix}"
          } else {
            $urlBase = "https://${repoOwner}.github.io/${repoName}/"
          }
          
          Write-Host "[OK] Path prefix: '$pathPrefix'" -ForegroundColor Green
          Write-Host "[OK] URL base: $urlBase" -ForegroundColor Green
          
          echo "path-prefix=${pathPrefix}" >> $env:GITHUB_OUTPUT
          echo "url-base=${urlBase}" >> $env:GITHUB_OUTPUT

      - name:  Bootstrap Environment
        shell: pwsh
        run: |
          Write-Host " Bootstrapping AitherZero environment..." -ForegroundColor Cyan
          ./bootstrap.ps1 -Mode New -InstallProfile Minimal

      - name: [Dashboard] Download Test Artifacts from test-execution.yml
        id: download-artifacts
        if: github.event.workflow_run
        uses: dawidd6/action-download-artifact@v6
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          run_id: ${{ github.event.workflow_run.id }}
          path: ./downloaded-artifacts
          workflow: test-execution.yml
        continue-on-error: true

      - name:  Organize Test Results
        shell: pwsh
        run: |
          Write-Host " Organizing test results from new test structure..." -ForegroundColor Cyan
          
          # Check if artifacts were downloaded
          $artifactsDownloaded = '${{ steps.download-artifacts.outcome }}' -eq 'success'
          $hasTestData = $false
          
          if (-not $artifactsDownloaded) {
            Write-Host "" -ForegroundColor Yellow
            Write-Host "  WARNING: Test artifacts were NOT downloaded!" -ForegroundColor Yellow
            Write-Host "  This means the test-execution workflow did NOT run or failed." -ForegroundColor Yellow
            Write-Host "  Dashboard will be generated WITHOUT actual test results." -ForegroundColor Yellow
            Write-Host "" -ForegroundColor Yellow
          }
          
          # Ensure directories exist
          New-Item -ItemType Directory -Path "library/tests/results" -Force | Out-Null
          New-Item -ItemType Directory -Path "library/tests/coverage" -Force | Out-Null
          New-Item -ItemType Directory -Path "library/reports" -Force | Out-Null
          
          # Copy downloaded artifacts to test results
          if (Test-Path "./downloaded-artifacts") {
            Write-Host "Copying test artifacts from test-execution.yml..." -ForegroundColor Yellow
            
            $xmlCount = 0
            $jsonCount = 0
            $coverageCount = 0
            
            Get-ChildItem "./downloaded-artifacts" -Recurse -Filter "*.xml" | ForEach-Object {
              $destPath = Join-Path "library/tests/results" $_.Name
              Copy-Item $_.FullName -Destination $destPath -Force
              Write-Host "   Test Result: $($_.Name)" -ForegroundColor Green
              $xmlCount++
              $hasTestData = $true
            }
            
            Get-ChildItem "./downloaded-artifacts" -Recurse -Filter "*.json" | ForEach-Object {
              $destPath = Join-Path "library/tests/results" $_.Name
              Copy-Item $_.FullName -Destination $destPath -Force
              Write-Host "   Test Data: $($_.Name)" -ForegroundColor Green
              $jsonCount++
            }
            
            # Copy coverage data
            Get-ChildItem "./downloaded-artifacts" -Recurse -Include "coverage*" | ForEach-Object {
              if ($_.PSIsContainer) {
                Copy-Item $_.FullName -Destination "library/tests/coverage" -Recurse -Force
              } else {
                Copy-Item $_.FullName -Destination "library/tests/coverage" -Force
              }
              Write-Host "   Coverage: $($_.Name)" -ForegroundColor Green
              $coverageCount++
            }
            
            # Copy performance metrics and validation results
            Get-ChildItem "./downloaded-artifacts" -Recurse -Filter "performance-*.json" | ForEach-Object {
              $destPath = Join-Path "library/reports" $_.Name
              Copy-Item $_.FullName -Destination $destPath -Force
              Write-Host "   Performance Metric: $($_.Name)" -ForegroundColor Green
            }
            
            Get-ChildItem "./downloaded-artifacts" -Recurse -Filter "validation-results.json" | ForEach-Object {
              $destPath = Join-Path "library/reports" $_.Name
              Copy-Item $_.FullName -Destination $destPath -Force
              Write-Host "   Validation Results: $($_.Name)" -ForegroundColor Green
            }
            
            Write-Host "" -ForegroundColor Cyan
            Write-Host "[Dashboard] Test artifacts summary:" -ForegroundColor Cyan
            Write-Host "   - Test result files (XML): $xmlCount" -ForegroundColor Cyan
            Write-Host "   - Test data files (JSON): $jsonCount" -ForegroundColor Cyan
            Write-Host "   - Coverage files: $coverageCount" -ForegroundColor Cyan
          } else {
            Write-Host "" -ForegroundColor Red
            Write-Host "[Error] No test artifacts directory found!" -ForegroundColor Red
            Write-Host "[Error] The downloaded-artifacts directory does not exist." -ForegroundColor Red
          }
          
          if ($hasTestData) {
            Write-Host "" -ForegroundColor Green
            Write-Host "[OK] Test results organized successfully" -ForegroundColor Green
          } else {
            Write-Host "" -ForegroundColor Red
            Write-Host "[Error] NO TEST RESULTS FOUND - Dashboard will show placeholder data" -ForegroundColor Red
            Write-Host "[Error] Verify that pr-check.yml and test-execution workflows are running" -ForegroundColor Red
          }

      - name: [Dashboard] Generate Dashboard with Modular Playbook
        shell: pwsh
        run: |
          Write-Host "[Dashboard] Generating dashboard using modular playbook..." -ForegroundColor Cyan
          
          # Import AitherZero module
          Import-Module ./AitherZero.psd1 -Force -ErrorAction Stop
          
          # Use new modular dashboard generation playbook
          # This runs 5 metrics collectors in parallel, then generates HTML
          Invoke-AitherPlaybook -Name dashboard-generation-complete -ErrorAction Continue
          
          Write-Host "[OK] Dashboard generated successfully" -ForegroundColor Green

      - name:  Generate PR-Specific Dashboard with Container Info
        if: github.event.pull_request || steps.extract-pr-context.outputs.has-pr == 'true'
        shell: pwsh
        env:
          # Use PR context from either pull_request event or extracted workflow_run context
          PR_NUMBER: ${{ github.event.pull_request.number || steps.extract-pr-context.outputs.pr-number }}
          PR_TITLE: ${{ github.event.pull_request.title || steps.extract-pr-context.outputs.pr-title }}
          PR_BRANCH: ${{ github.event.pull_request.head.ref || steps.extract-pr-context.outputs.pr-branch }}
          PR_BASE: ${{ github.event.pull_request.base.ref || steps.extract-pr-context.outputs.pr-base }}
          PR_STATE: ${{ github.event.pull_request.state || steps.extract-pr-context.outputs.pr-state }}
          BRANCH_PATH_PREFIX: ${{ steps.determine-branch-path.outputs.path-prefix }}
          DEPLOYMENT_URL_BASE: ${{ steps.determine-branch-path.outputs.url-base }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          Write-Host " Generating PR-specific dashboard for PR #$env:PR_NUMBER..." -ForegroundColor Cyan
          Write-Host "  Base branch: $env:PR_BASE" -ForegroundColor Yellow
          Write-Host "  Branch path prefix: '$env:BRANCH_PATH_PREFIX'" -ForegroundColor Yellow
          Write-Host "  Deployment URL base: $env:DEPLOYMENT_URL_BASE" -ForegroundColor Yellow
          
          # Determine PR directory with branch-specific path
          # If branch path prefix is empty (main), use library/reports/pr-{number}
          # Otherwise use {prefix}library/reports/pr-{number}
          if ($env:BRANCH_PATH_PREFIX) {
            $prDir = "${env:BRANCH_PATH_PREFIX}library/reports/pr-$env:PR_NUMBER"
          } else {
            $prDir = "library/reports/pr-$env:PR_NUMBER"
          }
          
          Write-Host "  Creating PR dashboard at: $prDir" -ForegroundColor Cyan
          New-Item -ItemType Directory -Path $prDir -Force | Out-Null
          
          # Copy main dashboard to PR-specific location (only from library/reports/)
          $dashboardSources = @(
            @{ Source = "library/reports/dashboard.html"; Dest = "dashboard.html" }
            @{ Source = "library/reports/dashboard.json"; Dest = "dashboard.json" }
            @{ Source = "library/reports/dashboard.md"; Dest = "dashboard.md" }
          )
          
          foreach ($item in $dashboardSources) {
            if (Test-Path $item.Source) {
              $destPath = Join-Path $prDir $item.Dest
              Copy-Item $item.Source -Destination $destPath -Force
              Write-Host "[OK] Copied $($item.Source) to PR dashboard" -ForegroundColor Green
            }
          }
          
          # Copy modular dashboard directory if it exists
          if (Test-Path "library/reports/dashboard") {
            Copy-Item "library/reports/dashboard" -Destination "$prDir/dashboard" -Recurse -Force
            Write-Host "[OK] Copied modular dashboard directory" -ForegroundColor Green
          }
          
          # Calculate Docker container info
          $dynamicPort = 8080 + ([int]$env:PR_NUMBER % 100)
          $imageNameLower = "$env:GITHUB_REPOSITORY".ToLower()
          $packageUrl = "https://github.com/$env:GITHUB_REPOSITORY/pkgs/container/aitherzero"
          $containerName = "aitherzero-pr-$env:PR_NUMBER"
          
          # Create PR-specific index with Docker container information using template
          $dynamicPort = 8080 + ([int]$env:PR_NUMBER % 100)
          $imageNameLower = "$env:GITHUB_REPOSITORY".ToLower()
          $packageUrl = "https://github.com/$env:GITHUB_REPOSITORY/pkgs/container/aitherzero"
          $containerName = "aitherzero-pr-$env:PR_NUMBER"
          
          # Load template and replace placeholders
          $templatePath = "./library/_templates/pr-dashboard-index.md"
          if (Test-Path $templatePath) {
            $prIndexContent = Get-Content $templatePath -Raw
            $replacements = @{
              '{{PR_NUMBER}}' = $env:PR_NUMBER
              '{{PR_TITLE}}' = $env:PR_TITLE
              '{{PR_BRANCH}}' = $env:PR_BRANCH
              '{{PR_BASE}}' = $env:PR_BASE
              '{{PR_STATE}}' = $env:PR_STATE
              '{{TIMESTAMP}}' = (Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
              '{{PACKAGE_URL}}' = $packageUrl
              '{{IMAGE_NAME_LOWER}}' = $imageNameLower
              '{{CONTAINER_NAME}}' = $containerName
              '{{DYNAMIC_PORT}}' = $dynamicPort
              '{{SERVER_URL}}' = $env:GITHUB_SERVER_URL
              '{{REPOSITORY}}' = $env:GITHUB_REPOSITORY
              '{{RUN_ID}}' = $env:GITHUB_RUN_ID
            }
            foreach ($key in $replacements.Keys) {
              $prIndexContent = $prIndexContent -replace [regex]::Escape($key), $replacements[$key]
            }
          } else {
            Write-Host "Template not found, using minimal content" -ForegroundColor Yellow
            $prIndexContent = "# PR Dashboard`n`nSee workflow run for details."
          }
          
          # Add test result summary if available
          $testResults = Get-ChildItem "library/tests/results" -Filter "*.xml" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if ($testResults) {
            try {
              [xml]$testXml = Get-Content $testResults.FullName
              $total = [int]$testXml.'test-results'.total
              $failures = [int]$testXml.'test-results'.failures
              $errors = [int]$testXml.'test-results'.errors
              $passed = $total - $failures - $errors
              $successRate = [math]::Round(($passed / $total) * 100, 1)
              
              $testSummary = "`n### Test Summary`n"
              $testSummary += "- [OK] **Passed:** $passed`n"
              $testSummary += "- [Error] **Failed:** $($failures + $errors)`n"
              $testSummary += "- [Dashboard] **Total:** $total`n"
              $testSummary += "- [Target] **Success Rate:** $successRate%`n`n"
              $prIndexContent += $testSummary
            } catch {
              Write-Host "Could not parse test results" -ForegroundColor Yellow
            }
          }
          
          # Add deployment status section
          $deploymentSection = "`n---`n`n##  Deployment Status`n`n"
          $deploymentSection += "Check the [GitHub Actions workflow runs]($env:GITHUB_SERVER_URL/$env:GITHUB_REPOSITORY/actions) for:`n"
          $deploymentSection += "- [OK] **Container Build**: View build logs and container publishing status`n"
          $deploymentSection += "- [OK] **Test Execution**: See all test results and coverage`n"
          $deploymentSection += "- [OK] **Quality Validation**: Code quality and linting results`n`n"
          $deploymentSection += "### How to Test This PR`n`n"
          $deploymentSection += "1. **Pull the Docker image** (see commands above)`n"
          $deploymentSection += "2. **Run the container** with the provided command`n"
          $deploymentSection += "3. **Access the environment** at ``http://localhost:$dynamicPort```n"
          $deploymentSection += "4. **Review the dashboard** for metrics and test results`n`n"
          $deploymentSection += "---`n`n* Auto-generated dashboard for PR #$env:PR_NUMBER*`n"
          $prIndexContent += $deploymentSection
          
          $prIndexContent | Out-File -FilePath "$prDir/index.md" -Encoding UTF8
          
          Write-Host "[OK] PR #$env:PR_NUMBER dashboard created at $prDir" -ForegroundColor Green
          Write-Host "  - Container: $containerName" -ForegroundColor Cyan
          Write-Host "  - Port: $dynamicPort" -ForegroundColor Cyan
          Write-Host "  - Package: $packageUrl" -ForegroundColor Cyan

      - name:  Create Main Navigation Index
        shell: pwsh
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
        run: |
          Write-Host " Creating main navigation index..." -ForegroundColor Cyan
          
          $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC'
          
          # Get all PR dashboards
          $prDirs = Get-ChildItem "library/reports" -Directory -Filter "pr-*" -ErrorAction SilentlyContinue | Sort-Object Name -Descending
          
          # Get latest release info from GitHub API or local VERSION file
          $latestRelease = "Unknown"
          $releaseUrl = "$env:GITHUB_SERVER_URL/$env:GITHUB_REPOSITORY/releases/latest"
          if (Test-Path "./VERSION") {
            $latestRelease = Get-Content "./VERSION" -Raw -ErrorAction SilentlyContinue
            if ($latestRelease) {
              $latestRelease = $latestRelease.Trim()
            }
          }
          
          # Calculate Docker container info
          $imageNameLower = "$env:GITHUB_REPOSITORY".ToLower()
          $packageUrl = "https://github.com/$env:GITHUB_REPOSITORY/pkgs/container/aitherzero"
          
          # Build main dashboard content without here-strings
          $indexContent = "# [Target] AitherZero Project Dashboard`n`n"
          $indexContent += "**Last Updated:** $timestamp`n`n"
          $indexContent += "##  Main Dashboard`n`n"
          $indexContent += "[Dashboard] [**View Comprehensive Dashboard**](library/reports/dashboard.html) - Real-time project metrics, test results, and code quality`n`n"
          $indexContent += "---`n`n"
          $indexContent += "##  Latest Release`n`n"
          $indexContent += "- **Version:** $latestRelease`n"
          $indexContent += "- **Release Page:** [$releaseUrl]($releaseUrl)`n"
          $indexContent += "- **Packages:** [GitHub Releases]($env:GITHUB_SERVER_URL/$env:GITHUB_REPOSITORY/releases)`n`n"
          $indexContent += "### [Docker] Docker Images`n`n"
          $indexContent += "- **Latest Release:** ``ghcr.io/${imageNameLower}:latest```n"
          $indexContent += "- **Version Tag:** ``ghcr.io/${imageNameLower}:$latestRelease```n"
          $indexContent += "- **Package Registry:** [$packageUrl]($packageUrl)`n`n"
          $indexContent += "###  Quick Install`n`n"
          $indexContent += "````powershell`n"
          $indexContent += "# One-line install (PowerShell)`n"
          $indexContent += "iwr -useb https://raw.githubusercontent.com/$env:GITHUB_REPOSITORY/main/bootstrap.ps1 | iex`n`n"
          $indexContent += "# Docker`n"
          $indexContent += "docker pull ghcr.io/${imageNameLower}:latest`n"
          $indexContent += "docker run -it --rm ghcr.io/${imageNameLower}:latest`n"
          $indexContent += "```````n`n"
          $indexContent += "---`n`n"
          $indexContent += "##  Pull Request Dashboards`n`n"
          
          if ($prDirs.Count -gt 0) {
            foreach ($prDir in $prDirs) {
              $prNum = $prDir.Name -replace 'pr-', ''
              $prIndexPath = Join-Path $prDir.FullName "index.md"
              
              if (Test-Path $prIndexPath) {
                $prContent = Get-Content $prIndexPath -Raw
                if ($prContent -match 'Title:\*\* (.+)') {
                  $prTitle = $matches[1].Trim()
                } else {
                  $prTitle = "PR #$prNum"
                }
              } else {
                $prTitle = "PR #$prNum"
              }
              
              # Include Docker container info for each PR
              $prDynamicPort = 8080 + ([int]$prNum % 100)
              $indexContent += "- [PR #$prNum - $prTitle](library/reports/$($prDir.Name)/) [Docker] ``ghcr.io/${imageNameLower}:pr-$prNum-latest`` (port: $prDynamicPort)`n"
            }
          } else {
            $indexContent += "*No open PRs with dashboards*`n"
          }
          
          # Add resources section without here-strings
          $indexContent += "`n---`n`n"
          $indexContent += "##  Additional Resources`n`n"
          $indexContent += "- [Test Reports](library/tests/results/) - Raw test execution data`n"
          $indexContent += "- [Coverage Reports](library/tests/coverage/) - Code coverage analysis`n"
          $indexContent += "- [Quality Metrics](library/reports/psscriptanalyzer-fast-results.json) - PSScriptAnalyzer results`n"
          $indexContent += "- [Project Reports](library/reports/) - All generated reports`n`n"
          $indexContent += "### [Docker] Container Registry`n`n"
          $indexContent += "All Docker containers are published to GitHub Container Registry:`n"
          $indexContent += "- **Main Package:** [$packageUrl]($packageUrl)`n"
          $indexContent += "- **Latest Release:** ``ghcr.io/${imageNameLower}:latest```n"
          $indexContent += "- **PR Containers:** ``ghcr.io/${imageNameLower}:pr-{number}-latest```n"
          $indexContent += "- **Version Tags:** ``ghcr.io/${imageNameLower}:{version}```n`n"
          $indexContent += "###  Release Artifacts`n`n"
          $indexContent += "Each release includes:`n"
          $indexContent += "- [OK] **Platform Package** - AitherZero-v{version}.zip/tar.gz`n"
          $indexContent += "- [OK] **MCP Server** - @aitherzero/mcp-server@{version}`n"
          $indexContent += "- [OK] **Docker Images** - Multi-platform (amd64, arm64)`n"
          $indexContent += "- [OK] **Build Info** - Complete build metadata`n`n"
          $indexContent += "---`n`n"
          $indexContent += "##  Dashboard Guide`n`n"
          $indexContent += "### Health Scores`n"
          $indexContent += "- [OK] **90-100**: Excellent`n"
          $indexContent += "- [GOOD] **70-89**: Good`n"
          $indexContent += "- [WARN] **50-69**: Needs Work`n"
          $indexContent += "-  **0-49**: Urgent`n`n"
          $indexContent += "### Priority Actions`n"
          $indexContent += "1. Fix Critical/Error items`n"
          $indexContent += "2. Address failing tests`n"
          $indexContent += "3. Review warnings`n"
          $indexContent += "4. Plan new features`n`n"
          $indexContent += "---`n`n"
          $indexContent += "*Generated: $timestamp*`n"
          
          $indexContent | Out-File -FilePath "index.md" -Encoding UTF8
          
          Write-Host "[OK] Navigation index created" -ForegroundColor Green
          Write-Host "  - PRs tracked: $($prDirs.Count)" -ForegroundColor Cyan
          Write-Host "  - Latest release: $latestRelease" -ForegroundColor Cyan
          Write-Host "  - Container registry: $packageUrl" -ForegroundColor Cyan

      - name:  Commit Updated Reports
        if: github.event_name != 'pull_request'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add reports and dashboards (all in library/reports/)
          git add library/reports/dashboard.* library/reports/psscriptanalyzer-fast-results.json
          git add library/reports/pr-*/
          git add library/reports/README.md library/reports/index.md
          git add library/reports/metrics-history/*.json
          git add index.md
          
          # Commit if there are changes
          if ! git diff --staged --quiet; then
            git commit -m "chore: update dashboards and reports - $(date -u +"%Y-%m-%d %H:%M UTC") [skip ci]"
            git push origin HEAD:${{ github.ref_name }}
            echo "[OK] Reports committed and pushed"
          else
            echo "[Info] No changes to reports"
          fi

      - name:  Upload Combined Reports
        uses: actions/upload-artifact@v4
        with:
          name: combined-reports
          path: |
            library/reports/
            library/tests/results/
            library/tests/coverage/
            index.md
            _config.yml
          retention-days: 30

  # ============================================================================
  # TRIGGER-JEKYLL-DEPLOYMENT: Trigger Jekyll workflow for unified deployment
  # ============================================================================
  trigger-jekyll-deployment:
    name: [Target] Trigger Jekyll Deployment
    runs-on: ubuntu-latest
    needs: collect-reports
    timeout-minutes: 5

    steps:
      - name:  Report Status
        shell: pwsh
        env:
          PR_NUMBER: ${{ needs.collect-reports.outputs.pr-number }}
          PR_BASE: ${{ needs.collect-reports.outputs.pr-base }}
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          Write-Host "[OK] Reports and dashboard generated successfully!" -ForegroundColor Green
          Write-Host ""
          Write-Host "[Dashboard] Generated Content:" -ForegroundColor Yellow
          Write-Host "  - Test reports collected from test execution"
          Write-Host "  - Interactive dashboard created"
          Write-Host "  - PR-specific content prepared"
          Write-Host ""
          Write-Host " Next Step: Jekyll workflow will deploy to GitHub Pages" -ForegroundColor Cyan
          Write-Host "  - Branch: $env:BRANCH_NAME" -ForegroundColor Yellow
          if ($env:PR_NUMBER) {
            Write-Host "  - PR: #$env:PR_NUMBER ‚Üí $env:PR_BASE" -ForegroundColor Yellow
          }
          Write-Host ""
          Write-Host "‚è≥ Triggering Jekyll deployment workflow..." -ForegroundColor Cyan

      - name:  Trigger Jekyll GitHub Pages Deployment
        uses: actions/github-script@v7
        with:
          script: |
            // Use the actual branch name from PR context or extracted values
            // For PR events, context.ref is 'refs/pull/<id>/merge' which doesn't exist as a branch
            // Use pr-branch output (from PR head ref) or fall back to ref_name
            const prBranch = '${{ needs.collect-reports.outputs.pr-branch }}';
            const prNumber = '${{ needs.collect-reports.outputs.pr-number }}';
            const refName = '${{ github.ref_name }}';
            
            // Determine the actual branch to trigger on
            // Priority: PR head branch > ref_name (for push events)
            // Use explicit check to handle empty strings (not just falsy values)
            const branch = prBranch && prBranch.trim() ? prBranch : refName;
            
            // Validate that branch is non-empty before proceeding
            if (!branch || branch.trim() === '') {
              core.setFailed('Cannot determine branch name for Jekyll deployment. Both prBranch and refName are empty.');
              return;
            }
            
            console.log(`Triggering Jekyll deployment for branch: ${branch}`);
            console.log(`  Resolved from: ${prBranch && prBranch.trim() ? 'pr-branch output' : 'ref_name'}`);
            if (prNumber) {
              console.log(`PR context: #${prNumber} (head: ${prBranch})`);
            }
            console.log(`Event type: ${context.eventName}`);
            console.log(`Original ref: ${context.ref}`);
            
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: '09-jekyll-gh-pages.yml',
                ref: branch,
                inputs: {
                  triggered_by: 'dashboard-workflow',
                  pr_number: prNumber || '',
                  reports_run_id: context.runId.toString()
                }
              });
              
              console.log('[OK] Jekyll deployment workflow triggered successfully!');
              core.info('Jekyll workflow will build complete site with reports and deploy to GitHub Pages');
            } catch (error) {
              core.setFailed(`Failed to trigger Jekyll workflow: ${error.message}`);
            }

      - name: [Comment] Comment on PR with Deployment Status
        if: needs.collect-reports.outputs.has-pr == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.collect-reports.outputs.pr-number }}
          PR_BASE: ${{ needs.collect-reports.outputs.pr-base }}
          REPOSITORY: ${{ github.repository }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        with:
          script: |
            const prNumber = process.env.PR_NUMBER;
            const prBase = process.env.PR_BASE;
            const repository = process.env.REPOSITORY;
            const repoOwner = process.env.REPO_OWNER;
            const repoName = process.env.REPO_NAME;
            
            // Calculate expected deployment URL
            const baseUrl = `https://${repoOwner}.github.io/${repoName}`;
            const dashboardUrl = `${baseUrl}/library/reports/dashboard.html`;
            const prDashboardUrl = `${baseUrl}/library/reports/pr-${prNumber}/`;
            
            // Calculate Docker container info
            const dynamicPort = 8080 + (parseInt(prNumber) % 100);
            const imageNameLower = repository.toLowerCase();
            const packageUrl = `https://github.com/${repository}/pkgs/container/aitherzero`;
            const containerName = `aitherzero-pr-${prNumber}`;
            
            const comment = `## [Dashboard] Dashboard & Reports Prepared

[OK] **Test reports and dashboard generated successfully!**

 **Deployment Status:** Jekyll workflow triggered - site will be published shortly

### [URLs] Deployment URLs (Available after Jekyll completes)

- [Target] **Main Dashboard:** [${dashboardUrl}](${dashboardUrl})
- [Dashboard] **PR #${prNumber} Dashboard:** [${prDashboardUrl}](${prDashboardUrl})
- [Reports] **All Reports:** [${baseUrl}/library/reports/](${baseUrl}/library/reports/)

### [Docker] Docker Container

\`\`\`bash
# Pull and run this PR's container
docker pull ghcr.io/${imageNameLower}:pr-${prNumber}-latest
docker run -it -p ${dynamicPort}:8080 ghcr.io/${imageNameLower}:pr-${prNumber}-latest
\`\`\`

- **Container Name:** \`${containerName}\`
- **Port:** \`${dynamicPort}\`
- **Registry:** [${packageUrl}](${packageUrl})

### ‚è≥ Next Steps

The Jekyll deployment workflow is building the complete site with your reports. Check the [Actions tab](https://github.com/${repository}/actions/workflows/09-jekyll-gh-pages.yml) for deployment progress.

---
*Target Branch:* \`${prBase}\` | *Updated:* ${new Date().toUTCString()}`;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            const existingComment = comments.find(c => 
              c.user.login === 'github-actions[bot]' && 
              (c.body.includes('Dashboard & Reports Prepared') || c.body.includes('Dashboard & Container Published'))
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: comment
              });
              console.log('Updated existing PR comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment
              });
              console.log('Created new PR comment');
            }
