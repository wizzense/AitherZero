---
name: CI Cost Optimizer

# Analyzes CI usage patterns and optimizes for cost efficiency without compromising functionality
on:
  schedule:
    # Weekly analysis and optimization
    - cron: '0 2 * * 0'  # Sunday 2 AM UTC
  workflow_dispatch:
    inputs:
      analysis_period:
        description: 'Analysis period in days'
        type: number
        default: 30
      apply_optimizations:
        description: 'Apply recommended optimizations'
        type: boolean
        default: false

permissions:
  contents: read
  actions: read
  issues: write
  pull-requests: write

jobs:
  analyze-ci-usage:
    name: 📊 Analyze CI Usage Patterns
    runs-on: ubuntu-latest
    outputs:
      total-minutes: ${{ steps.analysis.outputs.total-minutes }}
      cost-estimate: ${{ steps.analysis.outputs.cost-estimate }}
      optimization-opportunities: ${{ steps.analysis.outputs.optimization-opportunities }}
      
    steps:
      - name: 📥 Checkout Repository
        uses: actions/checkout@v4
        
      - name: 📊 Analyze Workflow Usage
        id: analysis
        uses: actions/github-script@v7
        with:
          script: |
            const analysisPeriod = parseInt('${{ github.event.inputs.analysis_period || 30 }}');
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - analysisPeriod);
            
            console.log(`📊 Analyzing CI usage for the past ${analysisPeriod} days...`);
            
            // Get workflow runs
            const { data: workflows } = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            let totalMinutes = 0;
            let runCount = 0;
            const workflowStats = {};
            const optimizationOpportunities = [];
            
            for (const workflow of workflows.workflows) {
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflow.id,
                per_page: 100,
                created: `>=${cutoffDate.toISOString().split('T')[0]}`
              });
              
              let workflowMinutes = 0;
              let workflowRuns = 0;
              let cancelledRuns = 0;
              let failedRuns = 0;
              
              for (const run of runs.workflow_runs) {
                if (new Date(run.created_at) < cutoffDate) continue;
                
                const runDuration = run.updated_at && run.created_at ? 
                  (new Date(run.updated_at) - new Date(run.created_at)) / 1000 / 60 : 0;
                
                workflowMinutes += runDuration;
                workflowRuns++;
                
                if (run.conclusion === 'cancelled') cancelledRuns++;
                if (run.conclusion === 'failure') failedRuns++;
              }
              
              workflowStats[workflow.name] = {
                runs: workflowRuns,
                minutes: Math.round(workflowMinutes),
                cancelled: cancelledRuns,
                failed: failedRuns,
                avgDuration: workflowRuns > 0 ? Math.round(workflowMinutes / workflowRuns) : 0
              };
              
              totalMinutes += workflowMinutes;
              runCount += workflowRuns;
              
              // Identify optimization opportunities
              if (cancelledRuns > workflowRuns * 0.2) {  // >20% cancelled
                optimizationOpportunities.push({
                  type: 'excessive-cancellations',
                  workflow: workflow.name,
                  issue: `High cancellation rate: ${Math.round(cancelledRuns/workflowRuns*100)}%`,
                  recommendation: 'Optimize concurrency settings or reduce redundant triggers'
                });
              }
              
              if (failedRuns > workflowRuns * 0.15) {  // >15% failed
                optimizationOpportunities.push({
                  type: 'high-failure-rate',
                  workflow: workflow.name,
                  issue: `High failure rate: ${Math.round(failedRuns/workflowRuns*100)}%`,
                  recommendation: 'Investigate and fix recurring failure patterns'
                });
              }
              
              if (workflowStats[workflow.name].avgDuration > 30) {  // >30 min average
                optimizationOpportunities.push({
                  type: 'long-running-workflow',
                  workflow: workflow.name,
                  issue: `Long average duration: ${workflowStats[workflow.name].avgDuration} minutes`,
                  recommendation: 'Consider parallelization, caching, or workflow splitting'
                });
              }
            }
            
            // Estimate costs (GitHub Actions pricing: ~$0.008/minute for Linux)
            const costEstimate = Math.round(totalMinutes * 0.008 * 100) / 100;
            
            console.log('📈 Usage Analysis Results:');
            console.log(`  Total Minutes: ${Math.round(totalMinutes)}`);
            console.log(`  Total Runs: ${runCount}`);
            console.log(`  Estimated Cost: $${costEstimate}`);
            console.log(`  Optimization Opportunities: ${optimizationOpportunities.length}`);
            
            // Save detailed analysis
            const analysis = {
              period: analysisPeriod,
              totalMinutes: Math.round(totalMinutes),
              totalRuns: runCount,
              costEstimate: costEstimate,
              avgDurationPerRun: runCount > 0 ? Math.round(totalMinutes / runCount) : 0,
              workflowStats: workflowStats,
              optimizationOpportunities: optimizationOpportunities,
              timestamp: new Date().toISOString()
            };
            
            require('fs').writeFileSync('ci-usage-analysis.json', JSON.stringify(analysis, null, 2));
            
            // Set outputs
            core.setOutput('total-minutes', Math.round(totalMinutes));
            core.setOutput('cost-estimate', costEstimate);
            core.setOutput('optimization-opportunities', optimizationOpportunities.length);
            
      - name: 📊 Upload Usage Analysis
        uses: actions/upload-artifact@v4
        with:
          name: ci-usage-analysis
          path: ci-usage-analysis.json
          retention-days: 90

  generate-optimization-recommendations:
    name: 🎯 Generate Optimization Recommendations
    runs-on: ubuntu-latest
    needs: analyze-ci-usage
    if: needs.analyze-ci-usage.outputs.optimization-opportunities > '0'
    
    steps:
      - name: 📥 Checkout Repository
        uses: actions/checkout@v4
        
      - name: 📊 Download Usage Analysis
        uses: actions/download-artifact@v4
        with:
          name: ci-usage-analysis
          path: ./analysis
          
      - name: 🎯 Generate Optimization Plan
        shell: pwsh
        run: |
          Write-Host "🎯 Generating CI optimization recommendations..." -ForegroundColor Cyan
          
          $analysis = Get-Content "./analysis/ci-usage-analysis.json" | ConvertFrom-Json
          
          Write-Host "📊 Current Usage Summary:" -ForegroundColor Yellow
          Write-Host "  Total Minutes (${analysis.period} days): $($analysis.totalMinutes)"
          Write-Host "  Total Runs: $($analysis.totalRuns)"
          Write-Host "  Estimated Cost: `$$($analysis.costEstimate)"
          Write-Host "  Average Duration/Run: $($analysis.avgDurationPerRun) minutes"
          
          # Generate optimization recommendations
          $optimizations = @()
          
          # Workflow-specific optimizations
          foreach ($opp in $analysis.optimizationOpportunities) {
            $optimization = @{
              Type = $opp.type
              Workflow = $opp.workflow
              Issue = $opp.issue
              Recommendation = $opp.recommendation
              EstimatedSavings = 0
            }
            
            # Calculate estimated savings
            switch ($opp.type) {
              'excessive-cancellations' {
                $workflowStats = $analysis.workflowStats[$opp.workflow]
                $optimization.EstimatedSavings = [math]::Round($workflowStats.minutes * 0.2)  # 20% of wasted minutes
              }
              'long-running-workflow' {
                $workflowStats = $analysis.workflowStats[$opp.workflow]
                $optimization.EstimatedSavings = [math]::Round($workflowStats.minutes * 0.3)  # 30% potential reduction
              }
              'high-failure-rate' {
                $workflowStats = $analysis.workflowStats[$opp.workflow]
                $optimization.EstimatedSavings = [math]::Round($workflowStats.minutes * 0.15)  # Retry overhead
              }
            }
            
            $optimizations += $optimization
          }
          
          # General optimization recommendations
          $generalOptimizations = @(
            @{
              Type = "caching"
              Recommendation = "Implement dependency caching for package managers"
              EstimatedSavings = [math]::Round($analysis.totalMinutes * 0.15)  # 15% typical savings
            },
            @{
              Type = "parallelization" 
              Recommendation = "Increase job parallelization where possible"
              EstimatedSavings = [math]::Round($analysis.totalMinutes * 0.25)  # 25% potential savings
            },
            @{
              Type = "trigger-optimization"
              Recommendation = "Optimize workflow triggers to reduce unnecessary runs"
              EstimatedSavings = [math]::Round($analysis.totalMinutes * 0.10)  # 10% reduction in runs
            }
          )
          
          $optimizations += $generalOptimizations
          
          # Calculate total potential savings
          $totalPotentialSavings = ($optimizations | Measure-Object -Property EstimatedSavings -Sum).Sum
          $potentialCostSavings = [math]::Round($totalPotentialSavings * 0.008, 2)
          
          Write-Host "`n💡 Optimization Opportunities:" -ForegroundColor Green
          foreach ($opt in $optimizations) {
            Write-Host "  • $($opt.Type): $($opt.Recommendation)"
            Write-Host "    Estimated Savings: $($opt.EstimatedSavings) minutes"
          }
          
          Write-Host "`n💰 Potential Monthly Savings:" -ForegroundColor Cyan
          Write-Host "  Minutes: $totalPotentialSavings"
          Write-Host "  Cost: `$$potentialCostSavings"
          Write-Host "  Percentage: $([math]::Round(($totalPotentialSavings / $analysis.totalMinutes) * 100, 1))%"
          
          # Save optimization plan
          $optimizationPlan = @{
            Analysis = $analysis
            Optimizations = $optimizations
            TotalPotentialSavings = $totalPotentialSavings
            PotentialCostSavings = $potentialCostSavings
            GeneratedAt = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
          }
          
          $optimizationPlan | ConvertTo-Json -Depth 5 | Out-File "optimization-plan.json"
          
      - name: 📊 Upload Optimization Plan
        uses: actions/upload-artifact@v4
        with:
          name: ci-optimization-plan
          path: optimization-plan.json
          retention-days: 90

  create-optimization-issue:
    name: 📝 Create Optimization Issue
    runs-on: ubuntu-latest
    needs: [analyze-ci-usage, generate-optimization-recommendations]
    if: needs.analyze-ci-usage.outputs.optimization-opportunities > '0'
    
    steps:
      - name: 📥 Checkout Repository
        uses: actions/checkout@v4
        
      - name: 📊 Download Optimization Plan
        uses: actions/download-artifact@v4
        with:
          name: ci-optimization-plan
          path: ./optimization
          
      - name: 📝 Create Optimization Issue
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = JSON.parse(fs.readFileSync('./optimization/optimization-plan.json', 'utf8'));
            const analysis = plan.Analysis;
            
            const issueTitle = `🚀 CI/CD Cost Optimization Opportunities - Potential $${plan.PotentialCostSavings}/month savings`;
            
            const issueBody = `## 🚀 CI/CD Cost Optimization Analysis
            
            **Analysis Period:** ${analysis.period} days  
            **Generated:** ${plan.GeneratedAt}
            
            ### 📊 Current Usage Summary
            - **Total Minutes:** ${analysis.totalMinutes.toLocaleString()}
            - **Total Runs:** ${analysis.totalRuns.toLocaleString()}
            - **Estimated Cost:** $${analysis.costEstimate}
            - **Average Duration/Run:** ${analysis.avgDurationPerRun} minutes
            
            ### 💰 Optimization Potential
            - **Potential Savings:** ${plan.TotalPotentialSavings.toLocaleString()} minutes/month
            - **Cost Savings:** $${plan.PotentialCostSavings}/month
            - **Percentage Reduction:** ${Math.round((plan.TotalPotentialSavings / analysis.totalMinutes) * 100)}%
            
            ### 🎯 Recommended Optimizations
            
            ${plan.Optimizations.map((opt, index) => `
            #### ${index + 1}. ${opt.Type.charAt(0).toUpperCase() + opt.Type.slice(1).replace(/-/g, ' ')}
            ${opt.Workflow ? `**Workflow:** ${opt.Workflow}` : ''}
            ${opt.Issue ? `**Issue:** ${opt.Issue}` : ''}
            **Recommendation:** ${opt.Recommendation}  
            **Estimated Savings:** ${opt.EstimatedSavings} minutes/month
            `).join('\n')}
            
            ### 📈 Top Resource-Consuming Workflows
            
            ${Object.entries(analysis.workflowStats)
              .sort((a, b) => b[1].minutes - a[1].minutes)
              .slice(0, 5)
              .map(([name, stats]) => `
            - **${name}:** ${stats.minutes} minutes (${stats.runs} runs, avg: ${stats.avgDuration}min)
              ${stats.cancelled > 0 ? `- ⚠️ ${stats.cancelled} cancelled runs` : ''}
              ${stats.failed > 0 ? `- ❌ ${stats.failed} failed runs` : ''}
            `).join('')}
            
            ### 🤖 AI Agent Instructions
            
            @copilot Please implement these CI/CD optimizations to reduce costs and improve efficiency:
            
            1. **Review** each optimization opportunity listed above
            2. **Prioritize** by impact vs. effort required
            3. **Implement** optimizations starting with highest impact
            4. **Test** changes to ensure no functionality is compromised
            5. **Monitor** usage patterns after implementation
            6. **Report** back with results and actual savings achieved
            
            ### 📋 Implementation Checklist
            
            - [ ] Implement caching strategies for dependencies
            - [ ] Optimize workflow triggers and conditions
            - [ ] Increase parallelization where beneficial
            - [ ] Fix recurring failure patterns
            - [ ] Optimize concurrency settings
            - [ ] Review and cleanup redundant workflows
            - [ ] Implement smart change detection
            - [ ] Add resource usage monitoring
            
            ### 📊 Success Metrics
            
            Target reductions after optimization:
            - **Minutes/month:** ${plan.TotalPotentialSavings.toLocaleString()} (current: ${analysis.totalMinutes.toLocaleString()})
            - **Cost/month:** $${plan.PotentialCostSavings} (current: $${analysis.costEstimate})
            - **Average run duration:** Reduce by 20-30%
            - **Failure rate:** < 10% across all workflows
            - **Cancellation rate:** < 15% across all workflows
            
            ---
            *This issue was automatically generated by the CI Cost Optimizer*
            
            **Next Analysis:** Will run again in 7 days to track progress`;
            
            const labels = ['optimization', 'ci-cd', 'cost-reduction', 'automated-issue'];
            
            try {
              const { data: issue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: labels,
                assignees: ['copilot']
              });
              
              console.log(`✅ Created optimization issue #${issue.number}`);
              
              // Also create a comment with the raw data for reference
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## 📊 Raw Analysis Data

            \`\`\`json
            ${JSON.stringify(analysis, null, 2)}
            \`\`\`
            
            <details>
            <summary>📈 Detailed Optimization Plan</summary>

            \`\`\`json
            ${JSON.stringify(plan, null, 2)}
            \`\`\`
            
            </details>`
              });
              
            } catch (error) {
              console.error(`❌ Failed to create optimization issue: ${error.message}`);
              core.setFailed(error.message);
            }