name: Code Quality Remediation

"on":
  schedule:
    # Run weekly on Sundays at 02:00 UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      modules:
        description: 'Specific modules to remediate (comma-separated, or "all" for all modules)'
        required: false
        default: 'all'
        type: string
      auto_fix:
        description: 'Enable automatic fixes for safe rules'
        required: false
        default: true
        type: boolean
      create_pr:
        description: 'Create pull request with fixes'
        required: false
        default: true
        type: boolean
      dry_run:
        description: 'Dry run mode (analyze only, no changes)'
        required: false
        default: false
        type: boolean

# Ensure only one remediation workflow runs at a time
concurrency:
  group: code-quality-remediation
  cancel-in-progress: false

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1
  DOTNET_CLI_TELEMETRY_OPTOUT: 1
  DOTNET_NOLOGO: true

jobs:
  analyze-quality:
    name: Analyze Code Quality
    runs-on: ubuntu-latest
    outputs:
      has-issues: ${{ steps.analysis.outputs.has-issues }}
      critical-modules: ${{ steps.analysis.outputs.critical-modules }}
      remediation-needed: ${{ steps.analysis.outputs.remediation-needed }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Install PowerShell modules
      shell: pwsh
      run: |
        $modules = @('PSScriptAnalyzer', 'Pester')
        foreach ($module in $modules) {
          if (!(Get-Module -ListAvailable -Name $module)) {
            Install-Module -Name $module -Force -AllowClobber -Scope CurrentUser
          }
        }
        
    - name: Comprehensive quality analysis
      id: analysis
      shell: pwsh
      run: |
        Write-Host "üîç Starting comprehensive code quality analysis..." -ForegroundColor Cyan
        
        # Import PSScriptAnalyzerIntegration if available
        $integrationPath = "./aither-core/modules/PSScriptAnalyzerIntegration/PSScriptAnalyzerIntegration.psd1"
        if (Test-Path $integrationPath) {
          Import-Module $integrationPath -Force
          Write-Host "‚úÖ PSScriptAnalyzerIntegration module loaded" -ForegroundColor Green
        }
        
        # Determine modules to analyze
        $modulesToAnalyze = @()
        $inputModules = '${{ github.event.inputs.modules || "all" }}'
        
        if ($inputModules -eq 'all' -or [string]::IsNullOrEmpty($inputModules)) {
          $modulesDirs = Get-ChildItem -Path "./aither-core/modules" -Directory -ErrorAction SilentlyContinue
          $modulesToAnalyze = $modulesDirs.FullName
        } else {
          $specifiedModules = $inputModules -split ',' | ForEach-Object { $_.Trim() }
          foreach ($module in $specifiedModules) {
            $modulePath = "./aither-core/modules/$module"
            if (Test-Path $modulePath) {
              $modulesToAnalyze += (Resolve-Path $modulePath).Path
            } else {
              Write-Warning "Module not found: $module"
            }
          }
        }
        
        if ($modulesToAnalyze.Count -eq 0) {
          Write-Host "‚ö†Ô∏è  No modules found to analyze" -ForegroundColor Yellow
          echo "has-issues=false" >> $env:GITHUB_OUTPUT
          echo "remediation-needed=false" >> $env:GITHUB_OUTPUT
          exit 0
        }
        
        Write-Host "üìÅ Analyzing $($modulesToAnalyze.Count) modules..." -ForegroundColor White
        
        # Perform analysis
        $allResults = @()
        $criticalModules = @()
        $totalFindings = 0
        $totalErrors = 0
        $totalWarnings = 0
        
        foreach ($modulePath in $modulesToAnalyze) {
          $moduleName = Split-Path $modulePath -Leaf
          Write-Host "  üîç Analyzing module: $moduleName" -ForegroundColor Cyan
          
          try {
            if (Get-Command 'Start-DirectoryAudit' -ErrorAction SilentlyContinue) {
              # Use integrated audit function
              $result = Start-DirectoryAudit -Path $modulePath -ModuleName $moduleName -UpdateDocumentation $false
              $moduleFindings = $result.Summary.TotalFindings
              $moduleErrors = $result.Summary.ErrorCount
              $moduleWarnings = $result.Summary.WarningCount
            } else {
              # Fallback to direct PSScriptAnalyzer
              $settingsPath = "./PSScriptAnalyzerSettings.psd1"
              $analyzerParams = @{
                Path = $modulePath
                Recurse = $true
              }
              
              if (Test-Path $settingsPath) {
                $analyzerParams.Settings = $settingsPath
              }
              
              $findings = Invoke-ScriptAnalyzer @analyzerParams
              $moduleFindings = $findings.Count
              $moduleErrors = ($findings | Where-Object Severity -eq 'Error').Count
              $moduleWarnings = ($findings | Where-Object Severity -eq 'Warning').Count
              
              $result = @{
                Path = $modulePath
                ModuleName = $moduleName
                Summary = @{
                  TotalFindings = $moduleFindings
                  ErrorCount = $moduleErrors
                  WarningCount = $moduleWarnings
                }
                Results = $findings
              }
            }
            
            $allResults += $result
            $totalFindings += $moduleFindings
            $totalErrors += $moduleErrors
            $totalWarnings += $moduleWarnings
            
            # Track critical modules (with errors or high warning count)
            if ($moduleErrors -gt 0 -or $moduleWarnings -gt 15) {
              $criticalModules += $moduleName
              Write-Host "    üî¥ Critical: $moduleErrors errors, $moduleWarnings warnings" -ForegroundColor Red
            } elseif ($moduleWarnings -gt 5) {
              Write-Host "    üü° Needs attention: $moduleWarnings warnings" -ForegroundColor Yellow
            } else {
              Write-Host "    ‚úÖ Good quality: $moduleFindings total findings" -ForegroundColor Green
            }
          }
          catch {
            Write-Host "    ‚ùå Analysis failed: $($_.Exception.Message)" -ForegroundColor Red
            $criticalModules += $moduleName
          }
        }
        
        # Summary
        Write-Host "`nüìä Analysis Summary:" -ForegroundColor Cyan
        Write-Host "  üìÅ Modules analyzed: $($modulesToAnalyze.Count)" -ForegroundColor White
        Write-Host "  üîç Total findings: $totalFindings" -ForegroundColor White
        Write-Host "  ‚ùå Total errors: $totalErrors" -ForegroundColor Red
        Write-Host "  ‚ö†Ô∏è  Total warnings: $totalWarnings" -ForegroundColor Yellow
        Write-Host "  üî¥ Critical modules: $($criticalModules.Count)" -ForegroundColor Red
        
        # Set outputs
        $hasIssues = $totalFindings -gt 0
        $remediationNeeded = $totalErrors -gt 0 -or $totalWarnings -gt 50
        $criticalModulesJson = $criticalModules | ConvertTo-Json -Compress
        
        echo "has-issues=$hasIssues" >> $env:GITHUB_OUTPUT
        echo "critical-modules=$criticalModulesJson" >> $env:GITHUB_OUTPUT
        echo "remediation-needed=$remediationNeeded" >> $env:GITHUB_OUTPUT
        
        # Export detailed results
        $allResults | ConvertTo-Json -Depth 10 | Set-Content -Path "quality-analysis-results.json"
        
        Write-Host "üéØ Quality analysis completed" -ForegroundColor Green

    - name: Upload analysis results
      uses: actions/upload-artifact@v4
      with:
        name: quality-analysis-results
        path: quality-analysis-results.json
        retention-days: 30

  remediate-issues:
    name: Automated Remediation
    runs-on: ubuntu-latest
    needs: analyze-quality
    if: needs.analyze-quality.outputs.remediation-needed == 'true' && github.event.inputs.dry_run != 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Configure Git
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        
    - name: Install PowerShell modules
      shell: pwsh
      run: |
        $modules = @('PSScriptAnalyzer', 'Pester')
        foreach ($module in $modules) {
          if (!(Get-Module -ListAvailable -Name $module)) {
            Install-Module -Name $module -Force -AllowClobber -Scope CurrentUser
          }
        }
        
    - name: Download analysis results
      uses: actions/download-artifact@v4
      with:
        name: quality-analysis-results
        
    - name: Perform automated remediation
      shell: pwsh
      run: |
        Write-Host "üîß Starting automated code quality remediation..." -ForegroundColor Cyan
        
        # Import modules
        $integrationPath = "./aither-core/modules/PSScriptAnalyzerIntegration/PSScriptAnalyzerIntegration.psd1"
        if (Test-Path $integrationPath) {
          Import-Module $integrationPath -Force
        }
        
        # Load analysis results
        $results = Get-Content "quality-analysis-results.json" | ConvertFrom-Json
        $autoFix = '${{ github.event.inputs.auto_fix }}' -eq 'true'
        $fixedFiles = @()
        $remediationLog = @()
        
        # Safe rules that can be auto-fixed
        $safeAutoFixRules = @(
          'PSAvoidUsingCmdletAliases',
          'PSUseConsistentWhitespace',
          'PSUseConsistentIndentation',
          'PSAvoidTrailingWhitespace',
          'PSAvoidSemicolonsAsLineTerminators',
          'PSUseCorrectCasing',
          'PSAlignAssignmentStatement'
        )
        
        foreach ($result in $results) {
          if (-not $result.Results -or $result.Results.Count -eq 0) {
            continue
          }
          
          Write-Host "üîß Processing module: $($result.ModuleName)" -ForegroundColor Yellow
          
          # Group findings by file
          $fileGroups = $result.Results | Group-Object ScriptPath
          
          foreach ($fileGroup in $fileGroups) {
            $filePath = $fileGroup.Name
            if (-not (Test-Path $filePath)) {
              continue
            }
            
            Write-Host "  üìù Processing file: $(Split-Path $filePath -Leaf)" -ForegroundColor White
            
            $fileContent = Get-Content $filePath -Raw
            $originalContent = $fileContent
            $fileModified = $false
            
            # Process each finding
            foreach ($finding in $fileGroup.Group) {
              $ruleName = $finding.RuleName
              $remediationEntry = @{
                File = $filePath
                Rule = $ruleName
                Severity = $finding.Severity
                Line = $finding.Line
                Message = $finding.Message
                Action = 'None'
                Success = $false
              }
              
              # Apply safe automatic fixes
              if ($autoFix -and $ruleName -in $safeAutoFixRules) {
                try {
                  switch ($ruleName) {
                    'PSAvoidUsingCmdletAliases' {
                      # Replace common aliases
                      $aliases = @{
                        'gci' = 'Get-ChildItem'
                        'dir' = 'Get-ChildItem'
                        'ls' = 'Get-ChildItem'
                        'cat' = 'Get-Content'
                        'type' = 'Get-Content'
                        'echo' = 'Write-Output'
                        'write' = 'Write-Output'
                        'cls' = 'Clear-Host'
                        'clear' = 'Clear-Host'
                        'cd' = 'Set-Location'
                        'chdir' = 'Set-Location'
                        'copy' = 'Copy-Item'
                        'cp' = 'Copy-Item'
                        'move' = 'Move-Item'
                        'mv' = 'Move-Item'
                        'del' = 'Remove-Item'
                        'rm' = 'Remove-Item'
                        'md' = 'New-Item'
                        'mkdir' = 'New-Item'
                      }
                      
                      foreach ($alias in $aliases.GetEnumerator()) {
                        $pattern = "\b$($alias.Key)\b"
                        if ($fileContent -match $pattern) {
                          $fileContent = $fileContent -replace $pattern, $alias.Value
                          $fileModified = $true
                          $remediationEntry.Action = "Replaced alias '$($alias.Key)' with '$($alias.Value)'"
                          $remediationEntry.Success = $true
                        }
                      }
                    }
                    
                    'PSAvoidTrailingWhitespace' {
                      # Remove trailing whitespace
                      $lines = $fileContent -split "`r?`n"
                      $cleanedLines = $lines | ForEach-Object { $_.TrimEnd() }
                      $newContent = $cleanedLines -join "`n"
                      
                      if ($newContent -ne $fileContent) {
                        $fileContent = $newContent
                        $fileModified = $true
                        $remediationEntry.Action = 'Removed trailing whitespace'
                        $remediationEntry.Success = $true
                      }
                    }
                    
                    'PSAvoidSemicolonsAsLineTerminators' {
                      # Remove unnecessary semicolons at end of lines
                      $pattern = ';(\s*)$'
                      if ($fileContent -match $pattern) {
                        $fileContent = $fileContent -replace $pattern, '$1'
                        $fileModified = $true
                        $remediationEntry.Action = 'Removed unnecessary semicolons'
                        $remediationEntry.Success = $true
                      }
                    }
                    
                    'PSUseCorrectCasing' {
                      # Fix common casing issues for PowerShell keywords
                      $keywords = @{
                        'param' = 'param'
                        'function' = 'function'
                        'if' = 'if'
                        'else' = 'else'
                        'elseif' = 'elseif'
                        'switch' = 'switch'
                        'foreach' = 'foreach'
                        'while' = 'while'
                        'do' = 'do'
                        'try' = 'try'
                        'catch' = 'catch'
                        'finally' = 'finally'
                        'return' = 'return'
                        'break' = 'break'
                        'continue' = 'continue'
                      }
                      
                      foreach ($keyword in $keywords.GetEnumerator()) {
                        $pattern = "\b(?i)$($keyword.Key)\b"
                        if ($fileContent -match $pattern) {
                          $fileContent = $fileContent -replace $pattern, $keyword.Value
                          $fileModified = $true
                          $remediationEntry.Action = "Fixed casing for keyword '$($keyword.Key)'"
                          $remediationEntry.Success = $true
                        }
                      }
                    }
                  }
                }
                catch {
                  $remediationEntry.Action = "Failed to apply fix: $($_.Exception.Message)"
                  Write-Warning "Failed to apply fix for $ruleName in $filePath: $($_.Exception.Message)"
                }
              } else {
                $remediationEntry.Action = 'Manual review required'
              }
              
              $remediationLog += $remediationEntry
            }
            
            # Save modified file
            if ($fileModified) {
              Set-Content -Path $filePath -Value $fileContent -Encoding UTF8 -NoNewline
              $fixedFiles += $filePath
              Write-Host "    ‚úÖ Fixed issues in $(Split-Path $filePath -Leaf)" -ForegroundColor Green
            }
          }
        }
        
        # Close resolved GitHub Issues first
        Write-Host "`nüîÑ Closing resolved GitHub Issues..." -ForegroundColor Cyan
        
        $closedIssuesReport = @{
          ProcessedIssues = 0
          ClosedIssues = 0
          SkippedIssues = 0
          Errors = 0
          Details = @{
            Closed = @()
            Skipped = @()
            Errors = @()
          }
        }
        
        try {
          if (Get-Command 'Close-ResolvedGitHubIssues' -ErrorAction SilentlyContinue) {
            $closedIssuesReport = Close-ResolvedGitHubIssues -Path "./aither-core/modules" -DryRun:$false
            
            Write-Host "  üéØ Closed Issues Summary:" -ForegroundColor Cyan
            Write-Host "  üìã Issues processed: $($closedIssuesReport.ProcessedIssues)" -ForegroundColor White
            Write-Host "  ‚úÖ Issues closed: $($closedIssuesReport.ClosedIssues)" -ForegroundColor Green
            Write-Host "  ‚è≠Ô∏è  Issues skipped: $($closedIssuesReport.SkippedIssues)" -ForegroundColor Yellow
            Write-Host "  ‚ùå Errors: $($closedIssuesReport.Errors)" -ForegroundColor Red
          } else {
            Write-Host "  ‚ö†Ô∏è  Close-ResolvedGitHubIssues function not available, skipping issue closure" -ForegroundColor Yellow
          }
        }
        catch {
          Write-Warning "GitHub Issues closure failed: $($_.Exception.Message)"
          $closedIssuesReport.Errors += "GitHub Issues closure failed: $($_.Exception.Message)"
        }
        
        # Create GitHub Issues for unresolved findings
        Write-Host "`nüé´ Creating GitHub Issues for unresolved findings..." -ForegroundColor Cyan
        
        $issuesCreated = @()
        $issuesSkipped = @()
        $issueErrors = @()
        
        try {
          foreach ($result in $results) {
            if ($result.Results -and $result.Results.Count -gt 0) {
              # Filter findings that should become issues
              $criticalFindings = $result.Results | Where-Object { 
                $_.Severity -eq 'Error' -or 
                ($_.Severity -eq 'Warning' -and $_.RuleName -in @(
                  'PSAvoidUsingPlainTextForPassword',
                  'PSAvoidUsingUsernameAndPasswordParams',
                  'PSAvoidUsingConvertToSecureStringWithPlainText',
                  'PSUsePSCredentialType',
                  'PSAvoidHardcodedCredentials',
                  'PSAvoidUsingInvokeExpression',
                  'PSUseCompatibleCmdlets',
                  'PSUseCompatibleSyntax'
                ))
              }
              
              if ($criticalFindings.Count -gt 0) {
                Write-Host "  üìÅ Processing $($criticalFindings.Count) critical findings from $($result.ModuleName)" -ForegroundColor White
                
                foreach ($finding in $criticalFindings) {
                  try {
                    $issueResult = $finding | New-GitHubIssueFromFinding -DryRun:$false
                    $issuesCreated += $issueResult.CreatedIssues
                    $issuesSkipped += $issueResult.SkippedIssues
                    $issueErrors += $issueResult.Errors
                  }
                  catch {
                    $issueErrors += "Failed to process finding $($finding.RuleName): $($_.Exception.Message)"
                    Write-Warning "Failed to create issue for $($finding.RuleName): $($_.Exception.Message)"
                  }
                }
              }
            }
          }
          
          Write-Host "`nüé´ GitHub Issues Summary:" -ForegroundColor Cyan
          Write-Host "  ‚úÖ Issues created: $($issuesCreated.Count)" -ForegroundColor Green
          Write-Host "  ‚è≠Ô∏è  Issues skipped: $($issuesSkipped.Count)" -ForegroundColor Yellow
          Write-Host "  ‚ùå Errors: $($issueErrors.Count)" -ForegroundColor Red
          
          # Export issues report
          $issuesReport = @{
            Created = $issuesCreated
            Skipped = $issuesSkipped
            Errors = $issueErrors
            ClosedIssues = $closedIssuesReport
            Summary = @{
              CreatedCount = $issuesCreated.Count
              SkippedCount = $issuesSkipped.Count
              ErrorCount = $issueErrors.Count
              ClosedCount = $closedIssuesReport.ClosedIssues
            }
          }
          
          $issuesReport | ConvertTo-Json -Depth 10 | Set-Content -Path "github-issues-report.json"
        }
        catch {
          Write-Warning "GitHub Issues creation failed: $($_.Exception.Message)"
          $issueErrors += "GitHub Issues creation failed: $($_.Exception.Message)"
        }
        
        # Generate comprehensive remediation report
        $report = @{
          Timestamp = (Get-Date).ToString('yyyy-MM-ddTHH:mm:ssZ')
          FilesModified = $fixedFiles.Count
          TotalRemediation = $remediationLog.Count
          SuccessfulFixes = ($remediationLog | Where-Object Success -eq $true).Count
          ManualReviewNeeded = ($remediationLog | Where-Object Action -eq 'Manual review required').Count
          GitHubIssues = @{
            Created = $issuesCreated.Count
            Skipped = $issuesSkipped.Count
            Errors = $issueErrors.Count
          }
          Details = $remediationLog
        }
        
        $report | ConvertTo-Json -Depth 10 | Set-Content -Path "remediation-report.json"
        
        Write-Host "`nüéØ Comprehensive Remediation Summary:" -ForegroundColor Cyan
        Write-Host "  üìù Files modified: $($report.FilesModified)" -ForegroundColor Green
        Write-Host "  ‚úÖ Successful fixes: $($report.SuccessfulFixes)" -ForegroundColor Green
        Write-Host "  üëÄ Manual review needed: $($report.ManualReviewNeeded)" -ForegroundColor Yellow
        Write-Host "  üé´ GitHub Issues created: $($report.GitHubIssues.Created)" -ForegroundColor Blue
        Write-Host "  ‚è≠Ô∏è  GitHub Issues skipped: $($report.GitHubIssues.Skipped)" -ForegroundColor Gray
        
        # Set output for PR creation
        echo "files-modified=$($report.FilesModified)" >> $env:GITHUB_OUTPUT
        echo "successful-fixes=$($report.SuccessfulFixes)" >> $env:GITHUB_OUTPUT

    - name: Upload remediation report
      uses: actions/upload-artifact@v4
      with:
        name: remediation-report
        path: remediation-report.json
        retention-days: 30

    - name: Upload GitHub issues report
      uses: actions/upload-artifact@v4
      with:
        name: github-issues-report
        path: github-issues-report.json
        retention-days: 30

    - name: Check for changes
      id: check-changes
      if: github.event.inputs.create_pr == 'true'
      shell: pwsh
      run: |
        $changes = git status --porcelain
        if (-not $changes) {
          Write-Host "üìù No changes to commit" -ForegroundColor Yellow
          echo "has-changes=false" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "üîß Changes detected, preparing for PR creation..." -ForegroundColor Cyan
          echo "has-changes=true" >> $env:GITHUB_OUTPUT
        }
        
    - name: Create Pull Request
      if: github.event.inputs.create_pr == 'true' && steps.check-changes.outputs.has-changes == 'true'
      shell: pwsh
      run: |
        $branchName = "automated-code-quality-fixes-$(Get-Date -Format 'yyyy-MM-dd-HHmm')"
        git checkout -b $branchName
        git add .
        git commit -m "Automated code quality fixes - Applied safe automatic fixes for PSScriptAnalyzer findings"
        git push origin $branchName
        
        $prBody = "This PR contains automated fixes for PSScriptAnalyzer findings applied by the code quality remediation workflow."
        
        gh pr create --title "Automated Code Quality Fixes" --body $prBody --head $branchName --base main

  notify-results:
    name: Notify Results
    runs-on: ubuntu-latest
    needs: [analyze-quality, remediate-issues]
    if: always()
    
    steps:
    - name: Create summary
      shell: pwsh
      run: |
        $hasIssues = '${{ needs.analyze-quality.outputs.has-issues }}'
        $remediationNeeded = '${{ needs.analyze-quality.outputs.remediation-needed }}'
        $criticalModules = '${{ needs.analyze-quality.outputs.critical-modules }}'
        
        Write-Host "üìä Code Quality Remediation Results" -ForegroundColor Cyan
        Write-Host "=================================" -ForegroundColor Cyan
        
        if ($hasIssues -eq 'true') {
          Write-Host "üîç Issues detected: Yes" -ForegroundColor Yellow
          Write-Host "üîß Remediation needed: $remediationNeeded" -ForegroundColor $(if ($remediationNeeded -eq 'true') { 'Red' } else { 'Green' })
          
          if ($criticalModules -and $criticalModules -ne '[]') {
            $modules = $criticalModules | ConvertFrom-Json
            Write-Host "üî¥ Critical modules: $($modules -join ', ')" -ForegroundColor Red
          }
          
          if ('${{ needs.remediate-issues.result }}' -eq 'success') {
            Write-Host "‚úÖ Automated remediation completed successfully" -ForegroundColor Green
          } elseif ('${{ needs.remediate-issues.result }}' -eq 'skipped') {
            Write-Host "‚è≠Ô∏è  Remediation skipped (dry run or no issues)" -ForegroundColor Yellow
          } else {
            Write-Host "‚ùå Remediation failed or was cancelled" -ForegroundColor Red
          }
        } else {
          Write-Host "‚úÖ No code quality issues detected!" -ForegroundColor Green
        }
        
        Write-Host "`nüéØ Workflow completed at $(Get-Date)" -ForegroundColor White