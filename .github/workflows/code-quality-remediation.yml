name: "Code Quality Remediation"

on:
  schedule:
    # Run weekly on Saturdays at 3 AM UTC
    - cron: '0 3 * * 6'
  workflow_dispatch:
    inputs:
      remediation_type:
        description: 'Type of remediation to perform'
        required: true
        default: 'comprehensive'
        type: choice
        options:
          - comprehensive
          - formatting-only
          - rules-only
          - critical-only
      create_pr:
        description: 'Create pull request with fixes'
        required: false
        default: true
        type: boolean
      dry_run:
        description: 'Show what would be fixed without making changes'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1
  DOTNET_CLI_TELEMETRY_OPTOUT: 1
  DOTNET_NOLOGO: true

defaults:
  run:
    shell: pwsh

jobs:
  analyze-quality:
    name: "Analyze Code Quality"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      has-issues: ${{ steps.analysis.outputs.has-issues }}
      issue-count: ${{ steps.analysis.outputs.issue-count }}
      critical-count: ${{ steps.analysis.outputs.critical-count }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install PSScriptAnalyzer
        run: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser

      - name: Run comprehensive analysis
        id: analysis
        run: |
          Write-Host "üîç Running comprehensive PowerShell code analysis..."
          
          # Get all PowerShell files
          $files = Get-ChildItem -Include "*.ps1", "*.psm1", "*.psd1" -Recurse |
                   Where-Object { $_.FullName -notlike "*\.git*" -and $_.FullName -notlike "*test*" }
          
          Write-Host "Found $($files.Count) PowerShell files to analyze"
          
          $allIssues = @()
          $fixableIssues = @()
          
          foreach ($file in $files) {
            Write-Host "Analyzing: $($file.Name)"
            
            $issues = Invoke-ScriptAnalyzer -Path $file.FullName -Severity Error,Warning,Information -IncludeDefaultRules
            
            if ($issues) {
              foreach ($issue in $issues) {
                $issueObj = [PSCustomObject]@{
                  File = $file.FullName.Replace((Get-Location).Path, "").TrimStart('/')
                  Line = $issue.Line
                  Column = $issue.Column
                  Severity = $issue.Severity
                  RuleName = $issue.RuleName
                  Message = $issue.Message
                  ScriptPath = $issue.ScriptPath
                  Fixable = $issue.RuleName -in @(
                    'PSUseConsistentIndentation',
                    'PSUseConsistentWhitespace',
                    'PSAlignAssignmentStatement',
                    'PSUseCorrectCasing',
                    'PSPlaceOpenBrace',
                    'PSPlaceCloseBrace',
                    'PSAvoidTrailingWhitespace',
                    'PSAvoidSemicolonsAsLineTerminators'
                  )
                }
                $allIssues += $issueObj
                
                if ($issueObj.Fixable) {
                  $fixableIssues += $issueObj
                }
              }
            }
          }
          
          Write-Host "üìä Analysis Results:"
          Write-Host "  Total issues: $($allIssues.Count)"
          Write-Host "  Fixable issues: $($fixableIssues.Count)"
          Write-Host "  Critical issues: $(($allIssues | Where-Object Severity -eq 'Error').Count)"
          Write-Host "  Warning issues: $(($allIssues | Where-Object Severity -eq 'Warning').Count)"
          Write-Host "  Info issues: $(($allIssues | Where-Object Severity -eq 'Information').Count)"
          
          # Group by rule for summary
          $ruleGroups = $allIssues | Group-Object RuleName | Sort-Object Count -Descending
          if ($ruleGroups) {
            Write-Host "`nüìã Top issues by rule:"
            foreach ($group in $ruleGroups | Select-Object -First 10) {
              Write-Host "  $($group.Name): $($group.Count) occurrences"
            }
          }
          
          # Export detailed results
          $allIssues | ConvertTo-Json -Depth 3 | Set-Content "quality-analysis.json"
          $fixableIssues | ConvertTo-Json -Depth 3 | Set-Content "fixable-issues.json"
          
          # Set outputs
          echo "has-issues=$($allIssues.Count -gt 0 ? 'true' : 'false')" >> $env:GITHUB_OUTPUT
          echo "issue-count=$($allIssues.Count)" >> $env:GITHUB_OUTPUT
          echo "critical-count=$(($allIssues | Where-Object Severity -eq 'Error').Count)" >> $env:GITHUB_OUTPUT

      - name: Upload analysis results
        uses: actions/upload-artifact@v4
        with:
          name: quality-analysis
          path: |
            quality-analysis.json
            fixable-issues.json
          retention-days: 30

  auto-fix:
    name: "Auto-Fix Issues"
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: analyze-quality
    if: needs.analyze-quality.outputs.has-issues == 'true' && github.event.inputs.dry_run != 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install tools
        run: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser

      - name: Download analysis results
        uses: actions/download-artifact@v4
        with:
          name: quality-analysis
          path: ./

      - name: Apply automatic fixes
        id: apply-fixes
        run: |
          Write-Host "üîß Applying automatic fixes..."
          
          $fixableIssues = Get-Content "fixable-issues.json" | ConvertFrom-Json
          $remediationType = "${{ github.event.inputs.remediation_type }}"
          
          Write-Host "Remediation type: $remediationType"
          Write-Host "Fixable issues: $($fixableIssues.Count)"
          
          $fixedFiles = @()
          $appliedFixes = @()
          
          # Group issues by file for efficient processing
          $fileGroups = $fixableIssues | Group-Object File
          
          foreach ($fileGroup in $fileGroups) {
            $filePath = $fileGroup.Name
            Write-Host "Processing: $filePath"
            
            if (-not (Test-Path $filePath)) {
              Write-Host "  ‚ö†Ô∏è File not found: $filePath"
              continue
            }
            
            $fileIssues = $fileGroup.Group
            $fixesToApply = @()
            
            # Filter fixes based on remediation type
            switch ($remediationType) {
              'formatting-only' {
                $fixesToApply = $fileIssues | Where-Object {
                  $_.RuleName -in @('PSUseConsistentIndentation', 'PSUseConsistentWhitespace', 'PSAlignAssignmentStatement', 'PSPlaceOpenBrace', 'PSPlaceCloseBrace', 'PSAvoidTrailingWhitespace')
                }
              }
              'rules-only' {
                $fixesToApply = $fileIssues | Where-Object {
                  $_.RuleName -in @('PSUseCorrectCasing', 'PSAvoidSemicolonsAsLineTerminators')
                }
              }
              'critical-only' {
                $fixesToApply = $fileIssues | Where-Object { $_.Severity -eq 'Error' }
              }
              default {
                $fixesToApply = $fileIssues
              }
            }
            
            if ($fixesToApply.Count -eq 0) {
              Write-Host "  ‚ÑπÔ∏è No applicable fixes for this file"
              continue
            }
            
            try {
              # Use Invoke-Formatter to fix formatting issues
              $formattingRules = $fixesToApply | Where-Object {
                $_.RuleName -in @('PSUseConsistentIndentation', 'PSUseConsistentWhitespace', 'PSPlaceOpenBrace', 'PSPlaceCloseBrace')
              }
              
              if ($formattingRules.Count -gt 0) {
                Write-Host "  üé® Applying formatting fixes..."
                
                $formatterSettings = @{
                  Rules = @{
                    PSUseConsistentIndentation = @{
                      Enable = $true
                      Kind = 'space'
                      IndentationSize = 4
                    }
                    PSUseConsistentWhitespace = @{
                      Enable = $true
                      CheckInnerBrace = $true
                      CheckOpenBrace = $true
                      CheckOpenParen = $true
                      CheckOperator = $true
                      CheckPipe = $true
                      CheckSeparator = $true
                    }
                    PSPlaceOpenBrace = @{
                      Enable = $true
                      OnSameLine = $true
                      NewLineAfter = $true
                      IgnoreOneLineBlock = $true
                    }
                    PSPlaceCloseBrace = @{
                      Enable = $true
                      NewLineAfter = $false
                      IgnoreOneLineBlock = $true
                      NoEmptyLineBefore = $false
                    }
                    PSAlignAssignmentStatement = @{
                      Enable = $true
                      CheckHashtable = $true
                    }
                  }
                }
                
                $originalContent = Get-Content $filePath -Raw
                $formattedContent = Invoke-Formatter -ScriptDefinition $originalContent -Settings $formatterSettings
                
                if ($formattedContent -ne $originalContent) {
                  Set-Content -Path $filePath -Value $formattedContent -NoNewline
                  $fixedFiles += $filePath
                  $appliedFixes += "Formatted $($formattingRules.Count) issues in $filePath"
                  Write-Host "  ‚úÖ Applied formatting fixes"
                } else {
                  Write-Host "  ‚ÑπÔ∏è No formatting changes needed"
                }
              }
              
              # Apply other rule-based fixes
              $otherRules = $fixesToApply | Where-Object {
                $_.RuleName -notin @('PSUseConsistentIndentation', 'PSUseConsistentWhitespace', 'PSPlaceOpenBrace', 'PSPlaceCloseBrace', 'PSAlignAssignmentStatement')
              }
              
              foreach ($rule in $otherRules) {
                switch ($rule.RuleName) {
                  'PSAvoidTrailingWhitespace' {
                    $content = Get-Content $filePath -Raw
                    $newContent = $content -replace '\s+$', ''
                    if ($newContent -ne $content) {
                      Set-Content -Path $filePath -Value $newContent -NoNewline
                      $appliedFixes += "Removed trailing whitespace in $filePath"
                      Write-Host "  ‚úÖ Removed trailing whitespace"
                    }
                  }
                  'PSAvoidSemicolonsAsLineTerminators' {
                    $lines = Get-Content $filePath
                    $modified = $false
                    for ($i = 0; $i -lt $lines.Length; $i++) {
                      if ($lines[$i] -match ';$' -and $lines[$i] -notmatch '["''].*;["'']') {
                        $lines[$i] = $lines[$i] -replace ';$', ''
                        $modified = $true
                      }
                    }
                    if ($modified) {
                      Set-Content -Path $filePath -Value $lines
                      $appliedFixes += "Removed semicolons in $filePath"
                      Write-Host "  ‚úÖ Removed semicolons"
                    }
                  }
                }
              }
              
            } catch {
              Write-Host "  ‚ùå Error processing file: $($_.Exception.Message)"
            }
          }
          
          Write-Host "`nüìä Fix Summary:"
          Write-Host "  Files modified: $($fixedFiles.Count)"
          Write-Host "  Total fixes applied: $($appliedFixes.Count)"
          
          if ($appliedFixes.Count -gt 0) {
            Write-Host "`nüîß Applied fixes:"
            foreach ($fix in $appliedFixes) {
              Write-Host "  - $fix"
            }
          }
          
          # Save fix summary
          @{
            FilesModified = $fixedFiles
            FixesApplied = $appliedFixes
            RemediationType = $remediationType
            Timestamp = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
          } | ConvertTo-Json -Depth 3 | Set-Content "fix-summary.json"
          
          echo "fixes-applied=$($appliedFixes.Count -gt 0 ? 'true' : 'false')" >> $env:GITHUB_OUTPUT
          echo "files-modified=$($fixedFiles.Count)" >> $env:GITHUB_OUTPUT

      - name: Upload fix results
        uses: actions/upload-artifact@v4
        with:
          name: fix-results
          path: fix-summary.json
          retention-days: 30

      - name: Create pull request
        if: steps.apply-fixes.outputs.fixes-applied == 'true' && github.event.inputs.create_pr == 'true'
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action - Code Quality Bot"
          
          # Create branch
          $branchName = "code-quality/auto-fix-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
          git checkout -b $branchName
          
          # Stage changes
          git add .
          
          # Check if there are changes to commit
          $changes = git diff --staged --name-only
          if (-not $changes) {
            Write-Host "No changes to commit"
            exit 0
          }
          
          Write-Host "Changes to commit:"
          foreach ($change in $changes) {
            Write-Host "  - $change"
          }
          
          # Commit changes
          $commitMessage = @"
          Automated code quality fixes (${{ github.event.inputs.remediation_type }})
          
          Applied automatic fixes using PSScriptAnalyzer:
          - Fixed ${{ steps.apply-fixes.outputs.files-modified }} files
          - Remediation type: ${{ github.event.inputs.remediation_type }}
          
          ü§ñ Generated by Code Quality Remediation workflow
          "@ -replace '^\s+', ''
          
          git commit -m $commitMessage
          
          # Push branch
          git push origin $branchName
          
          # Create PR using GitHub CLI
          $prTitle = "üîß Automated Code Quality Fixes (${{ github.event.inputs.remediation_type }})"
          $prBody = @"
          ## ü§ñ Automated Code Quality Fixes
          
          This PR contains automatic fixes applied by the Code Quality Remediation workflow.
          
          ### üìä Summary
          - **Remediation Type**: ${{ github.event.inputs.remediation_type }}
          - **Files Modified**: ${{ steps.apply-fixes.outputs.files-modified }}
          - **Triggered By**: ${{ github.actor }}
          - **Workflow Run**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          ### üîß Fixes Applied
          The following types of issues were automatically fixed:
          - Code formatting and indentation
          - Consistent whitespace usage
          - Brace placement
          - Trailing whitespace removal
          - Semicolon cleanup
          
          ### ‚úÖ Quality Assurance
          - All fixes were applied using PSScriptAnalyzer's built-in formatter
          - No functional changes were made to the code
          - Only formatting and style improvements
          
          ### üìã Next Steps
          1. Review the changes in this PR
          2. Run tests to ensure no functionality is broken
          3. Merge when satisfied with the improvements
          
          *This PR was automatically created by the Code Quality Remediation workflow.*
          "@ -replace '^\s+', ''
          
          gh pr create --title $prTitle --body $prBody --head $branchName --base main
          
          Write-Host "‚úÖ Pull request created successfully"

  generate-report:
    name: "Generate Quality Report"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [analyze-quality, auto-fix]
    if: always() && !cancelled()
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Generate comprehensive report
        run: |
          Write-Host "üìä Generating code quality report..."
          
          $report = @"
# üîß AitherZero Code Quality Report

**Generated**: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
**Workflow**: ${{ github.workflow }}
**Run ID**: ${{ github.run_id }}
**Triggered By**: ${{ github.actor }}

## üìà Quality Metrics

### Analysis Results
- **Total Issues**: ${{ needs.analyze-quality.outputs.issue-count }}
- **Critical Issues**: ${{ needs.analyze-quality.outputs.critical-count }}
- **Analysis Status**: ${{ needs.analyze-quality.result }}

### Remediation Results
- **Remediation Status**: ${{ needs.auto-fix.result }}
- **Remediation Type**: ${{ github.event.inputs.remediation_type }}
- **Dry Run**: ${{ github.event.inputs.dry_run }}
- **Create PR**: ${{ github.event.inputs.create_pr }}

## üéØ Quality Targets

| Metric | Current | Target | Status |
|--------|---------|--------|--------|
| Critical Issues | ${{ needs.analyze-quality.outputs.critical-count }} | 0 | ${{ needs.analyze-quality.outputs.critical-count == '0' ? '‚úÖ' : '‚ùå' }} |
| Total Issues | ${{ needs.analyze-quality.outputs.issue-count }} | < 50 | ${{ needs.analyze-quality.outputs.issue-count < 50 ? '‚úÖ' : '‚ùå' }} |

## üîß Automated Fixes

The workflow can automatically fix the following types of issues:
- ‚úÖ Code formatting and indentation
- ‚úÖ Consistent whitespace usage  
- ‚úÖ Brace placement standardization
- ‚úÖ Trailing whitespace removal
- ‚úÖ Semicolon cleanup
- ‚úÖ Assignment alignment

## üìã Recommendations

"@

          if ([int]"${{ needs.analyze-quality.outputs.critical-count }}" -gt 0) {
            $report += "`n### üö® Critical Issues Detected`n"
            $report += "- Review and fix critical issues manually`n"
            $report += "- Critical issues may indicate functional problems`n"
          }
          
          if ([int]"${{ needs.analyze-quality.outputs.issue-count }}" -gt 50) {
            $report += "`n### üìà High Issue Count`n"
            $report += "- Consider running remediation more frequently`n"
            $report += "- Review coding standards and practices`n"
          }
          
          $report += @"

### ‚úÖ Next Actions
1. Review any critical issues manually
2. Run automated remediation if needed
3. Consider updating coding guidelines
4. Schedule regular quality checks

---
*Report generated by AitherZero Code Quality Remediation workflow*
"@

          $report | Set-Content "quality-report.md"
          Write-Host $report

      - name: Upload quality report
        uses: actions/upload-artifact@v4
        with:
          name: quality-report
          path: quality-report.md
          retention-days: 90

      - name: Quality summary
        run: |
          Write-Host "üìä Code Quality Remediation Summary"
          Write-Host "=================================="
          Write-Host "Analysis: ${{ needs.analyze-quality.result }}"
          Write-Host "Auto-fix: ${{ needs.auto-fix.result }}"
          Write-Host "Issues found: ${{ needs.analyze-quality.outputs.issue-count }}"
          Write-Host "Critical issues: ${{ needs.analyze-quality.outputs.critical-count }}"
          
          if ("${{ needs.analyze-quality.result }}" -eq "failure") {
            Write-Host "::error::Code quality analysis failed"
            exit 1
          }
          
          Write-Host "::notice::Code quality remediation completed"