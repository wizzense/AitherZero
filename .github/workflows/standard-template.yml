# This is the STANDARD TEMPLATE for all AitherZero GitHub Actions workflows
# Every workflow should follow this pattern: minimal GitHub Actions logic,
# maximum use of AitherZero's own orchestration capabilities

name: Standard AitherZero Workflow Template

on:
  # Define your triggers
  push:
    branches: [ main, develop ]
  pull_request:
    types: [ opened, synchronize ]
  workflow_dispatch:
    inputs:
      operation:
        description: 'Operation to perform'
        required: true
        type: choice
        options:
          - test
          - build
          - deploy
          - analyze
          - report

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  execute:
    name: Execute via AitherZero
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]  # Add windows-latest, macos-latest as needed
    
    steps:
    # Step 1: Get the code
    - name: Checkout
      uses: actions/checkout@v4
    
    # Step 2: Let AitherZero bootstrap itself
    - name: Bootstrap AitherZero
      shell: pwsh
      run: |
        # AitherZero knows how to set itself up on any platform
        ./bootstrap.ps1 -NonInteractive -CI
    
    # Step 3: Execute the requested operation using AitherZero
    - name: Execute Operation
      shell: pwsh
      env:
        AITHERZERO_CI: true
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Map the operation to AitherZero commands
        $operation = "${{ github.event.inputs.operation }}"
        
        # For push/PR events, determine operation from context
        if (-not $operation) {
          if ("${{ github.event_name }}" -eq "pull_request") {
            $operation = "test"
          } elseif ("${{ github.event_name }}" -eq "push") {
            $operation = "build"
          } else {
            $operation = "test"
          }
        }
        
        Write-Host "ðŸŽ¯ Operation: $operation" -ForegroundColor Cyan
        
        # Let AitherZero handle it
        switch ($operation) {
          "test" {
            # Run the test playbook
            ./Start-AitherZero.ps1 -Mode Orchestrate -Playbook test-ci -NonInteractive
          }
          "build" {
            # Run build sequence
            ./az 0510 -CI  # Generate project report
            ./az 0511 -CI  # Show dashboard
          }
          "deploy" {
            # Run deployment playbook
            ./Start-AitherZero.ps1 -Mode Orchestrate -Playbook deployment -NonInteractive
          }
          "analyze" {
            # Run analysis sequence
            ./az 0520-0524 -CI  # Complete tech debt analysis
          }
          "report" {
            # Generate all reports
            ./az 0510 -ShowAll -OutputFormat JSON,HTML,Markdown -CI
          }
          default {
            Write-Error "Unknown operation: $operation"
            exit 1
          }
        }
    
    # Step 4: AitherZero handles its own artifact collection
    - name: Collect Artifacts
      if: always()
      shell: pwsh
      run: |
        # AitherZero creates its own artifact structure
        ./az 0512 -PrepareArtifacts -CI
    
    # Step 5: Upload what AitherZero prepared
    - name: Upload Artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: aitherzero-artifacts-${{ matrix.os }}
        path: |
          artifacts/
          reports/
          logs/
        retention-days: 30

# Key principles:
# 1. GitHub Actions is ONLY providing compute and triggers
# 2. AitherZero handles ALL logic, decisions, and execution
# 3. No complex logic in YAML - just call AitherZero
# 4. AitherZero validates itself, tests itself, deploys itself
# 5. The platform is self-sufficient and self-aware