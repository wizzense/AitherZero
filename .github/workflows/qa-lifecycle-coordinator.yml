---
name: QA Lifecycle Coordinator

# Comprehensive QA lifecycle automation that coordinates all quality assurance processes
on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  workflow_dispatch:
    inputs:
      qa_scope:
        description: 'QA Scope'
        type: choice
        options: ['quick', 'standard', 'comprehensive']
        default: 'standard'
      force_full_analysis:
        description: 'Force full QA analysis'
        type: boolean
        default: false
      create_dashboard:
        description: 'Create QA Dashboard'
        type: boolean
        default: true

permissions:
  contents: read
  checks: write
  pull-requests: write
  issues: write
  actions: write

env:
  QA_LIFECYCLE_MODE: true
  AITHERZERO_CI: true
  AITHERZERO_NONINTERACTIVE: true

jobs:
  qa-coordination:
    name: üéØ QA Lifecycle Coordination
    runs-on: ubuntu-latest
    timeout-minutes: 45

    outputs:
      qa-status: ${{ steps.qa-summary.outputs.status }}
      issues-created: ${{ steps.qa-summary.outputs.issues-created }}
      recommendations: ${{ steps.qa-summary.outputs.recommendations }}

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîß Setup AitherZero QA Environment
        shell: pwsh
        run: |
          Write-Host "üéØ Setting up comprehensive QA environment..." -ForegroundColor Magenta
          ./bootstrap.ps1 -Mode New -NonInteractive -InstallProfile Standard

          # Ensure QA directories exist
          @('tests/qa-results', 'qa-reports', 'qa-artifacts') | ForEach-Object {
            if (-not (Test-Path $_)) {
              New-Item -ItemType Directory -Path $_ -Force | Out-Null
              Write-Host "Created QA directory: $_" -ForegroundColor Cyan
            }
          }

          Write-Host "‚úÖ QA environment ready" -ForegroundColor Green

      - name: üîç Comprehensive Quality Analysis
        id: qa-analysis
        shell: pwsh
        env:
          QA_SCOPE: ${{ github.event.inputs.qa_scope || 'standard' }}
          FORCE_ANALYSIS: ${{ github.event.inputs.force_full_analysis || 'false' }}
        run: |
          Write-Host "üîç Starting comprehensive quality analysis..." -ForegroundColor Cyan
          Write-Host "QA Scope: $env:QA_SCOPE" -ForegroundColor White
          Write-Host "Force Analysis: $env:FORCE_ANALYSIS" -ForegroundColor White

          $qaResults = @{
            SyntaxValidation = @{ Status = 'Not Run'; ExitCode = -1; Issues = @() }
            CodeQuality = @{ Status = 'Not Run'; ExitCode = -1; Issues = @() }
            UnitTests = @{ Status = 'Not Run'; ExitCode = -1; Issues = @() }
            IntegrationTests = @{ Status = 'Not Run'; ExitCode = -1; Issues = @() }
            SecurityAnalysis = @{ Status = 'Not Run'; ExitCode = -1; Issues = @() }
            OverallStatus = 'Unknown'
            TotalIssues = 0
            CriticalIssues = 0
            Recommendations = @()
          }

          # 1. Syntax Validation (Always run)
          Write-Host "üîç Phase 1: Syntax Validation" -ForegroundColor Yellow
          try {
            $syntaxResult = & ./Start-AitherZero.ps1 -Mode Orchestrate -Sequence "0407" -NonInteractive
            $syntaxExitCode = $LASTEXITCODE

            if ($syntaxExitCode -eq 0) {
              $qaResults.SyntaxValidation.Status = 'Passed'
              Write-Host "  ‚úÖ Syntax validation passed" -ForegroundColor Green
            } else {
              $qaResults.SyntaxValidation.Status = 'Failed'
              $qaResults.SyntaxValidation.Issues += 'Syntax validation failed'
              Write-Host "  ‚ùå Syntax validation failed (exit code: $syntaxExitCode)" -ForegroundColor Red
            }
            $qaResults.SyntaxValidation.ExitCode = $syntaxExitCode
          } catch {
            $qaResults.SyntaxValidation.Status = 'Error'
            $qaResults.SyntaxValidation.Issues += "Syntax validation error: $_"
            Write-Host "  üí• Syntax validation error: $_" -ForegroundColor Red
          }

          # 2. Code Quality Analysis
          Write-Host "üîç Phase 2: Code Quality Analysis" -ForegroundColor Yellow
          try {
            $codeQualityResult = & ./Start-AitherZero.ps1 -Mode Orchestrate -Sequence "0404" -NonInteractive
            $codeQualityExitCode = $LASTEXITCODE

            if ($codeQualityExitCode -eq 0) {
              $qaResults.CodeQuality.Status = 'Passed'
              Write-Host "  ‚úÖ Code quality analysis passed" -ForegroundColor Green
            } else {
              $qaResults.CodeQuality.Status = 'Issues Found'
              $qaResults.CodeQuality.Issues += 'PSScriptAnalyzer found issues'
              Write-Host "  ‚ö†Ô∏è Code quality issues found (exit code: $codeQualityExitCode)" -ForegroundColor Yellow
            }
            $qaResults.CodeQuality.ExitCode = $codeQualityExitCode
          } catch {
            $qaResults.CodeQuality.Status = 'Error'
            $qaResults.CodeQuality.Issues += "Code quality analysis error: $_"
            Write-Host "  üí• Code quality analysis error: $_" -ForegroundColor Red
          }

          # 3. Unit Tests
          Write-Host "üîç Phase 3: Unit Testing" -ForegroundColor Yellow
          try {
            $unitTestResult = & ./Start-AitherZero.ps1 -Mode Orchestrate -Sequence "0402" -NonInteractive
            $unitTestExitCode = $LASTEXITCODE

            if ($unitTestExitCode -eq 0) {
              $qaResults.UnitTests.Status = 'Passed'
              Write-Host "  ‚úÖ Unit tests passed" -ForegroundColor Green
            } else {
              $qaResults.UnitTests.Status = 'Failed'
              $qaResults.UnitTests.Issues += 'Unit test failures detected'
              $qaResults.CriticalIssues++
              Write-Host "  ‚ùå Unit tests failed (exit code: $unitTestExitCode)" -ForegroundColor Red
            }
            $qaResults.UnitTests.ExitCode = $unitTestExitCode
          } catch {
            $qaResults.UnitTests.Status = 'Error'
            $qaResults.UnitTests.Issues += "Unit test execution error: $_"
            Write-Host "  üí• Unit test execution error: $_" -ForegroundColor Red
          }

          # 4. Integration Tests (if standard or comprehensive)
          if ($env:QA_SCOPE -in @('standard', 'comprehensive')) {
            Write-Host "üîç Phase 4: Integration Testing" -ForegroundColor Yellow
            try {
              $integrationResult = & ./Start-AitherZero.ps1 -Mode Orchestrate -Sequence "0403" -NonInteractive
              $integrationExitCode = $LASTEXITCODE

              if ($integrationExitCode -eq 0) {
                $qaResults.IntegrationTests.Status = 'Passed'
                Write-Host "  ‚úÖ Integration tests passed" -ForegroundColor Green
              } else {
                $qaResults.IntegrationTests.Status = 'Failed'
                $qaResults.IntegrationTests.Issues += 'Integration test failures detected'
                Write-Host "  ‚ö†Ô∏è Integration tests failed (exit code: $integrationExitCode)" -ForegroundColor Yellow
              }
              $qaResults.IntegrationTests.ExitCode = $integrationExitCode
            } catch {
              $qaResults.IntegrationTests.Status = 'Error'
              $qaResults.IntegrationTests.Issues += "Integration test error: $_"
              Write-Host "  üí• Integration test error: $_" -ForegroundColor Red
            }
          }

          # Calculate overall status and recommendations
          $allIssues = @()
          $qaResults.Values | Where-Object { $_ -is [hashtable] -and $_.Issues } | ForEach-Object { $allIssues += $_.Issues }
          $qaResults.TotalIssues = $allIssues.Count

          # Determine overall status
          $failedPhases = @($qaResults.Values | Where-Object { $_ -is [hashtable] -and $_.Status -in @('Failed', 'Error') }).Count
          $criticalFailures = @($qaResults.SyntaxValidation, $qaResults.UnitTests | Where-Object { $_.Status -in @('Failed', 'Error') }).Count

          if ($criticalFailures -gt 0) {
            $qaResults.OverallStatus = 'Critical Issues'
          } elseif ($failedPhases -gt 0) {
            $qaResults.OverallStatus = 'Issues Found'
          } else {
            $qaResults.OverallStatus = 'Passed'
          }

          # Generate recommendations
          if ($qaResults.SyntaxValidation.Status -ne 'Passed') {
            $qaResults.Recommendations += 'Fix syntax errors before proceeding with other changes'
          }
          if ($qaResults.CodeQuality.Status -eq 'Issues Found') {
            $qaResults.Recommendations += 'Address PSScriptAnalyzer findings to improve code quality'
          }
          if ($qaResults.UnitTests.Status -ne 'Passed') {
            $qaResults.Recommendations += 'Fix failing unit tests - this blocks merging'
          }
          if ($qaResults.IntegrationTests.Status -eq 'Failed') {
            $qaResults.Recommendations += 'Investigate integration test failures for system compatibility'
          }

          # Save results for later steps
          $qaResults | ConvertTo-Json -Depth 3 | Set-Content "qa-results.json"

          # Set step outputs
          echo "status=$($qaResults.OverallStatus)" >> $env:GITHUB_OUTPUT
          echo "total-issues=$($qaResults.TotalIssues)" >> $env:GITHUB_OUTPUT
          echo "critical-issues=$($qaResults.CriticalIssues)" >> $env:GITHUB_OUTPUT

          Write-Host ""
          Write-Host "üìä QA Analysis Summary:" -ForegroundColor Magenta
          Write-Host "  Overall Status: $($qaResults.OverallStatus)" -ForegroundColor White
          Write-Host "  Total Issues: $($qaResults.TotalIssues)" -ForegroundColor White
          Write-Host "  Critical Issues: $($qaResults.CriticalIssues)" -ForegroundColor White
          Write-Host "  Recommendations: $($qaResults.Recommendations.Count)" -ForegroundColor White

      - name: üìä Generate QA Dashboard
        if: always() && github.event.inputs.create_dashboard != 'false'
        shell: pwsh
        run: |
          Write-Host "üìä Generating comprehensive QA dashboard..." -ForegroundColor Cyan

          # Read QA results
          $qaResults = Get-Content "qa-results.json" | ConvertFrom-Json

          # Generate dashboard HTML (simplified to avoid YAML conflicts)
          $prNumber = "${{ github.event.pull_request.number || 'N/A' }}"
          $qaScope = "${{ github.event.inputs.qa_scope || 'standard' }}"
          $repoName = "${{ github.repository }}"
          $runId = "${{ github.run_id }}"

          $dashboard = "<!DOCTYPE html>`n<html>`n<head>`n"
          $dashboard += "<title>AitherZero QA Dashboard - PR #$prNumber</title>`n"
          $dashboard += '<style>body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;margin:20px}'
          $dashboard += '.status-passed{color:#28a745}.status-failed{color:#dc3545}.status-issues{color:#ffc107}'
          $dashboard += '.card{border:1px solid #e1e4e8;border-radius:6px;padding:16px;margin:16px 0}'
          $dashboard += '.critical{border-left:4px solid #dc3545}.warning{border-left:4px solid #ffc107}'
          $dashboard += '.success{border-left:4px solid #28a745}</style>`n</head>`n<body>`n"
          $dashboard += "<h1>üéØ AitherZero QA Dashboard</h1>`n"

          $cssClass = if ($qaResults.OverallStatus -eq 'Passed') { 'success' }
                     elseif ($qaResults.OverallStatus -eq 'Critical Issues') { 'critical' }
                     else { 'warning' }

          $dashboard += "<div class=`"card $cssClass`">`n"
          $dashboard += "<h2>üìä Overall Status: $($qaResults.OverallStatus)</h2>`n"
          $dashboard += "<p><strong>Total Issues:</strong> $($qaResults.TotalIssues)</p>`n"
          $dashboard += "<p><strong>Critical Issues:</strong> $($qaResults.CriticalIssues)</p>`n"
          $dashboard += "<p><strong>QA Scope:</strong> $qaScope</p>`n"
          $dashboard += "<p><strong>Timestamp:</strong> $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')</p>`n"
          $dashboard += "</div>`n"

          $dashboard += "<div class=`"card`">`n<h3>üîç Quality Analysis Results</h3>`n<ul>`n"
          $dashboard += "<li><strong>Syntax Validation:</strong> $($qaResults.SyntaxValidation.Status)</li>`n"
          $dashboard += "<li><strong>Code Quality:</strong> $($qaResults.CodeQuality.Status)</li>`n"
          $dashboard += "<li><strong>Unit Tests:</strong> $($qaResults.UnitTests.Status)</li>`n"
          $dashboard += "<li><strong>Integration Tests:</strong> $($qaResults.IntegrationTests.Status)</li>`n"
          $dashboard += "</ul>`n</div>`n"

          if ($qaResults.Recommendations -and $qaResults.Recommendations.Count -gt 0) {
            $dashboard += "<div class=`"card warning`">`n<h3>üí° Recommendations</h3>`n<ul>`n"
            foreach ($recommendation in $qaResults.Recommendations) {
              $dashboard += "<li>$recommendation</li>`n"
            }
            $dashboard += "</ul>`n</div>`n"
          }

          $dashboard += "<div class=`"card`">`n<h3>üîß Local Commands</h3>`n"
          $dashboard += "<p>Run these commands locally to reproduce and fix issues:</p>`n<ul>`n"
          $dashboard += "<li><code>./az.ps1 0407</code> - Syntax validation</li>`n"
          $dashboard += "<li><code>./az.ps1 0404</code> - Code quality analysis</li>`n"
          $dashboard += "<li><code>./az.ps1 0402</code> - Unit tests</li>`n"
          $dashboard += "<li><code>./az.ps1 0403</code> - Integration tests</li>`n"
          $dashboard += "<li><code>./az.ps1 0510</code> - Generate comprehensive report</li>`n"
          $dashboard += "</ul>`n</div>`n"

          $dashboard += "<div class=`"card`">`n<h3>üîó Resources</h3>`n<ul>`n"
          $dashboard += "<li><a href=`"https://github.com/$repoName/actions/runs/$runId`">View Workflow Run</a></li>`n"
          $dashboard += "<li><a href=`"https://github.com/$repoName/pull/$prNumber`">View Pull Request</a></li>`n"
          $dashboard += "<li><a href=`"https://github.com/wizzense/AitherZero#automation-scripts`">AitherZero Documentation</a></li>`n"
          $dashboard += "</ul>`n</div>`n</body>`n</html>`n"

          $dashboard | Set-Content "qa-dashboard.html"
          Write-Host "‚úÖ QA Dashboard generated" -ForegroundColor Green

      - name: üìã Generate QA Summary
        id: qa-summary
        if: always()
        shell: pwsh
        run: |
          Write-Host "üìã Generating QA lifecycle summary..." -ForegroundColor Cyan

          # Read results if available
          $qaResults = @{ OverallStatus = 'Unknown'; TotalIssues = 0; Recommendations = @() }
          if (Test-Path "qa-results.json") {
            $qaResults = Get-Content "qa-results.json" | ConvertFrom-Json
          }

          # Count issues created (would be updated by issue creation logic)
          $issuesCreated = 0  # This would be set by actual issue creation

          # Set outputs for other jobs/workflows
          echo "status=$($qaResults.OverallStatus)" >> $env:GITHUB_OUTPUT
          echo "issues-created=$issuesCreated" >> $env:GITHUB_OUTPUT
          echo "recommendations=$($qaResults.Recommendations -join ';')" >> $env:GITHUB_OUTPUT

          Write-Host "‚úÖ QA lifecycle coordination completed!" -ForegroundColor Green

      - name: üì§ Upload QA Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: qa-lifecycle-results-${{ github.run_id }}
          path: |
            qa-results.json
            qa-dashboard.html
            tests/qa-results/
            qa-reports/
            qa-artifacts/
            tests/analysis/
            tests/results/
            reports/
          retention-days: 30

      - name: üí¨ Update PR with QA Status
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          QA_SCOPE: ${{ github.event.inputs.qa_scope || 'standard' }}
        with:
          script: |
            const fs = require('fs');

            let qaResults = { OverallStatus: 'Unknown', TotalIssues: 0, Recommendations: [] };
            try {
              if (fs.existsSync('qa-results.json')) {
                qaResults = JSON.parse(fs.readFileSync('qa-results.json', 'utf8'));
              }
            } catch (error) {
              console.log('Could not read QA results:', error.message);
            }

            const status = qaResults.OverallStatus;
            let statusEmoji = 'üìä';
            let statusColor = 'yellow';

            if (status === 'Passed') {
              statusEmoji = '‚úÖ';
              statusColor = 'green';
            } else if (status === 'Critical Issues') {
              statusEmoji = '‚ùå';
              statusColor = 'red';
            } else if (status === 'Issues Found') {
              statusEmoji = '‚ö†Ô∏è';
              statusColor = 'orange';
            }

            let comment = '## üéØ QA Lifecycle Report ' + statusEmoji + '\n\n';
            comment += '**Overall Status:** ' + status + '\n';
            comment += '**Total Issues:** ' + qaResults.TotalIssues + '\n';
            comment += '**QA Scope:** ' + process.env.QA_SCOPE + '\n\n';
            comment += '### üìä Quality Analysis Results\n\n';
            comment += '| Phase | Status | Details |\n';
            comment += '|-------|--------|---------|\n';
            comment += '| üîç Syntax Validation | ' + (qaResults.SyntaxValidation?.Status || 'Not Run') + ' | ' + (qaResults.SyntaxValidation?.ExitCode === 0 ? 'All syntax checks passed' : 'Issues detected') + ' |\n';
            comment += '| üìù Code Quality | ' + (qaResults.CodeQuality?.Status || 'Not Run') + ' | ' + (qaResults.CodeQuality?.ExitCode === 0 ? 'No PSScriptAnalyzer issues' : 'Quality improvements needed') + ' |\n';
            comment += '| üß™ Unit Tests | ' + (qaResults.UnitTests?.Status || 'Not Run') + ' | ' + (qaResults.UnitTests?.ExitCode === 0 ? 'All tests passing' : 'Test failures detected') + ' |\n';
            comment += '| üîó Integration Tests | ' + (qaResults.IntegrationTests?.Status || 'Not Run') + ' | ' + (qaResults.IntegrationTests?.Status === 'Not Run' ? 'Skipped for quick QA' : (qaResults.IntegrationTests?.ExitCode === 0 ? 'Integration successful' : 'Integration issues')) + ' |\n\n';

            if (qaResults.Recommendations && qaResults.Recommendations.length > 0) {
              comment += '### üí° Recommendations\n\n';
              qaResults.Recommendations.forEach(rec => {
                comment += '- ' + rec + '\n';
              });
              comment += '\n';
            }

            comment += '### üîß Quick Actions\n\n';

            comment += '**Local Testing:**\n';
            comment += '```bash\n';
            comment += './az.ps1 0407  # Syntax validation\n';
            comment += './az.ps1 0404  # Code quality check\n';
            comment += './az.ps1 0402  # Run unit tests\n';
            comment += '```\n\n';
            comment += '**Resources:**\n';
            comment += '- üìä [QA Dashboard](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\n';
            comment += '- üîç [Detailed Artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\n';
            comment += '- üìö [AitherZero Docs](https://github.com/wizzense/AitherZero#automation-scripts)\n\n';
            comment += '---\n';
            comment += '*ü§ñ Automated QA lifecycle powered by AitherZero\'s comprehensive testing framework*';

            // Find and update existing comment or create new one
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const existingComment = comments.find(c =>
              c.user.login === 'github-actions[bot]' &&
              c.body.includes('üéØ QA Lifecycle Report')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: comment
              });
              console.log('Updated existing QA lifecycle comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              console.log('Created new QA lifecycle comment');
            }
