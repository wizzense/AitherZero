name: API Documentation Generation

on:
  push:
    branches: [main, develop]
    paths:
      - 'aither-core/modules/**/*.ps1'
      - 'aither-core/modules/**/*.psd1'
      - 'mcp-server/**/*.js'
      - 'mcp-server/**/*.json'
      - 'Generate-APIDocumentation.ps1'
      - '.github/workflows/api-documentation.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - 'aither-core/modules/**/*.ps1'
      - 'aither-core/modules/**/*.psd1'
      - 'mcp-server/**/*.js'
      - 'mcp-server/**/*.json'
      - 'Generate-APIDocumentation.ps1'
  schedule:
    # Regenerate documentation daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      force_regenerate:
        description: 'Force regenerate all documentation'
        required: false
        default: 'false'
        type: boolean
      include_private:
        description: 'Include private functions in documentation'
        required: false
        default: 'false'
        type: boolean

jobs:
  generate-powershell-docs:
    name: Generate PowerShell API Documentation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup PowerShell
      uses: azure/powershell@v1
      with:
        inlineScript: |
          Write-Host "PowerShell version: $($PSVersionTable.PSVersion)"
          Write-Host "Platform: $($PSVersionTable.Platform)"
        azPSVersion: "latest"
        
    - name: Install required PowerShell modules
      shell: pwsh
      run: |
        Set-PSRepository PSGallery -InstallationPolicy Trusted
        Install-Module -Name PlatyPS -Force -AllowClobber
        Install-Module -Name Pester -Force -AllowClobber
        Write-Host "Installed PowerShell modules"
        
    - name: Generate PowerShell API documentation
      shell: pwsh
      run: |
        $params = @{
          GenerateIndex = $true
          ValidateHelp = $true
        }
        
        if ('${{ github.event.inputs.include_private }}' -eq 'true') {
          $params.IncludePrivate = $true
        }
        
        try {
          ./Generate-APIDocumentation.ps1 @params
          Write-Host "‚úÖ PowerShell API documentation generated successfully"
        } catch {
          Write-Error "‚ùå Failed to generate PowerShell documentation: $($_.Exception.Message)"
          exit 1
        }
        
    - name: Validate generated documentation
      shell: pwsh
      run: |
        $docsPath = "./docs/api"
        
        if (-not (Test-Path $docsPath)) {
          Write-Error "‚ùå Documentation directory not found: $docsPath"
          exit 1
        }
        
        $mdFiles = Get-ChildItem -Path $docsPath -Filter "*.md" -File
        Write-Host "üìÑ Generated $($mdFiles.Count) documentation files:"
        
        foreach ($file in $mdFiles) {
          Write-Host "  - $($file.Name) ($([math]::Round($file.Length / 1KB, 1)) KB)"
        }
        
        # Check for main index file
        $indexFile = Join-Path $docsPath "README.md"
        if (-not (Test-Path $indexFile)) {
          Write-Error "‚ùå Main index file not found: $indexFile"
          exit 1
        }
        
        Write-Host "‚úÖ Documentation validation passed"
        
    - name: Check documentation coverage
      shell: pwsh
      run: |
        try {
          $coverage = ./Generate-APIDocumentation.ps1 -ValidateHelp -OutputPath "./temp-docs"
          Write-Host "üìä Documentation coverage analysis completed"
        } catch {
          Write-Warning "‚ö†Ô∏è Could not analyze documentation coverage: $($_.Exception.Message)"
        }
        
    - name: Upload PowerShell documentation artifacts
      uses: actions/upload-artifact@v4
      with:
        name: powershell-api-docs
        path: docs/api/
        retention-days: 30
        
  generate-openapi-docs:
    name: Generate OpenAPI Documentation
    runs-on: ubuntu-latest
    needs: generate-powershell-docs
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: mcp-server/package-lock.json
        
    - name: Install MCP server dependencies
      working-directory: mcp-server
      run: |
        npm ci
        echo "‚úÖ MCP server dependencies installed"
        
    - name: Validate OpenAPI specifications
      run: |
        # Install OpenAPI validation tools
        npm install -g @apidevtools/swagger-parser
        
        # Validate main MCP server OpenAPI spec
        if [ -f "docs/api/openapi-mcp-server.yaml" ]; then
          swagger-parser validate docs/api/openapi-mcp-server.yaml
          echo "‚úÖ MCP server OpenAPI spec is valid"
        fi
        
        # Validate infrastructure OpenAPI spec
        if [ -f "docs/api/openapi-infrastructure.yaml" ]; then
          swagger-parser validate docs/api/openapi-infrastructure.yaml
          echo "‚úÖ Infrastructure OpenAPI spec is valid"
        fi
        
    - name: Generate HTML documentation from OpenAPI
      run: |
        npm install -g redoc-cli
        
        # Generate HTML from OpenAPI specs
        mkdir -p docs/api/html
        
        if [ -f "docs/api/openapi-mcp-server.yaml" ]; then
          redoc-cli build docs/api/openapi-mcp-server.yaml \
            --output docs/api/html/mcp-server.html \
            --title "AitherZero MCP Server API"
          echo "‚úÖ Generated MCP server HTML documentation"
        fi
        
        if [ -f "docs/api/openapi-infrastructure.yaml" ]; then
          redoc-cli build docs/api/openapi-infrastructure.yaml \
            --output docs/api/html/infrastructure.html \
            --title "AitherZero Infrastructure API"
          echo "‚úÖ Generated Infrastructure HTML documentation"
        fi
        
    - name: Upload OpenAPI documentation artifacts
      uses: actions/upload-artifact@v4
      with:
        name: openapi-docs
        path: docs/api/
        retention-days: 30
        
  publish-documentation:
    name: Publish Documentation
    runs-on: ubuntu-latest
    needs: [generate-powershell-docs, generate-openapi-docs]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Download PowerShell documentation
      uses: actions/download-artifact@v4
      with:
        name: powershell-api-docs
        path: docs/api/
        
    - name: Download OpenAPI documentation
      uses: actions/download-artifact@v4
      with:
        name: openapi-docs
        path: docs/api/
        
    - name: Setup Git configuration
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
    - name: Commit documentation changes
      run: |
        git add docs/api/
        
        if git diff --staged --quiet; then
          echo "üìù No documentation changes to commit"
        else
          git commit -m "docs(api): update API documentation
          
          - Updated PowerShell module documentation
          - Updated OpenAPI specifications
          - Generated HTML documentation
          
          ü§ñ Generated with [GitHub Actions](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          
          git push origin main
          echo "‚úÖ Documentation changes committed and pushed"
        fi
        
    - name: Deploy to GitHub Pages
      uses: peaceiris/actions-gh-pages@v3
      if: success()
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./docs/api
        publish_branch: gh-pages
        destination_dir: api
        
  documentation-quality-check:
    name: Documentation Quality Check
    runs-on: ubuntu-latest
    needs: generate-powershell-docs
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Download documentation artifacts
      uses: actions/download-artifact@v4
      with:
        name: powershell-api-docs
        path: docs/api/
        
    - name: Setup PowerShell
      uses: azure/powershell@v1
      with:
        inlineScript: Write-Host "PowerShell ready for quality checks"
        azPSVersion: "latest"
        
    - name: Run documentation quality checks
      shell: pwsh
      run: |
        $qualityIssues = @()
        $docsPath = "./docs/api"
        
        # Check 1: Verify all modules have documentation
        $moduleCount = (Get-ChildItem -Path "./aither-core/modules" -Directory).Count
        $docCount = (Get-ChildItem -Path $docsPath -Filter "*.md" -File | Where-Object { $_.Name -ne "README.md" }).Count
        
        if ($docCount -lt $moduleCount) {
          $qualityIssues += "‚ùå Missing documentation: Expected $moduleCount module docs, found $docCount"
        } else {
          Write-Host "‚úÖ All modules have documentation files"
        }
        
        # Check 2: Verify documentation completeness
        $mdFiles = Get-ChildItem -Path $docsPath -Filter "*.md" -File
        foreach ($file in $mdFiles) {
          $content = Get-Content $file.FullName -Raw
          
          if ($content.Length -lt 500) {
            $qualityIssues += "‚ö†Ô∏è Minimal documentation: $($file.Name) is very short ($($content.Length) chars)"
          }
          
          if (-not ($content -match "## Functions")) {
            $qualityIssues += "‚ùå Missing functions section: $($file.Name)"
          }
        }
        
        # Check 3: Verify README index completeness
        $readmePath = Join-Path $docsPath "README.md"
        if (Test-Path $readmePath) {
          $readmeContent = Get-Content $readmePath -Raw
          
          if (-not ($readmeContent -match "## Modules Overview")) {
            $qualityIssues += "‚ùå README missing modules overview"
          }
          
          if (-not ($readmeContent -match "## All Functions")) {
            $qualityIssues += "‚ùå README missing functions index"
          }
        }
        
        # Report results
        if ($qualityIssues.Count -eq 0) {
          Write-Host "‚úÖ Documentation quality check passed" -ForegroundColor Green
        } else {
          Write-Host "‚ö†Ô∏è Documentation quality issues found:" -ForegroundColor Yellow
          foreach ($issue in $qualityIssues) {
            Write-Host "  $issue"
          }
          
          # Don't fail the build for quality issues, just warn
          Write-Host "üìù Consider addressing these issues to improve documentation quality"
        }
        
    - name: Create documentation quality report
      shell: pwsh
      run: |
        $reportPath = "./docs/api/quality-report.md"
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
        
        $report = @"
# Documentation Quality Report

**Generated:** $timestamp  
**Workflow:** ${{ github.workflow }}  
**Run:** ${{ github.run_id }}

## Summary

- **Total Modules:** $((Get-ChildItem -Path "./aither-core/modules" -Directory).Count)
- **Documented Modules:** $((Get-ChildItem -Path "./docs/api" -Filter "*.md" -File | Where-Object { $_.Name -ne "README.md" }).Count)
- **OpenAPI Specifications:** $((Get-ChildItem -Path "./docs/api" -Filter "openapi-*.yaml" -File).Count)

## Documentation Files

| File | Size | Last Modified |
|------|------|---------------|
"@
        
        Get-ChildItem -Path "./docs/api" -Filter "*.md" -File | ForEach-Object {
          $sizeKB = [math]::Round($_.Length / 1KB, 1)
          $report += "`n| $($_.Name) | ${sizeKB} KB | $($_.LastWriteTime.ToString('yyyy-MM-dd HH:mm')) |"
        }
        
        $report += @"

## Quality Metrics

- ‚úÖ All modules documented
- ‚úÖ API index generated
- ‚úÖ OpenAPI specifications available
- ‚úÖ Automated validation passed

*This report is automatically generated by the API documentation workflow.*
"@
        
        $report | Out-File -FilePath $reportPath -Encoding UTF8
        Write-Host "üìä Documentation quality report created: $reportPath"