name: Build and Release

on:
  # Only create releases on manual trigger or version tags
  push:
    tags: ['v*']  # Only trigger on version tags like v1.0.0
    branches: [main, master]
  pull_request:
    branches: [main, master]
    types: [closed]  # Only trigger on closed (merged) PRs

  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release Type'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
          - prerelease
      create_release:
        description: 'Create GitHub Release'
        required: true
        default: true
        type: boolean

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1

# Prevent conflicts with other workflows and duplicate runs
concurrency:
  group: build-release-${{ github.workflow }}-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: false  # Don't cancel release builds

permissions:
  contents: write
  packages: write
  repository-projects: write
  issues: write
  pull-requests: write

jobs:
  version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should-build: ${{ steps.check.outputs.should-build }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Version
        id: version
        shell: pwsh
        run: |
          Write-Host "Determining release version..." -ForegroundColor Cyan

          $version = ""

          if ("${{ github.ref_type }}" -eq "tag") {
            $tagName = "${{ github.ref_name }}"
            if ($tagName -match '^v?(.+)$') {
              $version = $matches[1]
              Write-Host "Using tag version: $version" -ForegroundColor Green
            }
          }

          if ([string]::IsNullOrEmpty($version) -and "${{ github.event.inputs.release_type }}" -ne "") {
            $latestTag = git describe --tags --abbrev=0 2>$null
            if ($latestTag) {
              $currentVersion = $latestTag -replace '^v', ''
              Write-Host "Current version from git: $currentVersion" -ForegroundColor Yellow

              if ($currentVersion -match '^(\d+)\.(\d+)\.(\d+)') {
                $major = [int]$matches[1]
                $minor = [int]$matches[2]
                $patch = [int]$matches[3]

                switch ("${{ github.event.inputs.release_type }}") {
                  "major" { $version = "$($major + 1).0.0" }
                  "minor" { $version = "$major.$($minor + 1).0" }
                  "patch" { $version = "$major.$minor.$($patch + 1)" }
                  "prerelease" { $version = "$major.$minor.$($patch + 1)-pre.$([DateTimeOffset]::UtcNow.ToUnixTimeSeconds())" }
                }
              }
            } else {
              $version = "1.0.0"
            }
            Write-Host "Calculated new version: $version" -ForegroundColor Green
          }

          # Version determination logic - removed release event handling

          if ([string]::IsNullOrEmpty($version) -and
              "${{ github.event_name }}" -eq "pull_request" -and
              "${{ github.event.pull_request.merged }}" -eq "true" -and
              ("${{ github.event.pull_request.base.ref }}" -eq "main" -or "${{ github.event.pull_request.base.ref }}" -eq "master")) {

            $latestTag = git describe --tags --abbrev=0 2>$null
            if ($latestTag) {
              $currentVersion = $latestTag -replace '^v', ''
              if ($currentVersion -match '^(\d+)\.(\d+)\.(\d+)') {
                $major = [int]$matches[1]
                $minor = [int]$matches[2]
                $patch = [int]$matches[3]
                $version = "$major.$minor.$($patch + 1)"
                Write-Host "Auto-incrementing patch version for merged PR: $version" -ForegroundColor Green
              }
            } else {
              $version = "1.0.0"
            }
          }

          if ([string]::IsNullOrEmpty($version) -and
              "${{ github.event_name }}" -eq "push" -and
              ("${{ github.ref }}" -eq "refs/heads/main" -or "${{ github.ref }}" -eq "refs/heads/master")) {

            $latestTag = git describe --tags --abbrev=0 2>$null
            if ($latestTag) {
              $currentVersion = $latestTag -replace '^v', ''
              if ($currentVersion -match '^(\d+)\.(\d+)\.(\d+)') {
                $major = [int]$matches[1]
                $minor = [int]$matches[2]
                $patch = [int]$matches[3]
                $version = "$major.$minor.$($patch + 1)"
                Write-Host "Auto-incrementing patch version for main branch push: $version" -ForegroundColor Green
              }
            } else {
              $version = "1.0.0"
            }
          }

          if ([string]::IsNullOrEmpty($version)) {
            $timestamp = Get-Date -Format "yyyy.MM.dd.HHmm"
            $version = "0.0.$timestamp"
            Write-Host "Using fallback timestamp version: $version" -ForegroundColor Yellow
          }

          Write-Host "Final version determined: $version" -ForegroundColor Green
          echo "version=$version" >> $env:GITHUB_OUTPUT

      - name: Check if build should proceed
        id: check
        shell: pwsh
        run: |
          $shouldBuild = $false

          if ("${{ github.event_name }}" -eq "push" -and "${{ github.ref_type }}" -eq "tag") {
            $shouldBuild = $true
            Write-Host "‚úì Tag push - proceeding with build" -ForegroundColor Green
          } elseif ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $shouldBuild = $true
            Write-Host "‚úì Manual dispatch - proceeding with build" -ForegroundColor Green
          } elseif ("${{ github.event_name }}" -eq "pull_request" -and
                    "${{ github.event.pull_request.merged }}" -eq "true" -and
                    ("${{ github.event.pull_request.base.ref }}" -eq "main" -or "${{ github.event.pull_request.base.ref }}" -eq "master")) {
            $shouldBuild = $true
            Write-Host "‚úì PR merged to main/master - proceeding with build" -ForegroundColor Green
          } elseif ("${{ github.event_name }}" -eq "push" -and
                    ("${{ github.ref }}" -eq "refs/heads/main" -or "${{ github.ref }}" -eq "refs/heads/master")) {
            $shouldBuild = $true
            Write-Host "‚úì Push to main/master - proceeding with build" -ForegroundColor Green
          } else {
            Write-Host "‚úó Event does not trigger build: ${{ github.event_name }}" -ForegroundColor Yellow
          }

          Write-Host "Should build: $shouldBuild" -ForegroundColor Cyan
          echo "should-build=$shouldBuild" >> $env:GITHUB_OUTPUT

  validate:
    name: Pre-Build Validation (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: version
    if: needs.version.outputs.should-build == 'true'

    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup PowerShell Environment
        shell: pwsh
        run: |
          Write-Host "Setting up PowerShell environment on ${{ matrix.os }}..." -ForegroundColor Cyan
          echo "POWERSHELL_TELEMETRY_OPTOUT=1" >> $env:GITHUB_ENV
          echo "PROJECT_ROOT=$PWD" >> $env:GITHUB_ENV

          if ($IsWindows) {
            $env:PATH_SEPARATOR = ";"
          } else {
            $env:PATH_SEPARATOR = ":"
          }

          Write-Host "‚úì Environment initialized for ${{ matrix.os }}" -ForegroundColor Green

      - name: Run Cross-Platform Validation
        shell: pwsh
        run: |
          Write-Host "Running pre-build validation on ${{ matrix.os }}..." -ForegroundColor Cyan

          $ErrorActionPreference = 'Stop'

          try {
            if (Test-Path './tests/Run-BulletproofValidation.ps1') {
              Write-Host "Running bulletproof validation..." -ForegroundColor Yellow
              pwsh -File './tests/Run-BulletproofValidation.ps1' -ValidationLevel 'Quick' -CI -FailFast
            } else {
              Write-Host "No bulletproof validation found, running basic checks" -ForegroundColor Yellow

              if (Test-Path './aither-core/modules') {
                $modules = Get-ChildItem -Path './aither-core/modules' -Directory
                foreach ($module in $modules) {
                  try {
                    if (-not $module.FullName) {
                      throw "Module $($module.Name) does not have a valid path (FullName is null)"
                    }
                    Write-Host "Testing module: $($module.Name)" -ForegroundColor Cyan
                    Import-Module $module.FullName -Force -ErrorAction Stop
                    Write-Host "‚úì Module $($module.Name) imports successfully" -ForegroundColor Green
                  } catch {
                    Write-Error "Module $($module.Name) failed to import: $($_.Exception.Message)"
                    exit 1
                  }
                }
              }
            }

            Write-Host "‚úì Pre-build validation completed successfully on ${{ matrix.os }}" -ForegroundColor Green

          } catch {
            Write-Error "Pre-build validation failed on ${{ matrix.os }}: $($_.Exception.Message)"
            exit 1
          }

  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: [version, validate]
    if: needs.version.outputs.should-build == 'true'

    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            artifact_extension: tar.gz
          - os: windows-latest
            platform: windows
            artifact_extension: zip
          - os: macos-latest
            platform: macos
            artifact_extension: tar.gz

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Build Environment
        shell: pwsh
        run: |
          Write-Host "Setting up build environment for ${{ matrix.platform }}..." -ForegroundColor Cyan

          $version = "${{ needs.version.outputs.version }}"
          echo "BUILD_VERSION=$version" >> $env:GITHUB_ENV
          echo "PROJECT_ROOT=$PWD" >> $env:GITHUB_ENV

          Write-Host "‚úì Environment configured for ${{ matrix.platform }}" -ForegroundColor Green

      - name: Build AitherZero Package
        shell: pwsh
        run: |
          Write-Host "Building lean AitherZero application package for ${{ matrix.platform }}..." -ForegroundColor Cyan

          $ErrorActionPreference = 'Stop'
          $version = "${{ needs.version.outputs.version }}"

          try {
            $buildDir = "build-output/${{ matrix.platform }}"
            New-Item -Path $buildDir -ItemType Directory -Force | Out-Null

            $packageName = "AitherZero-$version-${{ matrix.platform }}"
            $packageDir = "$buildDir/$packageName"
            New-Item -Path $packageDir -ItemType Directory -Force | Out-Null

            Write-Host "Creating lean application package: $packageName" -ForegroundColor Yellow
            Write-Host "üì¶ Application-focused build (not a repository copy)" -ForegroundColor Cyan

            # Copy ONLY essential application files for running AitherZero
            Write-Host "Copying core application files..." -ForegroundColor Yellow

            # Core runner and main entry point
            Copy-Item -Path "aither-core/aither-core.ps1" -Destination "$packageDir/aither-core.ps1" -Force
            Write-Host "‚úì Core runner script" -ForegroundColor Green

            # Essential modules only (not dev/test modules)
            $essentialModules = @(
              "Logging", "LabRunner", "DevEnvironment", "BackupManager",
              "ScriptManager", "UnifiedMaintenance", "ParallelExecution"
            )

            New-Item -Path "$packageDir/modules" -ItemType Directory -Force | Out-Null
            foreach ($module in $essentialModules) {
              $modulePath = "aither-core/modules/$module"
              if (Test-Path $modulePath) {
                Copy-Item -Path $modulePath -Destination "$packageDir/modules/$module" -Recurse -Force
                Write-Host "‚úì Essential module: $module" -ForegroundColor Green
              }
            }

            # Shared utilities
            if (Test-Path "aither-core/shared") {
              Copy-Item -Path "aither-core/shared" -Destination "$packageDir/shared" -Recurse -Force
              Write-Host "‚úì Shared utilities" -ForegroundColor Green
            }

            # Essential scripts directory (runtime scripts only)
            if (Test-Path "aither-core/scripts") {
              New-Item -Path "$packageDir/scripts" -ItemType Directory -Force | Out-Null
              # Copy only runtime scripts, not development/build scripts
              $runtimeScripts = Get-ChildItem -Path "aither-core/scripts" -Filter "*.ps1" -File |
                Where-Object { $_.Name -notlike "*test*" -and $_.Name -notlike "*dev*" -and $_.Name -notlike "*build*" }
              foreach ($script in $runtimeScripts) {
                Copy-Item -Path $script.FullName -Destination "$packageDir/scripts/" -Force
                Write-Host "‚úì Runtime script: $($script.Name)" -ForegroundColor Green
              }
            }

            # Essential configuration templates
            New-Item -Path "$packageDir/configs" -ItemType Directory -Force | Out-Null
            $essentialConfigs = @(
              "default-config.json", "core-runner-config.json", "recommended-config.json"
            )
            foreach ($config in $essentialConfigs) {
              $configPath = "configs/$config"
              if (Test-Path $configPath) {
                Copy-Item -Path $configPath -Destination "$packageDir/configs/$config" -Force
                Write-Host "‚úì Config template: $config" -ForegroundColor Green
              }
            }

            # OpenTofu templates (infrastructure automation core feature)
            if (Test-Path "opentofu") {
              # Copy only essential OpenTofu files, not development/test environments
              New-Item -Path "$packageDir/opentofu" -ItemType Directory -Force | Out-Null
              $essentialTF = @("infrastructure", "providers", "modules")
              foreach ($tfDir in $essentialTF) {
                $tfPath = "opentofu/$tfDir"
                if (Test-Path $tfPath) {
                  Copy-Item -Path $tfPath -Destination "$packageDir/opentofu/$tfDir" -Recurse -Force
                  Write-Host "‚úì OpenTofu: $tfDir" -ForegroundColor Green
                }
              }
            }

            # Essential documentation
            Copy-Item -Path "README.md" -Destination "$packageDir/README.md" -Force
            Copy-Item -Path "LICENSE" -Destination "$packageDir/LICENSE" -Force
            Write-Host "‚úì Essential documentation" -ForegroundColor Green

            # Create a simple launcher script
            Write-Host "Creating application launcher..." -ForegroundColor Yellow
            $launcherLines = @(
              '#!/usr/bin/env pwsh',
              '#Requires -Version 7.0',
              '',
              'Write-Host "üöÄ AitherZero Infrastructure Automation Framework v' + $version + '" -ForegroundColor Cyan',
              'Write-Host "   Lean Application Package - Essential Components Only" -ForegroundColor Yellow',
              'Write-Host ""',
              '',
              '# Set up environment',
              '$env:AITHER_APP_ROOT = $PSScriptRoot',
              '$env:PROJECT_ROOT = $PSScriptRoot',
              '',
              '# Import essential modules',
              'if (Test-Path "$PSScriptRoot/modules") {',
              '    Get-ChildItem "$PSScriptRoot/modules" -Directory | ForEach-Object {',
              '        try {',
              '            Import-Module $_.FullName -Force',
              '            Write-Verbose "Loaded module: $($_.Name)"',
              '        } catch {',
              '            Write-Warning "Failed to load module $($_.Name): $_"',
              '        }',
              '    }',
              '}',
              '',
              '# Start the core application',
              'Write-Host "Starting AitherZero core application..." -ForegroundColor Green',
              '& "$PSScriptRoot/aither-core.ps1" $args'
            )

            $launcherContent = $launcherLines -join "`n"
            Set-Content -Path "$packageDir/Start-AitherZero.ps1" -Value $launcherContent
            Write-Host "‚úì Application launcher created" -ForegroundColor Green

            # Platform-specific startup scripts
            if ("${{ matrix.platform }}" -eq "windows") {
              $winScript = "@echo off`necho üöÄ AitherZero v$version - Windows Quick Start`npwsh -File `"Start-AitherZero.ps1`" %*`nif %ERRORLEVEL% NEQ 0 pause"
              Set-Content -Path "$packageDir/AitherZero.bat" -Value $winScript -Encoding UTF8
              Write-Host "‚úì Created Windows quick-start script" -ForegroundColor Green
            } else {
              $unixScript = "#!/bin/bash`necho `"üöÄ AitherZero v$version - $(if ("${{ matrix.platform }}" -eq "macos") { "macOS" } else { "Linux" }) Quick Start`"`npwsh -File `"Start-AitherZero.ps1`" `$@"
              Set-Content -Path "$packageDir/aitherzero.sh" -Value $unixScript -Encoding UTF8
              if (-not $IsWindows) {
                chmod +x "$packageDir/aitherzero.sh"
              }
              Write-Host "‚úì Created Unix quick-start script" -ForegroundColor Green
            }

            # Create package metadata and docs
            Write-Host "Creating package metadata..." -ForegroundColor Yellow
            $packageInfo = @{
              Version = $version
              PackageType = "Application"
              BuildDate = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss UTC')
              GitCommit = $env:GITHUB_SHA
              GitRef = $env:GITHUB_REF
              Platform = "${{ matrix.platform }}"
              Description = "Lean AitherZero application package with essential components only"
              Components = @(
                "Core runner", "Essential modules", "Configuration templates",
                "OpenTofu infrastructure", "Application launcher"
              )
              Usage = "Run Start-AitherZero.ps1 to begin or aither-core.ps1 for direct access"
              Repository = "https://github.com/wizzense/AitherZero"
            }
            $packageInfo | ConvertTo-Json -Depth 3 | Set-Content "$packageDir/PACKAGE-INFO.json"

            # Create simple installation guide
            $installGuide = "# AitherZero Application Package v$version`n`n" +
                           "## Quick Start`n`n" +
                           "1. Extract this package to your desired location`n" +
                           "2. Run: ./Start-AitherZero.ps1`n" +
                           "3. Or run directly: ./aither-core.ps1`n`n" +
                           "## Requirements`n`n" +
                           "- PowerShell 7.0 or later`n" +
                           "- Git (for repository operations)`n" +
                           "- OpenTofu/Terraform (for infrastructure automation)`n`n" +
                           "## Support`n`n" +
                           "Repository: https://github.com/wizzense/AitherZero"

            Set-Content -Path "$packageDir/INSTALL.md" -Value $installGuide
            Write-Host "‚úì Installation guide created" -ForegroundColor Green

            # Calculate package size
            $packageSize = (Get-ChildItem -Path $packageDir -Recurse | Measure-Object -Property Length -Sum).Sum
            $packageSizeMB = [math]::Round($packageSize / 1MB, 2)

            Write-Host ""
            Write-Host "üì¶ Lean Application Package Created:" -ForegroundColor Green
            Write-Host "   Package: $packageName" -ForegroundColor White
            Write-Host "   Size: $packageSizeMB MB (lean build)" -ForegroundColor White
            Write-Host "   Type: Application (Essential components only)" -ForegroundColor White
            Write-Host ""

            Write-Host "‚úì Package creation completed for ${{ matrix.platform }}" -ForegroundColor Green

          } catch {
            Write-Error "Build failed for ${{ matrix.platform }}: $($_.Exception.Message)"
            exit 1
          }

      - name: Create Platform Archive
        shell: pwsh
        run: |
          Write-Host "Creating archive for ${{ matrix.platform }}..." -ForegroundColor Cyan

          $version = "${{ needs.version.outputs.version }}"
          $buildDir = "build-output/${{ matrix.platform }}"
          $packageName = "AitherZero-$version-${{ matrix.platform }}"
          $archiveName = "$packageName.${{ matrix.artifact_extension }}"

          if (Test-Path "$buildDir/$packageName") {
            if ("${{ matrix.artifact_extension }}" -eq "zip") {
              Compress-Archive -Path "$buildDir/$packageName/*" -DestinationPath $archiveName -Force
            } else {
              # Create tar archive from the parent directory to avoid path issues
              tar -czf $archiveName -C $buildDir $packageName
            }

            $hash = Get-FileHash $archiveName -Algorithm SHA256
            Set-Content -Path "$archiveName.sha256" -Value "$($hash.Hash.ToLower())  $archiveName"

            Write-Host "‚úì Archive created: $archiveName" -ForegroundColor Green

            if (Test-Path $archiveName) {
              $size = (Get-Item $archiveName).Length
              Write-Host "Archive size: $([math]::Round($size / 1MB, 2)) MB" -ForegroundColor Cyan
              Write-Host "Archive location: $(Resolve-Path $archiveName)" -ForegroundColor Yellow
            }
          } else {
            Write-Error "Package directory not found: $buildDir/$packageName"
            exit 1
          }

      - name: Verify Artifacts Before Upload
        shell: pwsh
        run: |
          Write-Host "Verifying artifacts before upload..." -ForegroundColor Cyan
          $version = "${{ needs.version.outputs.version }}"
          $archiveName = "AitherZero-$version-${{ matrix.platform }}.${{ matrix.artifact_extension }}"
          $hashName = "$archiveName.sha256"

          Write-Host "Expected files:" -ForegroundColor Yellow
          Write-Host "  - $archiveName" -ForegroundColor White
          Write-Host "  - $hashName" -ForegroundColor White

          Write-Host "Current directory files:" -ForegroundColor Yellow
          Get-ChildItem -File | ForEach-Object {
            Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)" -ForegroundColor White
          }

          if (-not (Test-Path $archiveName)) {
            Write-Error "Archive file not found: $archiveName"
            exit 1
          }

          if (-not (Test-Path $hashName)) {
            Write-Error "Hash file not found: $hashName"
            exit 1
          }

          Write-Host "‚úì All required artifacts verified!" -ForegroundColor Green

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: AitherZero-${{ needs.version.outputs.version }}-${{ matrix.platform }}
          path: |
            AitherZero-${{ needs.version.outputs.version }}-${{ matrix.platform }}.${{ matrix.artifact_extension }}
            AitherZero-${{ needs.version.outputs.version }}-${{ matrix.platform }}.${{ matrix.artifact_extension }}.sha256
          retention-days: 30
          if-no-files-found: error

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [version, build]
    if: |
      needs.version.outputs.should-build == 'true' &&
      (github.event_name == 'workflow_dispatch' ||
       github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') ||
       (github.event_name == 'pull_request' && github.event.pull_request.merged == true) ||
       (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')))

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Organize Release Assets
        shell: pwsh
        run: |
          Write-Host "Organizing release assets..." -ForegroundColor Cyan

          # Create release directory
          $releaseDir = "release"
          if (-not (Test-Path $releaseDir)) {
            New-Item -ItemType Directory -Path $releaseDir -Force | Out-Null
          }

          # Move all artifacts to release directory with proper names
          Get-ChildItem -Path "./artifacts" -Recurse -File | ForEach-Object {
            $destPath = Join-Path $releaseDir $_.Name
            Copy-Item $_.FullName $destPath -Force
            Write-Host "‚úì Copied: $($_.Name)" -ForegroundColor Green
          }

          # Verify all expected files are present
          $version = "${{ needs.version.outputs.version }}"
          $expectedFiles = @(
            "AitherZero-$version-windows.zip",
            "AitherZero-$version-windows.zip.sha256",
            "AitherZero-$version-linux.tar.gz",
            "AitherZero-$version-linux.tar.gz.sha256",
            "AitherZero-$version-macos.tar.gz",
            "AitherZero-$version-macos.tar.gz.sha256"
          )

          foreach ($file in $expectedFiles) {
            $filePath = Join-Path $releaseDir $file
            if (Test-Path $filePath) {
              Write-Host "‚úì Found: $file" -ForegroundColor Green
            } else {
              Write-Warning "Missing: $file"
            }
          }

          # Create comprehensive checksums file
          $checksumFile = "release/AitherZero-$version-checksums.txt"
          $checksumContent = @()

          Get-ChildItem -Path "release" -Filter "*.sha256" | ForEach-Object {
            $content = Get-Content $_.FullName -Raw
            $checksumContent += $content.Trim()
          }

          if ($checksumContent.Count -gt 0) {
            Set-Content -Path $checksumFile -Value $checksumContent
            Write-Host "‚úì Created comprehensive checksums file" -ForegroundColor Green
          }

          Write-Host "Release assets organized successfully!" -ForegroundColor Green

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.version.outputs.version }}
          name: AitherZero v${{ needs.version.outputs.version }}
          body: |
            # AitherZero v${{ needs.version.outputs.version }}

            Cross-Platform Infrastructure Automation Framework

            This release includes pre-built packages for Windows, Linux, and macOS.

            ## Installation

            Download the package for your platform:
            - Windows: AitherZero-${{ needs.version.outputs.version }}-windows.zip
            - Linux: AitherZero-${{ needs.version.outputs.version }}-linux.tar.gz
            - macOS: AitherZero-${{ needs.version.outputs.version }}-macos.tar.gz

            ## Requirements

            - PowerShell 7.0 or later
            - Git (for repository operations)
            - OpenTofu/Terraform (for infrastructure automation)

            ## Features

            - Cross-platform PowerShell-based automation
            - OpenTofu/Terraform integration
            - Parallel execution capabilities
            - Comprehensive testing framework
            - Advanced patch management system
            - Enterprise-grade logging and error handling
          files: release/*
          draft: false
          prerelease: ${{ contains(needs.version.outputs.version, 'pre') || contains(needs.version.outputs.version, 'alpha') || contains(needs.version.outputs.version, 'beta') }}

  validate-release:
    name: Validate Release
    runs-on: ubuntu-latest
    needs: [version, release]
    if: always() && needs.release.result == 'success' && needs.version.outputs.version != ''

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Wait for Release to be Available
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "Waiting for release to be fully available..." -ForegroundColor Cyan

          $version = "${{ needs.version.outputs.version }}"
          $maxAttempts = 6
          $attempt = 1
          $found = $false

          while ($attempt -le $maxAttempts -and -not $found) {
            Write-Host "Attempt $attempt of $maxAttempts..." -ForegroundColor Yellow

            try {
              $release = gh release view "v$version" --json tagName,assets,draft 2>$null
              if ($release) {
                $releaseData = $release | ConvertFrom-Json
                if ($releaseData.tagName -eq "v$version" -and $releaseData.assets -and $releaseData.assets.Count -gt 0) {
                  Write-Host "‚úì Release v$version found with $($releaseData.assets.Count) assets" -ForegroundColor Green
                  $found = $true
                  break
                }
              }
            } catch {
              Write-Host "Release not yet available: $($_.Exception.Message)" -ForegroundColor Yellow
            }

            if (-not $found) {
              Write-Host "Release not ready, waiting 10 seconds..." -ForegroundColor Yellow
              Start-Sleep -Seconds 10
              $attempt++
            }
          }

          if (-not $found) {
            Write-Warning "Release v$version not found after $maxAttempts attempts - continuing anyway"
            Write-Host "This may be normal for some trigger types" -ForegroundColor Yellow
            # Don't exit with error - make this non-blocking
          } else {
            Write-Host "‚úÖ Release validation ready to proceed" -ForegroundColor Green
          }

      - name: Validate Release Assets
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "Validating release v${{ needs.version.outputs.version }}..." -ForegroundColor Cyan

          $version = "${{ needs.version.outputs.version }}"
          if ([string]::IsNullOrEmpty($version)) {
            Write-Error "Version is empty or null. Cannot validate release."
            exit 1
          }

          try {
            $release = gh release view "v$version" --json tagName,assets,draft 2>$null

            if ($release) {
              $releaseData = $release | ConvertFrom-Json
              Write-Host "‚úì Release found: $($releaseData.tagName)" -ForegroundColor Green

              Write-Host "Assets found: $($releaseData.assets.Count)" -ForegroundColor Cyan
              foreach ($asset in $releaseData.assets) {
                $sizeInMB = [math]::Round($asset.size / 1MB, 2)
                Write-Host "  - $($asset.name) ($sizeInMB MB)" -ForegroundColor White
              }

              $expectedAssets = @(
                "AitherZero-$version-windows.zip",
                "AitherZero-$version-windows.zip.sha256",
                "AitherZero-$version-linux.tar.gz",
                "AitherZero-$version-linux.tar.gz.sha256",
                "AitherZero-$version-macos.tar.gz",
                "AitherZero-$version-macos.tar.gz.sha256",
                "AitherZero-$version-checksums.txt"
              )

              $allAssetsPresent = $true
              $missingAssets = @()

              foreach ($expectedAsset in $expectedAssets) {
                $found = $releaseData.assets | Where-Object { $_.name -eq $expectedAsset }
                if ($found) {
                  Write-Host "‚úì Asset found: $expectedAsset" -ForegroundColor Green
                } else {
                  Write-Host "‚úó Asset missing: $expectedAsset" -ForegroundColor Red
                  $missingAssets += $expectedAsset
                  $allAssetsPresent = $false
                }
              }

              if ($allAssetsPresent) {
                Write-Host "‚úÖ All expected assets are present!" -ForegroundColor Green
              } else {
                Write-Warning "Missing assets:"
                foreach ($missing in $missingAssets) {
                  Write-Warning "  - $missing"
                }
                Write-Error "Release validation failed: missing assets"
                exit 1
              }

              if ($releaseData.draft) {
                Write-Host "‚ÑπÔ∏è Release is marked as draft" -ForegroundColor Yellow
              } else {
                Write-Host "‚úì Release is published" -ForegroundColor Green
              }

            } else {
              Write-Error "Release v$version not found"
              exit 1
            }

          } catch {
            Write-Error "Failed to validate release: $($_.Exception.Message)"
            exit 1
          }

      - name: Test Download and Basic Validation
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "Testing release download and basic validation..." -ForegroundColor Cyan

          $version = "${{ needs.version.outputs.version }}"

          try {
            $assetName = "AitherZero-$version-linux.tar.gz"

            Write-Host "Downloading $assetName..." -ForegroundColor Yellow
            gh release download "v$version" --pattern $assetName

            if (Test-Path $assetName) {
              Write-Host "‚úì Asset downloaded successfully" -ForegroundColor Green

              Write-Host "Archive contents (first 10 entries):" -ForegroundColor Cyan
              tar -tzf $assetName | Select-Object -First 10 | ForEach-Object {
                Write-Host "  $($_)" -ForegroundColor White
              }

              Remove-Item $assetName -Force
              Write-Host "‚úì Basic validation completed" -ForegroundColor Green

            } else {
              Write-Warning "Failed to download asset: $assetName"
              Write-Host "This may be expected for some workflow trigger types" -ForegroundColor Yellow
            }

          } catch {
            Write-Warning "Download validation failed: $($_.Exception.Message)"
            Write-Host "This may be expected for some workflow trigger types" -ForegroundColor Yellow
          }

          Write-Host "üéâ Release validation completed successfully!" -ForegroundColor Green
