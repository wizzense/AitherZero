name: Build and Release

on:
  # Trigger on successful PR merges to main/master, version tags, or manual dispatch
  push:
    branches: [main, master]  # Trigger on successful PR merges
    tags: ['v*']  # Only trigger on version tags like v1.0.0
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release Type'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
          - prerelease
      create_release:
        description: 'Create GitHub Release'
        required: true
        default: true
        type: boolean

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1

# Prevent conflicts with other workflows and duplicate runs
concurrency:
  group: build-release-${{ github.workflow }}-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: false  # Don't cancel release builds

permissions:
  contents: write
  packages: write
  repository-projects: write
  issues: write
  pull-requests: write

jobs:
  version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should-build: ${{ steps.check.outputs.should-build }}
      should-release: ${{ steps.check.outputs.should-release }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Version
        id: version
        shell: pwsh
        run: |
          Write-Host "Determining release version..." -ForegroundColor Cyan

          $version = ""

          if ("${{ github.ref_type }}" -eq "tag") {
            $tagName = "${{ github.ref_name }}"
            if ($tagName -match '^v?(.+)$') {
              $version = $matches[1]
              Write-Host "Using tag version: $version" -ForegroundColor Green
            }
          }

          if ([string]::IsNullOrEmpty($version) -and "${{ github.event.inputs.release_type }}" -ne "") {
            $latestTag = git describe --tags --abbrev=0 2>$null
            if ($latestTag) {
              $currentVersion = $latestTag -replace '^v', ''
              Write-Host "Current version from git: $currentVersion" -ForegroundColor Yellow

              if ($currentVersion -match '^(\d+)\.(\d+)\.(\d+)') {
                $major = [int]$matches[1]
                $minor = [int]$matches[2]
                $patch = [int]$matches[3]

                switch ("${{ github.event.inputs.release_type }}") {
                  "major" { $version = "$($major + 1).0.0" }
                  "minor" { $version = "$major.$($minor + 1).0" }
                  "patch" { $version = "$major.$minor.$($patch + 1)" }
                  "prerelease" { $version = "$major.$minor.$($patch + 1)-pre.$([DateTimeOffset]::UtcNow.ToUnixTimeSeconds())" }
                }
              }
            } else {
              $version = "1.0.0"
            }
            Write-Host "Calculated new version: $version" -ForegroundColor Green
          }

          # Version determination logic

          # For PR merges to main/master, create a patch release version automatically
          if ([string]::IsNullOrEmpty($version) -and
              "${{ github.event_name }}" -eq "push" -and
              ("${{ github.ref }}" -eq "refs/heads/main" -or "${{ github.ref }}" -eq "refs/heads/master")) {
            $latestTag = git describe --tags --abbrev=0 2>$null
            if ($latestTag) {
              $currentVersion = $latestTag -replace '^v', ''
              Write-Host "Current version from git: $currentVersion" -ForegroundColor Yellow

              if ($currentVersion -match '^(\d+)\.(\d+)\.(\d+)') {
                $major = [int]$matches[1]
                $minor = [int]$matches[2]
                $patch = [int]$matches[3]
                $version = "$major.$minor.$($patch + 1)"
                Write-Host "Auto-incrementing to patch version: $version" -ForegroundColor Green
              } else {
                Write-Host "Could not parse version, using 0.11.1" -ForegroundColor Yellow
                $version = "0.11.1"
              }
            } else {
              $version = "0.11.1"
              Write-Host "No tags found, using initial version: $version" -ForegroundColor Green
            }
          }

          if ([string]::IsNullOrEmpty($version)) {
            $timestamp = Get-Date -Format "yyyy.MM.dd.HHmm"
            $version = "0.0.$timestamp"
            Write-Host "Using fallback timestamp version: $version" -ForegroundColor Yellow
          }

          Write-Host "Final version determined: $version" -ForegroundColor Green
          echo "version=$version" >> $env:GITHUB_OUTPUT

      - name: Check if build should proceed
        id: check
        shell: pwsh
        run: |
          $shouldBuild = $false
          $shouldRelease = $false

          if ("${{ github.event_name }}" -eq "push" -and "${{ github.ref_type }}" -eq "tag") {
            $shouldBuild = $true
            $shouldRelease = $true
            Write-Host "✓ Tag push - proceeding with build and release" -ForegroundColor Green
          } elseif ("${{ github.event_name }}" -eq "push" -and ("${{ github.ref }}" -eq "refs/heads/main" -or "${{ github.ref }}" -eq "refs/heads/master")) {
            $shouldBuild = $true
            $shouldRelease = $true
            Write-Host "✓ PR merge to main/master - proceeding with build and AUTOMATED RELEASE" -ForegroundColor Green
          } elseif ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $shouldBuild = $true
            $shouldRelease = $true
            Write-Host "✓ Manual dispatch - proceeding with build and release" -ForegroundColor Green
          } else {
            Write-Host "✗ Event does not trigger build: ${{ github.event_name }} (ref: ${{ github.ref }}, ref_type: ${{ github.ref_type }})" -ForegroundColor Yellow
            Write-Host "✗ This workflow runs on: version tags (v*), PR merges to main/master, or manual dispatch" -ForegroundColor Red
          }

          Write-Host "Should build: $shouldBuild" -ForegroundColor Cyan
          Write-Host "Should release: $shouldRelease" -ForegroundColor Cyan
          echo "should-build=$shouldBuild" >> $env:GITHUB_OUTPUT
            echo "should-release=$shouldRelease" >> $env:GITHUB_OUTPUT

  validate:
    name: Pre-Build Validation (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: version
    if: needs.version.outputs.should-build == 'true'

    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup PowerShell Environment
        shell: pwsh
        run: |
          Write-Host "Setting up PowerShell environment on ${{ matrix.os }}..." -ForegroundColor Cyan
          echo "POWERSHELL_TELEMETRY_OPTOUT=1" >> $env:GITHUB_ENV
          echo "PROJECT_ROOT=$PWD" >> $env:GITHUB_ENV

          if ($IsWindows) {
            $env:PATH_SEPARATOR = ";"
          } else {
            $env:PATH_SEPARATOR = ":"
          }

          Write-Host "✓ Environment initialized for ${{ matrix.os }}" -ForegroundColor Green

      - name: Run Cross-Platform Validation
        shell: pwsh
        run: |
          Write-Host "Running pre-build validation on ${{ matrix.os }}..." -ForegroundColor Cyan

          $ErrorActionPreference = 'Stop'

          try {
            if (Test-Path './tests/Run-BulletproofValidation.ps1') {
              Write-Host "Running bulletproof validation..." -ForegroundColor Yellow
              pwsh -File './tests/Run-BulletproofValidation.ps1' -ValidationLevel 'Quick' -CI -FailFast
            } else {
              Write-Host "No bulletproof validation found, running basic checks" -ForegroundColor Yellow

              if (Test-Path './aither-core/modules') {
                $modules = Get-ChildItem -Path './aither-core/modules' -Directory
                foreach ($module in $modules) {
                  try {
                    if (-not $module.FullName) {
                      throw "Module $($module.Name) does not have a valid path (FullName is null)"
                    }
                    Write-Host "Testing module: $($module.Name)" -ForegroundColor Cyan
                    Import-Module $module.FullName -Force -ErrorAction Stop
                    Write-Host "✓ Module $($module.Name) imports successfully" -ForegroundColor Green
                  } catch {
                    Write-Error "Module $($module.Name) failed to import: $($_.Exception.Message)"
                    exit 1
                  }
                }
              }
            }

            Write-Host "✓ Pre-build validation completed successfully on ${{ matrix.os }}" -ForegroundColor Green

          } catch {
            Write-Error "Pre-build validation failed on ${{ matrix.os }}: $($_.Exception.Message)"
            exit 1
          }

  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: [version, validate]
    if: needs.version.outputs.should-build == 'true'

    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            artifact_extension: tar.gz
          - os: windows-latest
            platform: windows
            artifact_extension: zip
          - os: macos-latest
            platform: macos
            artifact_extension: tar.gz

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Build Environment
        shell: pwsh
        run: |
          Write-Host "Setting up build environment for ${{ matrix.platform }}..." -ForegroundColor Cyan

          $version = "${{ needs.version.outputs.version }}"
          echo "BUILD_VERSION=$version" >> $env:GITHUB_ENV
          echo "PROJECT_ROOT=$PWD" >> $env:GITHUB_ENV

          Write-Host "✓ Environment configured for ${{ matrix.platform }}" -ForegroundColor Green

      - name: Build AitherZero Package
        shell: pwsh
        run: |
          $version = "${{ needs.version.outputs.version }}"
          & "./build/Build-Package.ps1" -Platform "${{ matrix.platform }}" -Version $version -ArtifactExtension "${{ matrix.artifact_extension }}"

      - name: Create Platform Archive
        shell: pwsh
        run: |
          Write-Host "Creating archive for ${{ matrix.platform }}..." -ForegroundColor Cyan

          $version = "${{ needs.version.outputs.version }}"
          $buildDir = "build-output/${{ matrix.platform }}"
          $packageName = "AitherZero-$version-${{ matrix.platform }}"
          $archiveName = "$packageName.${{ matrix.artifact_extension }}"

          if (Test-Path "$buildDir/$packageName") {
            if ("${{ matrix.artifact_extension }}" -eq "zip") {
              Compress-Archive -Path "$buildDir/$packageName/*" -DestinationPath $archiveName -Force
            } else {
              # Create tar archive from the parent directory to avoid path issues
              tar -czf $archiveName -C $buildDir $packageName
            }

            $hash = Get-FileHash $archiveName -Algorithm SHA256
            Set-Content -Path "$archiveName.sha256" -Value "$($hash.Hash.ToLower())  $archiveName"

            Write-Host "✓ Archive created: $archiveName" -ForegroundColor Green

            if (Test-Path $archiveName) {
              $size = (Get-Item $archiveName).Length
              Write-Host "Archive size: $([math]::Round($size / 1MB, 2)) MB" -ForegroundColor Cyan
              Write-Host "Archive location: $(Resolve-Path $archiveName)" -ForegroundColor Yellow
            }
          } else {
            Write-Error "Package directory not found: $buildDir/$packageName"
            exit 1
          }

      - name: Verify Artifacts Before Upload
        shell: pwsh
        run: |
          Write-Host "Verifying artifacts before upload..." -ForegroundColor Cyan
          $version = "${{ needs.version.outputs.version }}"
          $archiveName = "AitherZero-$version-${{ matrix.platform }}.${{ matrix.artifact_extension }}"
          $hashName = "$archiveName.sha256"

          Write-Host "Expected files:" -ForegroundColor Yellow
          Write-Host "  - $archiveName" -ForegroundColor White
          Write-Host "  - $hashName" -ForegroundColor White

          Write-Host "Current directory files:" -ForegroundColor Yellow
          Get-ChildItem -File | ForEach-Object {
            Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)" -ForegroundColor White
          }

          if (-not (Test-Path $archiveName)) {
            Write-Error "Archive file not found: $archiveName"
            exit 1
          }

          if (-not (Test-Path $hashName)) {
            Write-Error "Hash file not found: $hashName"
            exit 1
          }

          Write-Host "✓ All required artifacts verified!" -ForegroundColor Green

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: AitherZero-${{ needs.version.outputs.version }}-${{ matrix.platform }}
          path: |
            AitherZero-${{ needs.version.outputs.version }}-${{ matrix.platform }}.${{ matrix.artifact_extension }}
            AitherZero-${{ needs.version.outputs.version }}-${{ matrix.platform }}.${{ matrix.artifact_extension }}.sha256
          retention-days: 30
          if-no-files-found: error

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [version, build]
    if: needs.version.outputs.should-release == 'true'
    outputs:
      release-tag: v${{ needs.version.outputs.version }}
      release-version: ${{ needs.version.outputs.version }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Organize Release Assets
        shell: pwsh
        run: |
          Write-Host "Organizing release assets..." -ForegroundColor Cyan

          # Create release directory
          $releaseDir = "release"
          if (-not (Test-Path $releaseDir)) {
            New-Item -ItemType Directory -Path $releaseDir -Force | Out-Null
          }

          # Move all artifacts to release directory with proper names
          Get-ChildItem -Path "./artifacts" -Recurse -File | ForEach-Object {
            $destPath = Join-Path $releaseDir $_.Name
            Copy-Item $_.FullName $destPath -Force
            Write-Host "✓ Copied: $($_.Name)" -ForegroundColor Green
          }

          # Verify all expected files are present
          $version = "${{ needs.version.outputs.version }}"
          $expectedFiles = @(
            "AitherZero-$version-windows.zip",
            "AitherZero-$version-windows.zip.sha256",
            "AitherZero-$version-linux.tar.gz",
            "AitherZero-$version-linux.tar.gz.sha256",
            "AitherZero-$version-macos.tar.gz",
            "AitherZero-$version-macos.tar.gz.sha256"
          )

          foreach ($file in $expectedFiles) {
            $filePath = Join-Path $releaseDir $file
            if (Test-Path $filePath) {
              Write-Host "✓ Found: $file" -ForegroundColor Green
            } else {
              Write-Warning "Missing: $file"
            }
          }

          # Create comprehensive checksums file
          $checksumFile = "release/AitherZero-$version-checksums.txt"
          $checksumContent = @()

          Get-ChildItem -Path "release" -Filter "*.sha256" | ForEach-Object {
            $content = Get-Content $_.FullName -Raw
            $checksumContent += $content.Trim()
          }

          if ($checksumContent.Count -gt 0) {
            Set-Content -Path $checksumFile -Value $checksumContent
            Write-Host "✓ Created comprehensive checksums file" -ForegroundColor Green
          }

          Write-Host "Release assets organized successfully!" -ForegroundColor Green

      - name: Create GitHub Release
        id: create-release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.version.outputs.version }}
          name: AitherZero v${{ needs.version.outputs.version }}
          body: |
            # AitherZero v${{ needs.version.outputs.version }}

            Cross-Platform Infrastructure Automation Framework

            This release includes pre-built packages for Windows, Linux, and macOS.

            ## Installation

            Download the package for your platform:
            - Windows: AitherZero-${{ needs.version.outputs.version }}-windows.zip
            - Linux: AitherZero-${{ needs.version.outputs.version }}-linux.tar.gz
            - macOS: AitherZero-${{ needs.version.outputs.version }}-macos.tar.gz

            ## Requirements

            - PowerShell 7.0 or later
            - Git (for repository operations)
            - OpenTofu/Terraform (for infrastructure automation)

            ## Features

            - Cross-platform PowerShell-based automation
            - OpenTofu/Terraform integration
            - Parallel execution capabilities
            - Comprehensive testing framework
            - Advanced patch management system
            - Enterprise-grade logging and error handling
          files: release/*
          draft: false
          prerelease: ${{ contains(needs.version.outputs.version, 'pre') || contains(needs.version.outputs.version, 'alpha') || contains(needs.version.outputs.version, 'beta') }}

      - name: Output Release Information
        shell: pwsh
        run: |
          $version = "${{ needs.version.outputs.version }}"
          $tagName = "v$version"
          Write-Host "✅ Release created successfully!" -ForegroundColor Green
          Write-Host "Tag: $tagName" -ForegroundColor Cyan
          Write-Host "Version: $version" -ForegroundColor Cyan

  validate-release:
    name: Validate Release
    runs-on: ubuntu-latest
    needs: [version, release]
    if: always() && needs.release.result == 'success' && needs.release.outputs.release-version != ''

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Wait for Release to be Available
        id: wait
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "Waiting for release to be fully available..." -ForegroundColor Cyan

          $version = "${{ needs.release.outputs.release-version }}"
          $maxAttempts = 6
          $attempt = 1
          $found = $false

          Write-Host "Looking for release with version: $version" -ForegroundColor Yellow

          while ($attempt -le $maxAttempts -and -not $found) {
            Write-Host "Attempt $attempt of $maxAttempts..." -ForegroundColor Yellow

            try {
              $release = gh release view "v$version" --json tagName,assets,isDraft 2>$null
              if ($release) {
                $releaseData = $release | ConvertFrom-Json
                if ($releaseData.tagName -eq "v$version" -and $releaseData.assets -and $releaseData.assets.Count -gt 0) {
                  Write-Host "✓ Release v$version found with $($releaseData.assets.Count) assets" -ForegroundColor Green
                  $found = $true
                  break
                }
              }
            } catch {
              Write-Host "Release not yet available: $($_.Exception.Message)" -ForegroundColor Yellow
            }

            if (-not $found) {
              Write-Host "Release not ready, waiting 10 seconds..." -ForegroundColor Yellow
              Start-Sleep -Seconds 10
              $attempt++
            }
          }

          if (-not $found) {
            Write-Warning "Release v$version not found after $maxAttempts attempts - continuing anyway"
            Write-Host "This may be normal for some trigger types" -ForegroundColor Yellow
            # Set output to skip remaining validation steps
            echo "release-found=false" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "✅ Release validation ready to proceed" -ForegroundColor Green
            echo "release-found=true" >> $env:GITHUB_OUTPUT
          }

      - name: Validate Release Assets
        if: steps.wait.outputs.release-found == 'true'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "Validating release v${{ needs.release.outputs.release-version }}..." -ForegroundColor Cyan

          $version = "${{ needs.release.outputs.release-version }}"
          if ([string]::IsNullOrEmpty($version)) {
            Write-Error "Version is empty or null. Cannot validate release."
            exit 1
          }

          try {
            $release = gh release view "v$version" --json tagName,assets,isDraft 2>$null

            if ($release) {
              $releaseData = $release | ConvertFrom-Json
              Write-Host "✓ Release found: $($releaseData.tagName)" -ForegroundColor Green

              Write-Host "Assets found: $($releaseData.assets.Count)" -ForegroundColor Cyan
              foreach ($asset in $releaseData.assets) {
                $sizeInMB = [math]::Round($asset.size / 1MB, 2)
                Write-Host "  - $($asset.name) ($sizeInMB MB)" -ForegroundColor White
              }

              $expectedAssets = @(
                "AitherZero-$version-windows.zip",
                "AitherZero-$version-windows.zip.sha256",
                "AitherZero-$version-linux.tar.gz",
                "AitherZero-$version-linux.tar.gz.sha256",
                "AitherZero-$version-macos.tar.gz",
                "AitherZero-$version-macos.tar.gz.sha256",
                "AitherZero-$version-checksums.txt"
              )

              $allAssetsPresent = $true
              $missingAssets = @()

              foreach ($expectedAsset in $expectedAssets) {
                $found = $releaseData.assets | Where-Object { $_.name -eq $expectedAsset }
                if ($found) {
                  Write-Host "✓ Asset found: $expectedAsset" -ForegroundColor Green
                } else {
                  Write-Host "✗ Asset missing: $expectedAsset" -ForegroundColor Red
                  $missingAssets += $expectedAsset
                  $allAssetsPresent = $false
                }
              }

              if ($allAssetsPresent) {
                Write-Host "✅ All expected assets are present!" -ForegroundColor Green
              } else {
                Write-Warning "Missing assets:"
                foreach ($missing in $missingAssets) {
                  Write-Warning "  - $missing"
                }
                Write-Error "Release validation failed: missing assets"
                exit 1
              }

              if ($releaseData.isDraft) {
                Write-Host "ℹ️ Release is marked as draft" -ForegroundColor Yellow
              } else {
                Write-Host "✓ Release is published" -ForegroundColor Green
              }

            } else {
              Write-Error "Release v$version not found"
              exit 1
            }

          } catch {
            Write-Error "Failed to validate release: $($_.Exception.Message)"
            exit 1
          }

      - name: Test Download and Basic Validation
        if: steps.wait.outputs.release-found == 'true'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "Testing release download and basic validation..." -ForegroundColor Cyan

          $version = "${{ needs.release.outputs.release-version }}"

          try {
            $assetName = "AitherZero-$version-linux.tar.gz"

            Write-Host "Downloading $assetName..." -ForegroundColor Yellow
            gh release download "v$version" --pattern $assetName

            if (Test-Path $assetName) {
              Write-Host "✓ Asset downloaded successfully" -ForegroundColor Green

              Write-Host "Archive contents (first 10 entries):" -ForegroundColor Cyan
              tar -tzf $assetName | Select-Object -First 10 | ForEach-Object {
                Write-Host "  $($_)" -ForegroundColor White
              }

              Remove-Item $assetName -Force
              Write-Host "✓ Basic validation completed" -ForegroundColor Green

            } else {
              Write-Warning "Failed to download asset: $assetName"
              Write-Host "This may be expected for some workflow trigger types" -ForegroundColor Yellow
            }

          } catch {
            Write-Warning "Download validation failed: $($_.Exception.Message)"
            Write-Host "This may be expected for some workflow trigger types" -ForegroundColor Yellow
          }

          Write-Host "🎉 Release validation completed successfully!" -ForegroundColor Green
