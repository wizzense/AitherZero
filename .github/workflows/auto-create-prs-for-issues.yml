---
name: 🚀 Auto-Create PRs for Prioritized Issues

# Phase 2: Group related issues and create PRs after P1-P10 label assigned
# Creates one PR per category (type + file/domain grouping)
on:
  issues:
    types: [labeled]
  
  # DISABLED: 4-hour schedule was too aggressive
  # schedule:
  #   # Check for prioritized issues every 4 hours
  #   - cron: '0 */4 * * *'
  
  workflow_dispatch:
    inputs:
      force_grouping:
        description: 'Force regrouping of all prioritized issues'
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  group-and-create-prs:
    name: 📦 Group Issues and Create PRs
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'schedule' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issues' && 
       github.event.action == 'labeled' &&
       contains(fromJSON('["P1","P2","P3","P4","P5","P6","P7","P8","P9","P10"]'), github.event.label.name))

    steps:
      - name: 📥 Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 🔍 Find and Group Prioritized Issues
        id: group_issues
        uses: actions/github-script@v7
        with:
          script: |
            console.log('🔍 Scanning for prioritized issues with copilot-task label...');
            
            // Find all open issues with copilot-task label and P1-P10 priority
            const { data: allIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'copilot-task',
              per_page: 100
            });

            // Filter for issues with P1-P10 labels and at least 2 hours old
            const prioritizedIssues = allIssues.filter(issue => {
              const hasPriority = issue.labels.some(l => /^P([1-9]|10)$/.test(l.name));
              const ageHours = Math.round((Date.now() - new Date(issue.created_at)) / (1000 * 60 * 60));
              const isOldEnough = ageHours >= 2;
              
              // Check if already linked to a PR
              const hasLinkedPR = issue.body && issue.body.includes('Linked PR:');
              
              return hasPriority && isOldEnough && !hasLinkedPR;
            });

            console.log(`Found ${prioritizedIssues.length} prioritized issues ready for PR creation`);

            if (prioritizedIssues.length === 0) {
              console.log('No issues ready for PR creation');
              core.setOutput('has_issues', 'false');
              return;
            }

            // Group issues by type, file, and domain
            const groups = {};
            
            for (const issue of prioritizedIssues) {
              const labels = issue.labels.map(l => l.name);
              
              // Determine primary type
              let type = 'other';
              if (labels.includes('psscriptanalyzer')) type = 'code-quality';
              else if (labels.includes('unit-tests')) type = 'testing';
              else if (labels.includes('security')) type = 'security';
              else if (labels.includes('maintenance')) type = 'maintenance';
              
              // Extract file/domain info from issue body
              let fileContext = 'general';
              const bodyMatch = issue.body?.match(/`([^`]+\.(ps1|psm1|psd1))`/i);
              if (bodyMatch) {
                const filePath = bodyMatch[1];
                // Get domain from file path
                if (filePath.includes('domains/')) {
                  const domainMatch = filePath.match(/domains\/([^\/]+)/);
                  if (domainMatch) fileContext = `domain-${domainMatch[1]}`;
                } else if (filePath.includes('automation-scripts/')) {
                  const scriptMatch = filePath.match(/automation-scripts\/(\d{4})/);
                  if (scriptMatch) fileContext = `scripts-${scriptMatch[1].substring(0, 2)}xx`;
                } else if (filePath.includes('tests/')) {
                  fileContext = 'tests';
                }
              }
              
              // Get priority for grouping
              const priorityLabel = labels.find(l => /^P([1-9]|10)$/.test(l));
              const priority = priorityLabel || 'P5';
              
              // Create group key: type + fileContext + priority
              const groupKey = `${type}-${fileContext}-${priority}`;
              
              if (!groups[groupKey]) {
                groups[groupKey] = {
                  type,
                  fileContext,
                  priority,
                  issues: []
                };
              }
              
              groups[groupKey].issues.push({
                number: issue.number,
                title: issue.title,
                labels,
                created_at: issue.created_at
              });
            }

            // Log grouping results
            console.log('\n📊 Issue Grouping Results:');
            for (const [key, group] of Object.entries(groups)) {
              console.log(`  ${key}: ${group.issues.length} issues`);
              group.issues.forEach(issue => {
                console.log(`    - #${issue.number}: ${issue.title}`);
              });
            }

            // Save groups for next step
            core.setOutput('groups', JSON.stringify(groups));
            core.setOutput('has_issues', 'true');
            core.setOutput('group_count', Object.keys(groups).length.toString());

      - name: 🔧 Setup Git
        if: steps.group_issues.outputs.has_issues == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: 🚀 Create PRs for Issue Groups
        if: steps.group_issues.outputs.has_issues == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const groups = JSON.parse('${{ steps.group_issues.outputs.groups }}');
            
            console.log(`\n🚀 Creating PRs for ${Object.keys(groups).length} issue groups...\n`);

            for (const [groupKey, group] of Object.entries(groups)) {
              const { type, fileContext, priority, issues } = group;
              
              // Skip if only 1 issue and not high priority
              if (issues.length === 1 && !['P1', 'P2'].includes(priority)) {
                console.log(`⏭️ Skipping single issue #${issues[0].number} (${priority}) - will be handled individually`);
                continue;
              }

              // Generate branch name
              const timestamp = Date.now();
              const branchName = `auto-fix/${type}-${fileContext}-${priority.toLowerCase()}-${timestamp}`;
              
              // Create branch
              const mainRef = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'heads/main'
              });

              try {
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: mainRef.data.object.sha
                });
                console.log(`✅ Created branch: ${branchName}`);
              } catch (error) {
                if (error.status === 422) {
                  console.log(`Branch ${branchName} already exists, skipping...`);
                  continue;
                }
                throw error;
              }

              // Generate PR title
              const prTitle = `🤖 [${priority}] Fix ${type} issues in ${fileContext}`;
              
              // Generate PR body with issue links
              const issueLinks = issues.map(issue => 
                `- Fixes #${issue.number}: ${issue.title}`
              ).join('\n');

              const prBody = `## 🤖 Automated Issue Resolution

This PR groups and addresses related issues for efficient resolution.

### 📋 Issues Addressed

${issueLinks}

### 🎯 Summary

**Type:** ${type}
**Context:** ${fileContext}
**Priority:** ${priority}
**Issue Count:** ${issues.length}

### 🔧 Changes Required

@copilot Please analyze the linked issues above and implement fixes for:

1. **Review Issues:** Read each linked issue carefully to understand the problems
2. **Group Analysis:** Identify common patterns or root causes across issues
3. **Implement Fixes:** Create minimal, targeted fixes for each issue
4. **Test Changes:** Ensure all related tests pass
5. **Update Documentation:** If configuration or usage changes

### ✅ Acceptance Criteria

- [ ] All linked issues are addressed
- [ ] Tests pass for affected areas
- [ ] No new issues introduced
- [ ] Documentation updated if needed
- [ ] Each issue closed with resolution summary

### 🔗 Related Issues

${issues.map(issue => `#${issue.number}`).join(', ')}

### 📊 Metrics

- **Issues Grouped:** ${issues.length}
- **Priority Level:** ${priority}
- **Estimated Complexity:** ${issues.length === 1 ? 'Low' : issues.length <= 3 ? 'Medium' : 'High'}

---
**Auto-created:** ${new Date().toISOString()}
**Branch:** \`${branchName}\`
**Workflow:** Auto-Create PRs for Prioritized Issues`;

              // Create PR
              try {
                const pr = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: prTitle,
                  head: branchName,
                  base: 'main',
                  body: prBody
                });

                console.log(`✅ Created PR #${pr.data.number}: ${prTitle}`);
                console.log(`   Issues: ${issues.map(i => `#${i.number}`).join(', ')}`);

                // Add labels to PR
                const prLabels = ['auto-created', 'copilot-pr', type, priority];
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.data.number,
                  labels: prLabels
                });

                // Update each issue with PR link
                for (const issue of issues) {
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `## 🔗 Linked to PR

This issue has been grouped with related issues and linked to PR #${pr.data.number}.

**PR:** #${pr.data.number}
**Type:** ${type}
**Priority:** ${priority}
**Group:** ${issues.length} related ${issues.length === 1 ? 'issue' : 'issues'}

The PR includes @copilot assignment to implement fixes for all grouped issues. Please monitor the PR for progress.`
                    });

                    // Add 'in-progress' label to issue
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      labels: ['in-progress']
                    });
                  } catch (error) {
                    console.log(`⚠️ Failed to update issue #${issue.number}: ${error.message}`);
                  }
                }

                // Add @copilot mention in separate comment to trigger Copilot Workspace
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.data.number,
                  body: `@copilot Please implement the fixes described in this PR. Review all ${issues.length} linked issue(s) and create targeted solutions.`
                });

              } catch (error) {
                console.log(`❌ Failed to create PR for group ${groupKey}: ${error.message}`);
                
                // Clean up branch if PR creation failed
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branchName}`
                  });
                } catch (deleteError) {
                  console.log(`⚠️ Failed to delete branch ${branchName}`);
                }
              }
            }

            console.log('\n✅ PR creation complete!');

      - name: 📝 Summary
        if: always()
        shell: bash
        run: |
          if [ -n "$GITHUB_STEP_SUMMARY" ]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## 🚀 Auto-Create PRs - Phase 2

          This workflow automatically groups related prioritized issues and creates PRs for efficient resolution.

          ### How It Works
          1. **Scans** for open issues with `copilot-task` label and P1-P10 priority
          2. **Groups** issues by type (code-quality, testing, security) AND file/domain context
          3. **Creates PRs** for each group (min 2 issues, or single P1/P2 issues)
          4. **Links Issues** to PR and adds `in-progress` label
          5. **Mentions @copilot** in PR to trigger Copilot Workspace

          ### Grouping Strategy
          - **By Type:** PSScriptAnalyzer, testing, security, maintenance
          - **By Domain:** File path analysis (domains/, automation-scripts/, tests/)
          - **By Priority:** P1-P10 labels

          ### Benefits
          - ✅ Related issues fixed together
          - ✅ Less PR overhead
          - ✅ Better context for @copilot
          - ✅ Efficient resource usage
          - ✅ Clear progress tracking

          **Status:** ${{ steps.group_issues.outputs.has_issues == 'true' && 'PRs created' || 'No issues ready' }}
          **Groups Processed:** ${{ steps.group_issues.outputs.group_count || '0' }}
          EOF
          fi
