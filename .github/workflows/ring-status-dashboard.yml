---
name: üîÑ Ring Status Dashboard

# Generate comprehensive status dashboard for ring-based branching strategy
on:
  push:
    branches: [main, develop, dev, dev-staging, ring-0, ring-0-integrations, ring-1, ring-1-integrations, ring-2]
  pull_request:
    branches: [main, develop, dev, dev-staging, ring-0, ring-0-integrations, ring-1, ring-1-integrations, ring-2]
  schedule:
    # Update dashboard every hour
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force dashboard update'
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: read
  checks: read
  actions: read

concurrency:
  group: ring-status-dashboard-${{ github.ref }}
  cancel-in-progress: true

env:
  AITHERZERO_CI: true
  AITHERZERO_NONINTERACTIVE: true

jobs:
  generate-ring-status:
    name: üìä Generate Ring Status Dashboard
    # Skip if triggered by bot to prevent loops
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for branch comparison

      - name: üîß Bootstrap Environment
        shell: pwsh
        run: |
          ./bootstrap.ps1 -Mode New -InstallProfile Minimal

      - name: üìä Generate Ring Status Data
        id: generate-status
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Define ring structure
            const rings = [
              { name: 'main', displayName: 'Main (Production)', color: '#28a745', description: 'Production-ready code' },
              { name: 'develop', displayName: 'Develop (Pre-Release)', color: '#0366d6', description: 'Release candidate' },
              { name: 'dev', displayName: 'Dev (Integration)', color: '#6f42c1', description: 'Development integration' },
              { name: 'ring-0', displayName: 'Ring 0 (Core Foundation)', color: '#d73a49', description: 'Core infrastructure changes' },
              { name: 'ring-0-integrations', displayName: 'Ring 0 Integrations', color: '#e36209', description: 'Core feature integration' },
              { name: 'ring-1', displayName: 'Ring 1 (Features)', color: '#0366d6', description: 'New feature development' },
              { name: 'ring-1-integrations', displayName: 'Ring 1 Integrations', color: '#0969da', description: 'Feature integration testing' },
              { name: 'ring-2', displayName: 'Ring 2 (Experimental)', color: '#8b949e', description: 'Experimental features' }
            ];

            const statusData = {
              timestamp: new Date().toISOString(),
              rings: []
            };

            // Fetch data for each ring
            for (const ring of rings) {
              console.log(`Fetching data for ${ring.name}...`);

              let branchData = null;
              let commits = [];
              let prs = [];
              let checks = [];

              try {
                // Get branch info
                try {
                  const { data: branch } = await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: ring.name
                  });
                  branchData = branch;
                } catch (error) {
                  console.log(`Branch ${ring.name} not found or inaccessible`);
                }

                // Get recent commits (last 10)
                if (branchData) {
                  const { data: commitData } = await github.rest.repos.listCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    sha: ring.name,
                    per_page: 10
                  });
                  commits = commitData.map(c => ({
                    sha: c.sha.substring(0, 7),
                    message: c.commit.message.split('\n')[0],
                    author: c.commit.author.name,
                    date: c.commit.author.date
                  }));
                }

                // Get open PRs targeting this branch
                const { data: prData } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  base: ring.name,
                  per_page: 50
                });
                
                prs = await Promise.all(prData.map(async pr => {
                  // Get detailed PR info including files changed
                  let filesChanged = [];
                  let additions = 0;
                  let deletions = 0;
                  
                  try {
                    const { data: files } = await github.rest.pulls.listFiles({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: pr.number,
                      per_page: 100
                    });
                    
                    filesChanged = files.map(f => ({
                      filename: f.filename,
                      status: f.status,
                      additions: f.additions,
                      deletions: f.deletions,
                      changes: f.changes,
                      patch: f.patch ? f.patch.substring(0, 500) : null // First 500 chars of diff
                    }));
                    
                    additions = files.reduce((sum, f) => sum + f.additions, 0);
                    deletions = files.reduce((sum, f) => sum + f.deletions, 0);
                  } catch (error) {
                    console.log(`Could not fetch files for PR #${pr.number}: ${error.message}`);
                  }
                  
                  // Get PR reviews
                  let reviews = [];
                  try {
                    const { data: reviewData } = await github.rest.pulls.listReviews({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: pr.number
                    });
                    
                    reviews = reviewData.map(r => ({
                      user: r.user.login,
                      state: r.state,
                      submitted_at: r.submitted_at
                    }));
                  } catch (error) {
                    console.log(`Could not fetch reviews for PR #${pr.number}: ${error.message}`);
                  }
                  
                  return {
                    number: pr.number,
                    title: pr.title,
                    author: pr.user.login,
                    created: pr.created_at,
                    updated: pr.updated_at,
                    url: pr.html_url,
                    draft: pr.draft,
                    mergeable: pr.mergeable_state,
                    head: {
                      ref: pr.head.ref,
                      sha: pr.head.sha.substring(0, 7),
                      label: pr.head.label
                    },
                    base: {
                      ref: pr.base.ref,
                      sha: pr.base.sha.substring(0, 7)
                    },
                    filesChanged: filesChanged.length,
                    additions: additions,
                    deletions: deletions,
                    files: filesChanged,
                    reviews: reviews,
                    labels: pr.labels.map(l => l.name),
                    comments: pr.comments,
                    reviewComments: pr.review_comments,
                    commits: pr.commits
                  };
                }));

                // Get check runs for the latest commit
                if (branchData) {
                  try {
                    const { data: checkData } = await github.rest.checks.listForRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: branchData.commit.sha,
                      per_page: 100
                    });
                    
                    checks = checkData.check_runs.map(check => ({
                      name: check.name,
                      status: check.status,
                      conclusion: check.conclusion,
                      url: check.html_url
                    }));
                  } catch (error) {
                    console.log(`Could not fetch checks for ${ring.name}: ${error.message}`);
                  }
                }

              } catch (error) {
                console.error(`Error fetching data for ${ring.name}:`, error.message);
              }

              // Calculate health score
              let healthScore = 100;
              const failedChecks = checks.filter(c => c.conclusion === 'failure').length;
              const successChecks = checks.filter(c => c.conclusion === 'success').length;
              
              if (checks.length > 0) {
                healthScore = Math.round((successChecks / checks.length) * 100);
              }

              // Determine status
              let status = 'healthy';
              if (!branchData) {
                status = 'missing';
                healthScore = 0;
              } else if (failedChecks > 0) {
                status = 'failing';
              } else if (checks.length === 0) {
                status = 'unknown';
                healthScore = 50;
              }

              statusData.rings.push({
                ...ring,
                exists: !!branchData,
                lastCommit: branchData ? {
                  sha: branchData.commit.sha.substring(0, 7),
                  message: branchData.commit.commit.message.split('\n')[0],
                  author: branchData.commit.commit.author.name,
                  date: branchData.commit.commit.author.date
                } : null,
                commits: commits,
                openPRs: prs.length,
                prs: prs,
                checks: {
                  total: checks.length,
                  success: successChecks,
                  failed: failedChecks,
                  pending: checks.filter(c => c.status === 'in_progress').length,
                  details: checks
                },
                healthScore: healthScore,
                status: status
              });
            }

            // Save to file
            const outputDir = './reports/ring-status';
            if (!fs.existsSync(outputDir)) {
              fs.mkdirSync(outputDir, { recursive: true });
            }

            const dataPath = path.join(outputDir, 'ring-status-data.json');
            fs.writeFileSync(dataPath, JSON.stringify(statusData, null, 2));

            console.log(`‚úÖ Generated ring status data: ${dataPath}`);
            return statusData;

      - name: üìä Generate HTML Dashboard
        shell: pwsh
        run: |
          # Import ring status dashboard builder
          Import-Module ./library/automation-scripts/RingStatusDashboard.psm1 -Force
          
          # Load data
          $dataPath = "./reports/ring-status/ring-status-data.json"
          $data = Get-Content $dataPath | ConvertFrom-Json
          
          # Generate HTML using module (NO HERE-STRINGS!)
          $html = New-RingStatusHTML -Data $data
          
          # Save HTML
          $htmlPath = "./reports/ring-status/ring-status.html"
          $html | Out-File -FilePath $htmlPath -Encoding UTF8
          
          Write-Host "‚úÖ Generated HTML dashboard: $htmlPath" -ForegroundColor Green

      - name: üì§ Copy to Reports Directory for Jekyll
        shell: pwsh
        run: |
          Write-Host "üì§ Copying ring status to reports directory..." -ForegroundColor Cyan
          
          # Ensure reports directory exists
          $reportsDir = "./reports"
          if (-not (Test-Path $reportsDir)) {
            New-Item -ItemType Directory -Path $reportsDir -Force | Out-Null
          }
          
          # Copy ring status HTML and JSON
          Copy-Item "./reports/ring-status/index.html" "$reportsDir/ring-status.html" -Force
          Copy-Item "./reports/ring-status/ring-status-data.json" "$reportsDir/ring-status-data.json" -Force
          
          Write-Host "‚úÖ Copied to reports/ for Jekyll deployment" -ForegroundColor Green
          
          # Update main dashboard.json to include ring status link
          $dashboardPath = "$reportsDir/dashboard.json"
          if (Test-Path $dashboardPath) {
            try {
              $dashboard = Get-Content $dashboardPath -Raw | ConvertFrom-Json
              
              # Add ring status section if it doesn't exist
              if (-not $dashboard.PSObject.Properties['RingStatus']) {
                $dashboard | Add-Member -NotePropertyName 'RingStatus' -NotePropertyValue @{
                  DashboardUrl = 'ring-status.html'
                  DataUrl = 'ring-status-data.json'
                  LastUpdated = (Get-Date).ToString('yyyy-MM-ddTHH:mm:ss.fffZ')
                } -Force
                
                $dashboard | ConvertTo-Json -Depth 10 | Out-File -FilePath $dashboardPath -Encoding UTF8
                Write-Host "‚úÖ Updated dashboard.json with ring status links" -ForegroundColor Green
              }
            } catch {
              Write-Host "‚ö†Ô∏è Could not update dashboard.json: $_" -ForegroundColor Yellow
            }
          }

      - name: üîó Update Index Page with Ring Status Link
        shell: pwsh
        run: |
          Write-Host "üîó Adding ring status link to index.md..." -ForegroundColor Cyan
          
          $indexPath = "./index.md"
          if (Test-Path $indexPath) {
            $content = Get-Content $indexPath -Raw
            
            # Check if ring status link already exists
            if ($content -notmatch 'ring-status\.html') {
              # Load ring status link template
              $templatePath = "./library/_templates/ring-status-link.md"
              if (Test-Path $templatePath) {
                $ringStatusLink = Get-Content $templatePath -Raw
              } else {
                # Fallback if template not found
                $ringStatusLink = "`n## üîÑ Ring Status Dashboard`n`nView real-time status across all development rings.`n"
              }
              
              # Insert after the main dashboard link or at the end
              if ($content -match '## .* Dashboard') {
                $content = $content -replace '(## .* Dashboard.*?\n\n)', "`$1$ringStatusLink"
              } else {
                $content += $ringStatusLink
              }
              
              $content | Out-File -FilePath $indexPath -Encoding UTF8
              Write-Host "‚úÖ Added ring status link to index.md" -ForegroundColor Green
            } else {
              Write-Host "‚ÑπÔ∏è Ring status link already exists in index.md" -ForegroundColor Cyan
            }
          }

      - name: üìä Commit Changes to Repository
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/ring-0-integrations'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add reports/ring-status.html reports/ring-status-data.json reports/dashboard.json index.md
          git commit -m "Update ring status dashboard - $(date -u +"%Y-%m-%d %H:%M:%S UTC")" || echo "No changes to commit"
          git push origin HEAD:${{ github.ref_name }}

      - name: üìä Upload Dashboard Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ring-status-dashboard
          path: |
            reports/ring-status/*.html
            reports/ring-status/*.json
          retention-days: 30
