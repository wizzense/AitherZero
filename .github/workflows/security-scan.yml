name: Security Scan

on:
  schedule:
    # Run every Monday at 3:00 AM UTC
    - cron: '0 3 * * 1'
  pull_request:
    branches: [ main, develop ]
    paths:
      - '**/*.ps1'
      - '**/*.psm1'
      - '**/*.psd1'
      - '**/requirements.psd1'
      - '**/packages.config'
      - '.github/workflows/security-scan.yml'
  workflow_dispatch:
    inputs:
      scan_type:
        description: 'Type of scan to run'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - codeql
          - dependencies
          - secrets

# Security: Minimal permissions by default
permissions:
  contents: read

jobs:
  # CodeQL Analysis for PowerShell code
  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'schedule' || 
      github.event_name == 'pull_request' || 
      (github.event_name == 'workflow_dispatch' && (github.event.inputs.scan_type == 'all' || github.event.inputs.scan_type == 'codeql'))
    permissions:
      actions: read
      contents: read
      security-events: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: 'javascript'  # PowerShell is analyzed as JavaScript
        queries: security-and-quality
        
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:powershell"
        
  # Dependency vulnerability scanning
  dependency-scan:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'schedule' || 
      github.event_name == 'pull_request' || 
      (github.event_name == 'workflow_dispatch' && (github.event.inputs.scan_type == 'all' || github.event.inputs.scan_type == 'dependencies'))
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    # PowerShell is pre-installed on GitHub runners
        
    - name: Scan PowerShell module dependencies
      shell: pwsh
      run: |
        Write-Host "Scanning PowerShell module dependencies..." -ForegroundColor Cyan
        
        # Get all module manifests
        $manifests = Get-ChildItem -Path . -Include "*.psd1" -Recurse
        $vulnerabilities = @()
        
        foreach ($manifest in $manifests) {
          Write-Host "Checking: $($manifest.Name)" -ForegroundColor Gray
          
          try {
            $data = Import-PowerShellDataFile -Path $manifest.FullName
            
            # Check required modules
            if ($data.RequiredModules) {
              foreach ($module in $data.RequiredModules) {
                $moduleName = if ($module -is [hashtable]) { $module.ModuleName } else { $module }
                $moduleVersion = if ($module -is [hashtable]) { $module.ModuleVersion } else { $null }
                
                # Check against known vulnerable versions (this is a simplified check)
                # In production, you'd use a vulnerability database API
                $knownVulnerabilities = @{
                  'Az' = @('1.0.0', '1.1.0')  # Example vulnerable versions
                  'AzureRM' = @('*')  # Deprecated module
                }
                
                if ($knownVulnerabilities.ContainsKey($moduleName)) {
                  if ($knownVulnerabilities[$moduleName] -contains '*' -or 
                      $knownVulnerabilities[$moduleName] -contains $moduleVersion) {
                    $vulnerabilities += @{
                      Module = $moduleName
                      Version = $moduleVersion
                      File = $manifest.Name
                      Severity = 'High'
                      Message = "Known vulnerable or deprecated module"
                    }
                  }
                }
              }
            }
          }
          catch {
            Write-Warning "Failed to parse $($manifest.Name): $_"
          }
        }
        
        # Report findings
        if ($vulnerabilities.Count -gt 0) {
          Write-Host "`nâš ï¸ Found $($vulnerabilities.Count) vulnerable dependencies:" -ForegroundColor Yellow
          $vulnerabilities | ForEach-Object {
            Write-Host "::warning file=$($_.File)::$($_.Module) $($_.Version): $($_.Message)"
          }
          
          # Create SARIF report
          $sarif = @{
            version = "2.1.0"
            runs = @(@{
              tool = @{
                driver = @{
                  name = "PowerShell Dependency Scanner"
                  version = "1.0.0"
                }
              }
              results = $vulnerabilities | ForEach-Object {
                @{
                  ruleId = "vulnerable-dependency"
                  level = $_.Severity.ToLower()
                  message = @{
                    text = "$($_.Module) $($_.Version): $($_.Message)"
                  }
                  locations = @(@{
                    physicalLocation = @{
                      artifactLocation = @{
                        uri = $_.File
                      }
                    }
                  })
                }
              }
            })
          }
          
          $sarif | ConvertTo-Json -Depth 10 | Set-Content -Path dependency-scan.sarif
          Write-Host "Created SARIF report: dependency-scan.sarif"
        } else {
          Write-Host "âœ… No vulnerable dependencies found" -ForegroundColor Green
        }
        
    - name: Check for outdated modules
      shell: pwsh
      run: |
        Write-Host "Checking for outdated PowerShell modules..." -ForegroundColor Cyan
        
        # Get all unique required modules
        $allModules = @{}
        Get-ChildItem -Path . -Include "*.psd1" -Recurse | ForEach-Object {
          try {
            $data = Import-PowerShellDataFile -Path $_.FullName
            if ($data.RequiredModules) {
              foreach ($module in $data.RequiredModules) {
                $name = if ($module -is [hashtable]) { $module.ModuleName } else { $module }
                $version = if ($module -is [hashtable]) { $module.ModuleVersion } else { '0.0.0' }
                
                if (-not $allModules.ContainsKey($name) -or 
                    [version]$version -gt [version]$allModules[$name]) {
                  $allModules[$name] = $version
                }
              }
            }
          } catch {}
        }
        
        # Check for updates (simplified - in production use PSGallery API)
        $outdated = @()
        foreach ($module in $allModules.GetEnumerator()) {
          Write-Host "Checking $($module.Key) (current: $($module.Value))..." -NoNewline
          
          try {
            $latest = Find-Module -Name $module.Key -ErrorAction SilentlyContinue | 
                      Select-Object -First 1 -ExpandProperty Version
            
            if ($latest -and [version]$latest -gt [version]$module.Value) {
              Write-Host " Update available: $latest" -ForegroundColor Yellow
              $outdated += "$($module.Key): $($module.Value) â†’ $latest"
            } else {
              Write-Host " Up to date" -ForegroundColor Green
            }
          }
          catch {
            Write-Host " Unable to check" -ForegroundColor Gray
          }
        }
        
        if ($outdated.Count -gt 0) {
          Write-Host "`nðŸ“¦ Outdated modules:" -ForegroundColor Yellow
          $outdated | ForEach-Object { Write-Host "  $_" }
        }
        
    - name: Upload dependency scan results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: dependency-scan-results
        path: |
          dependency-scan.sarif
          outdated-modules.txt
        retention-days: 30
        
  # Secret scanning
  secrets-scan:
    name: Secrets Detection
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'schedule' || 
      github.event_name == 'pull_request' || 
      (github.event_name == 'workflow_dispatch' && (github.event.inputs.scan_type == 'all' || github.event.inputs.scan_type == 'secrets'))
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for better detection
        
    - name: TruffleHog OSS scan
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        base: ${{ github.event.repository.default_branch }}
        head: HEAD
        extra_args: --debug --only-verified
        
    - name: GitLeaks scan
      uses: gitleaks/gitleaks-action@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Custom PowerShell secrets scan
      shell: pwsh
      run: |
        Write-Host "Running custom PowerShell secrets scan..." -ForegroundColor Cyan
        
        # Common patterns to detect
        $patterns = @{
          'API Key' = 'api[_-]?key\s*[:=]\s*["\']?[a-zA-Z0-9]{32,}'
          'AWS Key' = 'AKIA[0-9A-Z]{16}'
          'Azure Key' = 'DefaultEndpointsProtocol=https.*AccountKey=[a-zA-Z0-9+/=]{88}'
          'Private Key' = '-----BEGIN (RSA |EC |DSA )?PRIVATE KEY-----'
          'Password' = '(?i)(password|passwd|pwd)\s*[:=]\s*["\'][^"\']{8,}'
          'Token' = '(?i)(token|bearer)\s*[:=]\s*["\'][a-zA-Z0-9._-]{20,}'
          'Connection String' = '(?i)(server|data source)=.*;(password|pwd)=.*'
          'GitHub Token' = 'gh[pousr]_[A-Za-z0-9_]{36}'
        }
        
        $findings = @()
        $files = Get-ChildItem -Path . -Include "*.ps1","*.psm1","*.psd1","*.json","*.xml","*.config" -Recurse |
                 Where-Object { $_.FullName -notmatch '\\\.git\\|/\.git/' }
        
        foreach ($file in $files) {
          $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
          if (-not $content) { continue }
          
          $lineNumber = 0
          foreach ($line in ($content -split "`n")) {
            $lineNumber++
            
            foreach ($pattern in $patterns.GetEnumerator()) {
              if ($line -match $pattern.Value) {
                # Check if it's a false positive
                $isFalsePositive = $false
                
                # Enhanced false positive detection
                if ($line -match '^\s*#' -or                    # Comment
                    $line -match 'example|sample|test|demo|mock' -or # Example code
                    $line -match '\$\{.*\}' -or                 # Variable substitution
                    $line -match '\$env:' -or                   # Environment variable
                    $line -match 'ConvertTo-SecureString' -or   # Secure string handling
                    $line -match 'ToBase64String' -or           # Base64 encoding (legitimate)
                    $line -match 'Generate.*key' -or            # Key generation
                    $line -match 'New.*key' -or                 # Key creation
                    $line -match 'Create.*key' -or              # Key creation
                    $line -match 'localhost|127\.0\.0\.1' -or   # Local connections
                    $line -match 'It "Should.*"' -or            # Pester tests
                    $line -match 'Context ".*"' -or             # Pester contexts
                    $line -match 'Describe ".*"' -or            # Pester describes
                    $file.FullName -match '\.Tests\.ps1$|test|mock|example|sample') # Test files
                {
                  $isFalsePositive = $true
                }
                
                if (-not $isFalsePositive) {
                  $findings += @{
                    Type = $pattern.Key
                    File = $file.FullName -replace [regex]::Escape($PWD.Path), '.'
                    Line = $lineNumber
                    Content = ($line -replace $pattern.Value, '[REDACTED]').Trim()
                  }
                }
              }
            }
          }
        }
        
        # Report findings
        if ($findings.Count -gt 0) {
          Write-Host "`nðŸš¨ Found $($findings.Count) potential secrets:" -ForegroundColor Red
          $findings | ForEach-Object {
            Write-Host "::error file=$($_.File),line=$($_.Line)::$($_.Type) detected: $($_.Content)"
          }
          
          # Create report
          $findings | ConvertTo-Json -Depth 3 | Set-Content -Path secrets-scan-report.json
          
          # Fail the build
          throw "Potential secrets detected! Please review and remove them."
        } else {
          Write-Host "âœ… No secrets detected" -ForegroundColor Green
        }
        
    - name: Upload scan results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: secrets-scan-results
        path: |
          secrets-scan-report.json
          .gitleaks-report.json
        retention-days: 7
        
  # PowerShell-specific security checks
  powershell-security:
    name: PowerShell Security Analysis
    runs-on: windows-latest
    if: github.event_name == 'pull_request' || github.event_name == 'schedule'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Analyze script security
      shell: pwsh
      run: |
        Write-Host "Analyzing PowerShell script security..." -ForegroundColor Cyan
        
        $issues = @()
        $scripts = Get-ChildItem -Path . -Include "*.ps1","*.psm1" -Recurse
        
        foreach ($script in $scripts) {
          $content = Get-Content $script.FullName -Raw
          $ast = [System.Management.Automation.Language.Parser]::ParseInput($content, [ref]$null, [ref]$null)
          
          # Check for dangerous commands
          $dangerousCommands = @(
            'Invoke-Expression',
            'iex',
            'Invoke-Command',
            'Start-Process',
            'New-Object System.Diagnostics.Process',
            'Add-Type',
            '[System.Reflection.Assembly]::Load'
          )
          
          foreach ($cmd in $dangerousCommands) {
            if ($content -match $cmd) {
              # Check if it's legitimate usage
              $isLegitimate = $false
              
              # Skip if it's in a test file or has legitimate context
              if ($script.FullName -match '\.Tests\.ps1$|test|mock|example|sample') {
                $isLegitimate = $true
              }
              
              # Check for legitimate usage patterns
              $legitimateContexts = @(
                'try\s*{[^}]*' + $cmd,       # In try-catch blocks
                'if\s*\([^)]*\)\s*{[^}]*' + $cmd,  # In conditional blocks
                '#.*' + $cmd,                # In comments
                'param\s*\([^)]*\)\s*{[^}]*' + $cmd,  # In function parameters
                'Write-.*Log.*' + $cmd,      # In logging contexts
                'Test-.*' + $cmd,            # In test functions
                'Debug.*' + $cmd,            # In debug contexts
                'Validate.*' + $cmd          # In validation contexts
              )
              
              foreach ($context in $legitimateContexts) {
                if ($content -match $context) {
                  $isLegitimate = $true
                  break
                }
              }
              
              # Special handling for common legitimate cases
              switch ($cmd) {
                'Start-Process' {
                  # Legitimate if using -Wait, -PassThru, or well-formed arguments
                  if ($content -match 'Start-Process.*(-Wait|-PassThru|-ArgumentList|-FilePath)') {
                    $isLegitimate = $true
                  }
                }
                'Invoke-Expression' {
                  # Legitimate if used for dynamic script generation with validation
                  if ($content -match 'Invoke-Expression.*\$\w+.*Validate|Test-.*Expression') {
                    $isLegitimate = $true
                  }
                }
                'Invoke-Command' {
                  # Legitimate for remote operations
                  if ($content -match 'Invoke-Command.*(-ComputerName|-Session|-ScriptBlock)') {
                    $isLegitimate = $true
                  }
                }
              }
              
              # Only report if it's not legitimate usage
              if (-not $isLegitimate) {
                $issues += @{
                  File = $script.FullName
                  Issue = "Uses potentially dangerous command: $cmd"
                  Severity = 'Warning'
                }
              }
            }
          }
          
          # Check for web downloads without validation (improved)
          if ($content -match 'Invoke-WebRequest|Invoke-RestMethod|wget|curl') {
            # Check if it has proper error handling or is in legitimate context
            $hasErrorHandling = $false
            
            $errorHandlingPatterns = @(
              'try\s*{[^}]*(?:Invoke-WebRequest|Invoke-RestMethod)',
              'catch\s*{[^}]*(?:Invoke-WebRequest|Invoke-RestMethod)',
              '-ErrorAction\s+(?:Stop|SilentlyContinue|Ignore)',
              'if\s*\([^)]*\)\s*{[^}]*(?:Invoke-WebRequest|Invoke-RestMethod)',
              'Test-.*Connection',
              'Validate-.*Url'
            )
            
            foreach ($pattern in $errorHandlingPatterns) {
              if ($content -match $pattern) {
                $hasErrorHandling = $true
                break
              }
            }
            
            # Skip test files and legitimate download functions
            if ($script.FullName -match '\.Tests\.ps1$|test|mock|example|sample' -or
                $content -match 'Install-.*Dependencies|Download-.*|Get-.*Download') {
              $hasErrorHandling = $true
            }
            
            if (-not $hasErrorHandling) {
              $issues += @{
                File = $script.FullName
                Issue = "Web request without proper error handling"
                Severity = 'Warning'
              }
            }
          }
          
          # Check for credential handling (improved logic)
          if ($content -match 'ConvertTo-SecureString.*-AsPlainText') {
            # Check if it's legitimate usage
            $isLegitimate = $false
            
            # Legitimate patterns for secure string usage
            $legitimatePatterns = @(
              'ToBase64String',           # Key generation
              'Generate.*key',            # Key generation functions
              'New.*key',                 # Key creation functions
              'Create.*key',              # Key creation functions
              '\$env:',                   # Environment variables
              'Get-Credential',           # Credential prompt
              '\[PSCredential\]',         # Credential objects
              'Test.*key',                # Test keys
              'Mock.*key',                # Mock keys
              'Example.*key',             # Example keys
              'Sample.*key',              # Sample keys
              'Demo.*key'                 # Demo keys
            )
            
            foreach ($pattern in $legitimatePatterns) {
              if ($content -match $pattern) {
                $isLegitimate = $true
                break
              }
            }
            
            # Check if it's in a test file
            if ($script.FullName -match '\.Tests\.ps1$|test|mock|example|sample') {
              $isLegitimate = $true
            }
            
            # Only report if it's not legitimate usage
            if (-not $isLegitimate) {
              $issues += @{
                File = $script.FullName
                Issue = "Hardcoded credentials or insecure credential handling"
                Severity = 'High'
              }
            }
          }
          
          # Check execution policy bypass
          if ($content -match '-ExecutionPolicy\s+(?:Bypass|Unrestricted)') {
            $issues += @{
              File = $script.FullName
              Issue = "Attempts to bypass execution policy"
              Severity = 'Warning'
            }
          }
        }
        
        # Report issues
        if ($issues.Count -gt 0) {
          Write-Host "`nâš ï¸ Security issues found:" -ForegroundColor Yellow
          $issues | Group-Object Severity | ForEach-Object {
            Write-Host "`n$($_.Name) severity issues ($($_.Count)):" -ForegroundColor Yellow
            $_.Group | ForEach-Object {
              Write-Host "  - $($_.File): $($_.Issue)"
            }
          }
          
          # Create annotations
          $issues | ForEach-Object {
            $level = if ($_.Severity -eq 'High') { 'error' } else { 'warning' }
            Write-Host "::$level file=$($_.File)::$($_.Issue)"
          }
          
          if (($issues | Where-Object Severity -eq 'High').Count -gt 0) {
            throw "High severity security issues found!"
          }
        } else {
          Write-Host "âœ… No security issues found" -ForegroundColor Green
        }
        
  # Security report summary
  security-summary:
    name: Security Summary
    runs-on: ubuntu-latest
    needs: [codeql, dependency-scan, secrets-scan, powershell-security]
    if: always()
    
    steps:
    - name: Check results
      shell: pwsh
      run: |
        Write-Host "ðŸ”’ Security Scan Summary" -ForegroundColor Cyan
        Write-Host "========================" -ForegroundColor Cyan
        
        $results = @{
          'CodeQL Analysis' = '${{ needs.codeql.result }}'
          'Dependency Scan' = '${{ needs.dependency-scan.result }}'
          'Secrets Scan' = '${{ needs.secrets-scan.result }}'
          'PowerShell Security' = '${{ needs.powershell-security.result }}'
        }
        
        $failed = 0
        foreach ($check in $results.GetEnumerator()) {
          $emoji = if ($check.Value -eq 'success') { 'âœ…' } 
                   elseif ($check.Value -eq 'failure') { 'âŒ'; $failed++ }
                   elseif ($check.Value -eq 'skipped') { 'â­ï¸' }
                   else { 'âš ï¸' }
          
          Write-Host "$emoji $($check.Key): $($check.Value)"
        }
        
        if ($failed -gt 0) {
          Write-Host "`nâŒ Security scan failed: $failed check(s) failed" -ForegroundColor Red
          exit 1
        } else {
          Write-Host "`nâœ… All security checks passed!" -ForegroundColor Green
        }
        
    - name: Post PR comment
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const results = {
            'CodeQL Analysis': '${{ needs.codeql.result }}',
            'Dependency Scan': '${{ needs.dependency-scan.result }}',
            'Secrets Scan': '${{ needs.secrets-scan.result }}',
            'PowerShell Security': '${{ needs.powershell-security.result }}'
          };
          
          let body = '## ðŸ”’ Security Scan Results\n\n';
          body += '| Check | Status |\n';
          body += '|-------|--------|\n';
          
          for (const [check, result] of Object.entries(results)) {
            const emoji = result === 'success' ? 'âœ…' : 
                         result === 'failure' ? 'âŒ' : 
                         result === 'skipped' ? 'â­ï¸' : 'âš ï¸';
            body += `| ${check} | ${emoji} ${result} |\n`;
          }
          
          body += '\n[View detailed security report](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})';
          
          // Update or create comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('ðŸ”’ Security Scan Results')
          );
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
          }