---
name: üöÄ Phase 2: Intelligent Issue Creation

# Comprehensive automated issue creation system that captures ALL failure types
# and creates intelligent, deduplicated issues with agent routing and rich context

on:
  workflow_run:
    workflows:
      - "üß™ Comprehensive Test Execution"
      - "‚úÖ PR Validation"
      - "üîç Quality Validation"
    types: [completed]
  
  schedule:
    # Daily analysis to catch any missed failures
    - cron: '0 3 * * *'  # 3 AM UTC daily
  
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - preview issues without creating them'
        type: boolean
        default: false
      force_analysis:
        description: 'Force re-analysis even if no new failures'
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  actions: read
  checks: write
  pull-requests: write

env:
  ISSUE_STATE_DIR: ./reports/issue-state

jobs:
  comprehensive-failure-analysis:
    name: üîç Comprehensive Failure Analysis
    runs-on: ubuntu-latest
    
    outputs:
      has-failures: ${{ steps.analysis.outputs.has-failures }}
      total-issues-to-create: ${{ steps.analysis.outputs.total-issues-to-create }}
      analysis-artifact: ${{ steps.analysis.outputs.analysis-artifact }}
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
      
      - name: üìä Download Workflow Artifacts
        if: github.event.workflow_run
        uses: dawidd6/action-download-artifact@v6
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          run_id: ${{ github.event.workflow_run.id }}
          path: ./artifacts
        continue-on-error: true
      
      - name: üì• Download Existing Issue State
        uses: actions/download-artifact@v4
        with:
          name: issue-state-db
          path: ${{ env.ISSUE_STATE_DIR }}
        continue-on-error: true
      
      - name: üîç Comprehensive Analysis
        id: analysis
        shell: pwsh
        run: |
          Write-Host "üîç Starting comprehensive failure analysis..." -ForegroundColor Cyan
          
          # Create issue state directory if it doesn't exist
          New-Item -ItemType Directory -Force -Path "$env:ISSUE_STATE_DIR" | Out-Null
          
          # Initialize analysis results
          $analysisResults = @{
            Timestamp = Get-Date -Format 'o'
            WorkflowContext = @{
              EventName = "${{ github.event_name }}"
              RunId = "${{ github.run_id }}"
              RunNumber = "${{ github.run_number }}"
              Actor = "${{ github.actor }}"
              Ref = "${{ github.ref }}"
              Sha = "${{ github.sha }}"
            }
            Failures = @{
              Tests = @()
              Syntax = @()
              CodeQuality = @()
              Security = @()
              Performance = @()
              Workflows = @()
            }
            IssueGroups = @()
          }
          
          if ("${{ github.event_name }}" -eq "workflow_run") {
            $analysisResults.WorkflowContext.TriggeredBy = @{
              WorkflowName = "${{ github.event.workflow_run.name }}"
              WorkflowId = "${{ github.event.workflow_run.id }}"
              Conclusion = "${{ github.event.workflow_run.conclusion }}"
              Status = "${{ github.event.workflow_run.status }}"
              HtmlUrl = "${{ github.event.workflow_run.html_url }}"
            }
          }
          
          Write-Host "üìÇ Searching for failure artifacts..." -ForegroundColor Yellow
          
          # 1. ANALYZE TEST FAILURES
          Write-Host "`nüß™ Analyzing test failures..." -ForegroundColor Cyan
          $testReportFiles = Get-ChildItem -Path "./reports", "./artifacts" -Filter "TestReport*.json" -Recurse -ErrorAction SilentlyContinue
          
          foreach ($reportFile in $testReportFiles) {
            try {
              $report = Get-Content $reportFile.FullName -Raw | ConvertFrom-Json
              
              if ($report.TestResults.Details) {
                foreach ($result in $report.TestResults.Details) {
                  if ($result.Result -eq 'Failed') {
                    $analysisResults.Failures.Tests += @{
                      TestName = $result.Name ?? $result.ExpandedName ?? 'Unknown Test'
                      TestType = $report.TestType ?? 'Unknown'
                      ErrorMessage = if ($result.ErrorRecord) { $result.ErrorRecord.Exception.Message } else { "Test failed" }
                      StackTrace = if ($result.ErrorRecord) { $result.ErrorRecord.ScriptStackTrace } else { $null }
                      File = if ($result.ScriptBlock) { $result.ScriptBlock.File } else { "Unknown" }
                      Line = if ($result.ScriptBlock) { $result.ScriptBlock.StartPosition.Line } else { 0 }
                      Duration = $result.Duration ?? 0
                      Timestamp = $report.Timestamp ?? (Get-Date -Format 'o')
                    }
                  }
                }
              }
            } catch {
              Write-Warning "Failed to parse test report: $($reportFile.Name) - $_"
            }
          }
          Write-Host "  Found $($analysisResults.Failures.Tests.Count) test failures" -ForegroundColor $(if ($analysisResults.Failures.Tests.Count -gt 0) { 'Red' } else { 'Green' })
          
          # 2. ANALYZE SYNTAX ERRORS
          Write-Host "`nüìù Analyzing syntax errors..." -ForegroundColor Cyan
          $syntaxReportFiles = Get-ChildItem -Path "./reports", "./artifacts" -Filter "*syntax*.json" -Recurse -ErrorAction SilentlyContinue
          
          foreach ($reportFile in $syntaxReportFiles) {
            try {
              $report = Get-Content $reportFile.FullName -Raw | ConvertFrom-Json
              
              if ($report.Errors) {
                foreach ($error in $report.Errors) {
                  $analysisResults.Failures.Syntax += @{
                    File = $error.File ?? 'Unknown'
                    Line = $error.Line ?? 0
                    Message = $error.Message ?? 'Syntax error'
                    Severity = 'Error'
                    Category = 'Syntax'
                  }
                }
              }
            } catch {
              Write-Warning "Failed to parse syntax report: $($reportFile.Name) - $_"
            }
          }
          Write-Host "  Found $($analysisResults.Failures.Syntax.Count) syntax errors" -ForegroundColor $(if ($analysisResults.Failures.Syntax.Count -gt 0) { 'Red' } else { 'Green' })
          
          # 3. ANALYZE CODE QUALITY ISSUES
          Write-Host "`n‚ö†Ô∏è  Analyzing code quality issues..." -ForegroundColor Cyan
          $qualityReportFiles = Get-ChildItem -Path "./reports", "./artifacts" -Filter "*psscriptanalyzer*.json" -Recurse -ErrorAction SilentlyContinue
          
          foreach ($reportFile in $qualityReportFiles) {
            try {
              $report = Get-Content $reportFile.FullName -Raw | ConvertFrom-Json
              
              if ($report.Results) {
                $groupedByFile = $report.Results | Group-Object -Property ScriptPath
                
                foreach ($group in $groupedByFile) {
                  $errors = @($group.Group | Where-Object { $_.Severity -eq 'Error' })
                  $warnings = @($group.Group | Where-Object { $_.Severity -eq 'Warning' })
                  
                  if ($errors.Count -gt 0 -or $warnings.Count -gt 10) {
                    $analysisResults.Failures.CodeQuality += @{
                      File = $group.Name
                      ErrorCount = $errors.Count
                      WarningCount = $warnings.Count
                      Issues = @($group.Group | ForEach-Object {
                        @{
                          RuleName = $_.RuleName
                          Severity = $_.Severity
                          Message = $_.Message
                          Line = $_.Line
                        }
                      })
                    }
                  }
                }
              }
            } catch {
              Write-Warning "Failed to parse quality report: $($reportFile.Name) - $_"
            }
          }
          Write-Host "  Found $($analysisResults.Failures.CodeQuality.Count) files with quality issues" -ForegroundColor $(if ($analysisResults.Failures.CodeQuality.Count -gt 0) { 'Yellow' } else { 'Green' })
          
          # 4. ANALYZE SECURITY ISSUES
          Write-Host "`nüîí Analyzing security issues..." -ForegroundColor Cyan
          $securityReportFiles = Get-ChildItem -Path "./reports", "./artifacts" -Filter "*security*.json" -Recurse -ErrorAction SilentlyContinue
          
          foreach ($reportFile in $securityReportFiles) {
            try {
              $report = Get-Content $reportFile.FullName -Raw | ConvertFrom-Json
              
              if ($report.Vulnerabilities) {
                foreach ($vuln in $report.Vulnerabilities) {
                  $analysisResults.Failures.Security += @{
                    Type = $vuln.Type ?? 'Security Issue'
                    Severity = $vuln.Severity ?? 'Medium'
                    Description = $vuln.Description ?? 'Security vulnerability detected'
                    File = $vuln.File ?? 'Unknown'
                    Recommendation = $vuln.Recommendation ?? 'Review and remediate'
                  }
                }
              }
            } catch {
              Write-Warning "Failed to parse security report: $($reportFile.Name) - $_"
            }
          }
          Write-Host "  Found $($analysisResults.Failures.Security.Count) security issues" -ForegroundColor $(if ($analysisResults.Failures.Security.Count -gt 0) { 'Red' } else { 'Green' })
          
          # 5. ANALYZE WORKFLOW FAILURES
          Write-Host "`nüîÑ Analyzing workflow failures..." -ForegroundColor Cyan
          if ("${{ github.event.workflow_run.conclusion }}" -eq "failure") {
            $analysisResults.Failures.Workflows += @{
              WorkflowName = "${{ github.event.workflow_run.name }}"
              WorkflowId = "${{ github.event.workflow_run.id }}"
              Conclusion = "failure"
              HtmlUrl = "${{ github.event.workflow_run.html_url }}"
              Timestamp = Get-Date -Format 'o'
            }
          }
          Write-Host "  Found $($analysisResults.Failures.Workflows.Count) workflow failures" -ForegroundColor $(if ($analysisResults.Failures.Workflows.Count -gt 0) { 'Red' } else { 'Green' })
          
          # Calculate total failures
          $totalFailures = $analysisResults.Failures.Tests.Count + 
                          $analysisResults.Failures.Syntax.Count + 
                          $analysisResults.Failures.CodeQuality.Count + 
                          $analysisResults.Failures.Security.Count + 
                          $analysisResults.Failures.Workflows.Count
          
          Write-Host "`nüìä Analysis Summary:" -ForegroundColor Green
          Write-Host "  Total Failures: $totalFailures" -ForegroundColor White
          Write-Host "    ‚Ä¢ Test Failures: $($analysisResults.Failures.Tests.Count)" -ForegroundColor White
          Write-Host "    ‚Ä¢ Syntax Errors: $($analysisResults.Failures.Syntax.Count)" -ForegroundColor White
          Write-Host "    ‚Ä¢ Code Quality: $($analysisResults.Failures.CodeQuality.Count)" -ForegroundColor White
          Write-Host "    ‚Ä¢ Security Issues: $($analysisResults.Failures.Security.Count)" -ForegroundColor White
          Write-Host "    ‚Ä¢ Workflow Failures: $($analysisResults.Failures.Workflows.Count)" -ForegroundColor White
          
          # Save analysis results
          $analysisResults | ConvertTo-Json -Depth 20 | Out-File -FilePath "./comprehensive-failure-analysis.json"
          
          # Set outputs
          "has-failures=$($totalFailures -gt 0)" >> $env:GITHUB_OUTPUT
          "total-issues-to-create=0" >> $env:GITHUB_OUTPUT
          "analysis-artifact=comprehensive-failure-analysis" >> $env:GITHUB_OUTPUT
          
          Write-Host "`n‚úÖ Comprehensive analysis complete!" -ForegroundColor Green
      
      - name: üì§ Upload Analysis Results
        uses: actions/upload-artifact@v4
        with:
          name: comprehensive-failure-analysis
          path: comprehensive-failure-analysis.json
          retention-days: 30

  intelligent-issue-grouping:
    name: üß† Intelligent Issue Grouping & Deduplication
    runs-on: ubuntu-latest
    needs: comprehensive-failure-analysis
    if: needs.comprehensive-failure-analysis.outputs.has-failures == 'true'
    
    outputs:
      issue-count: ${{ steps.grouping.outputs.issue-count }}
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
      
      - name: üìä Download Analysis Results
        uses: actions/download-artifact@v4
        with:
          name: comprehensive-failure-analysis
          path: ./
      
      - name: üì• Download Issue State
        uses: actions/download-artifact@v4
        with:
          name: issue-state-db
          path: ${{ env.ISSUE_STATE_DIR }}
        continue-on-error: true
      
      - name: üß† Intelligent Grouping
        id: grouping
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const crypto = require('crypto');
            
            // Load analysis results
            const analysis = JSON.parse(fs.readFileSync('./comprehensive-failure-analysis.json', 'utf8'));
            console.log('üìä Loaded analysis with', Object.keys(analysis.Failures).length, 'failure categories');
            
            // Load existing issues to check for duplicates
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'automated-issue',
              state: 'open',
              per_page: 100
            });
            
            console.log(`Found ${existingIssues.length} existing automated issues`);
            
            // Helper: Create fingerprint for deduplication
            function createFingerprint(failure) {
              const normalizedData = JSON.stringify({
                type: failure.Type || failure.TestType || 'unknown',
                file: (failure.File || '').replace(/\\/g, '/').toLowerCase(),
                error: (failure.ErrorMessage || failure.Message || '').replace(/\d+/g, 'N').toLowerCase(),
                category: failure.Category || failure.RuleName || 'general'
              });
              
              return crypto.createHash('sha256').update(normalizedData).digest('hex').substring(0, 16);
            }
            
            // Helper: Determine agent based on file and error type
            function determineAgent(failure) {
              const file = (failure.File || '').toLowerCase();
              const error = (failure.ErrorMessage || failure.Message || '').toLowerCase();
              
              // Infrastructure issues
              if (file.includes('infrastructure') || file.includes('vm') || file.includes('network') || file.includes('hyperv')) {
                return { agent: 'maya', name: 'Maya Infrastructure', mention: '@maya' };
              }
              
              // Security issues
              if (file.includes('security') || file.includes('certificate') || file.includes('credential') || error.includes('security')) {
                return { agent: 'sarah', name: 'Sarah Security', mention: '@sarah' };
              }
              
              // Test infrastructure issues
              if (file.includes('tests/') || file.includes('.Tests.ps1') || error.includes('pester')) {
                return { agent: 'jessica', name: 'Jessica Testing', mention: '@jessica' };
              }
              
              // UI/UX issues
              if (file.includes('experience/') || file.includes('ui') || file.includes('menu') || file.includes('wizard')) {
                return { agent: 'emma', name: 'Emma Frontend', mention: '@emma' };
              }
              
              // Backend/Module issues
              if (file.includes('.psm1') || file.includes('api') || file.includes('backend')) {
                return { agent: 'marcus', name: 'Marcus Backend', mention: '@marcus' };
              }
              
              // Documentation issues
              if (file.endsWith('.md') || file.includes('docs/')) {
                return { agent: 'olivia', name: 'Olivia Documentation', mention: '@olivia' };
              }
              
              // Default to PowerShell expert
              return { agent: 'rachel', name: 'Rachel PowerShell', mention: '@rachel' };
            }
            
            // Group failures intelligently
            const issueGroups = [];
            const processedFingerprints = new Set();
            
            // Process each failure type
            for (const [category, failures] of Object.entries(analysis.Failures)) {
              if (!failures || failures.length === 0) continue;
              
              console.log(`\nProcessing ${failures.length} ${category} failures...`);
              
              for (const failure of failures) {
                const fingerprint = createFingerprint(failure);
                
                // Check if already processed
                if (processedFingerprints.has(fingerprint)) {
                  console.log(`  Skipping duplicate: ${fingerprint}`);
                  continue;
                }
                
                // Check if issue already exists
                const existingIssue = existingIssues.find(i => 
                  i.body && i.body.includes(`<!-- fingerprint:${fingerprint} -->`)
                );
                
                if (existingIssue) {
                  console.log(`  Issue already exists for fingerprint: ${fingerprint} (#${existingIssue.number})`);
                  continue;
                }
                
                processedFingerprints.add(fingerprint);
                
                // Determine assigned agent
                const agent = determineAgent(failure);
                
                // Create issue group
                issueGroups.push({
                  fingerprint,
                  category,
                  failure,
                  agent,
                  priority: category === 'Security' ? 'p0' : category === 'Syntax' ? 'p1' : 'p2'
                });
              }
            }
            
            console.log(`\n‚úÖ Created ${issueGroups.length} unique issue groups`);
            
            // Save grouped issues
            fs.writeFileSync('./issue-groups.json', JSON.stringify({ issueGroups, analysis }, null, 2));
            
            core.setOutput('issue-count', issueGroups.length);
            
            return issueGroups.length;
      
      - name: üì§ Upload Issue Groups
        uses: actions/upload-artifact@v4
        with:
          name: issue-groups
          path: issue-groups.json
          retention-days: 30

  create-intelligent-issues:
    name: üìù Create Intelligent Issues
    runs-on: ubuntu-latest
    needs: [comprehensive-failure-analysis, intelligent-issue-grouping]
    if: |
      needs.intelligent-issue-grouping.outputs.issue-count > 0 &&
      github.event.inputs.dry_run != 'true'
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
      
      - name: üìä Download Issue Groups
        uses: actions/download-artifact@v4
        with:
          name: issue-groups
          path: ./
      
      - name: üìù Create Issues with Agent Assignment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Load issue groups
            const data = JSON.parse(fs.readFileSync('./issue-groups.json', 'utf8'));
            const { issueGroups, analysis } = data;
            
            console.log(`üìù Creating ${issueGroups.length} intelligent issues...`);
            
            let createdCount = 0;
            
            for (const group of issueGroups) {
              const { fingerprint, category, failure, agent, priority } = group;
              
              // Build issue title
              const title = category === 'Tests' 
                ? `üß™ Test Failure: ${failure.TestName}`
                : category === 'Syntax'
                ? `üìù Syntax Error in ${failure.File.split('/').pop()}`
                : category === 'CodeQuality'
                ? `‚ö†Ô∏è Code Quality Issues in ${failure.File.split('/').pop()}`
                : category === 'Security'
                ? `üîí Security Issue: ${failure.Type}`
                : `üîÑ Workflow Failure: ${failure.WorkflowName}`;
              
              // Build issue body with rich context
              const workflowContext = analysis.WorkflowContext.TriggeredBy 
                ? `- **Workflow:** [${analysis.WorkflowContext.TriggeredBy.WorkflowName}](${analysis.WorkflowContext.TriggeredBy.HtmlUrl})
            - **Run ID:** ${analysis.WorkflowContext.TriggeredBy.WorkflowId}
            - **Status:** ${analysis.WorkflowContext.TriggeredBy.Conclusion}`
                : `- **Manual Analysis:** Scheduled analysis`;
              
              const body = `## ${category} Failure Detected
            
            **Category:** ${category}
            **Priority:** ${priority}
            **Detected:** ${analysis.Timestamp}
            **File:** \`${failure.File || 'N/A'}\`
            ${failure.Line ? `**Line:** ${failure.Line}` : ''}
            
            ### Error Details
            
            ${failure.ErrorMessage || failure.Message || failure.Description || 'See details below'}
            
            ${failure.StackTrace ? `\`\`\`
            ${failure.StackTrace}
            \`\`\`` : ''}
            
            ### ü§ñ AI Agent Assignment
            
            ${agent.mention} This issue has been automatically assigned to you based on the failure category and affected files.
            
            **Agent:** ${agent.name}
            **Expertise:** ${agent.agent}
            
            #### Recommended Actions:
            
            1. **Analyze** the failure details and identify the root cause
            2. **Review** related code in \`${failure.File || 'affected files'}\`
            3. **Fix** the underlying issue
            4. **Test** to verify the fix works
            5. **Submit** a PR that references this issue with \`Fixes #ISSUE_NUMBER\`
            
            ${category === 'Security' ? '‚ö†Ô∏è **Security Issue:** Please prioritize this fix for security reasons.' : ''}
            
            ### Workflow Context
            
            ${workflowContext}
            
            ---
            *This issue was automatically created by the Phase 2 Intelligent Issue Creation System*
            <!-- fingerprint:${fingerprint} -->`;
              
              try {
                const labels = ['automated-issue', category.toLowerCase(), priority];
                
                // Add agent-specific label
                labels.push(`agent-${agent.agent}`);
                
                const newIssue = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title,
                  body,
                  labels
                });
                
                console.log(`‚úÖ Created issue #${newIssue.data.number}: ${title}`);
                createdCount++;
                
              } catch (error) {
                console.error(`‚ùå Failed to create issue: ${error.message}`);
              }
            }
            
            console.log(`\n‚úÖ Created ${createdCount} intelligent issues!`);
      
      - name: üìä Update Issue State Database
        shell: pwsh
        run: |
          Write-Host "üìä Updating issue state database..." -ForegroundColor Cyan
          
          $issueStateFile = "$env:ISSUE_STATE_DIR/issue-fingerprints.json"
          
          # Load existing state
          $issueState = if (Test-Path $issueStateFile) {
            Get-Content $issueStateFile -Raw | ConvertFrom-Json
          } else {
            @{ fingerprints = @(); lastUpdated = $null }
          }
          
          # Load created issues
          $issueGroups = Get-Content "./issue-groups.json" -Raw | ConvertFrom-Json
          
          # Add new fingerprints
          foreach ($group in $issueGroups.issueGroups) {
            if ($group.fingerprint -notin $issueState.fingerprints) {
              $issueState.fingerprints += $group.fingerprint
            }
          }
          
          $issueState.lastUpdated = Get-Date -Format 'o'
          $issueState.totalTracked = $issueState.fingerprints.Count
          
          # Save updated state
          New-Item -ItemType Directory -Force -Path "$env:ISSUE_STATE_DIR" | Out-Null
          $issueState | ConvertTo-Json -Depth 10 | Out-File -FilePath $issueStateFile
          
          Write-Host "‚úÖ Updated issue state database with $($issueState.fingerprints.Count) fingerprints" -ForegroundColor Green
      
      - name: üì§ Upload Issue State Database
        uses: actions/upload-artifact@v4
        with:
          name: issue-state-db
          path: ${{ env.ISSUE_STATE_DIR }}
          retention-days: 90

  dry-run-preview:
    name: üß™ Dry Run Preview
    runs-on: ubuntu-latest
    needs: [comprehensive-failure-analysis, intelligent-issue-grouping]
    if: |
      github.event.inputs.dry_run == 'true' &&
      needs.intelligent-issue-grouping.outputs.issue-count > 0
    
    steps:
      - name: üìä Download Issue Groups
        uses: actions/download-artifact@v4
        with:
          name: issue-groups
          path: ./
      
      - name: üìã Preview Issues
        shell: pwsh
        run: |
          Write-Host "üß™ DRY RUN MODE - Previewing issues that would be created" -ForegroundColor Yellow
          Write-Host "============================================================" -ForegroundColor Yellow
          Write-Host ""
          
          $data = Get-Content "./issue-groups.json" -Raw | ConvertFrom-Json
          
          Write-Host "üìä Summary:" -ForegroundColor Cyan
          Write-Host "  Total Issues to Create: $($data.issueGroups.Count)" -ForegroundColor White
          Write-Host ""
          
          foreach ($group in $data.issueGroups) {
            Write-Host "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" -ForegroundColor DarkGray
            Write-Host "  Category: $($group.category)" -ForegroundColor Yellow
            Write-Host "  Priority: $($group.priority)" -ForegroundColor Yellow
            Write-Host "  Agent: $($group.agent.name)" -ForegroundColor Cyan
            Write-Host "  File: $($group.failure.File)" -ForegroundColor White
            Write-Host "  Fingerprint: $($group.fingerprint)" -ForegroundColor DarkGray
            Write-Host ""
          }
          
          Write-Host "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" -ForegroundColor DarkGray
          Write-Host ""
          Write-Host "üí° Run without dry_run to create these issues" -ForegroundColor Blue
