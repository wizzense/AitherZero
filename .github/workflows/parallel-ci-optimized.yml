name: Parallel CI/CD Pipeline (Optimized)

on:
  push:
    branches: [ develop, main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - 'LICENSE'
  pull_request:
    branches: [ main, develop ]
    types: [ opened, synchronize, reopened ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - 'LICENSE'
  workflow_dispatch:
    inputs:
      test_level:
        description: 'Test Level (Quick/Standard/Complete)'
        required: false
        default: 'Standard'
        type: choice
        options:
          - Quick
          - Standard
          - Complete
      enable_automerge:
        description: 'Enable AutoMerge for PRs'
        required: false
        default: false
        type: boolean

# Aggressive parallelism with optimized concurrency
concurrency:
  group: parallel-ci-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: true

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1
  # Cache keys for optimized dependency management
  CACHE_VERSION: v3

permissions:
  contents: read
  issues: write
  pull-requests: write
  checks: write
  actions: read

jobs:
  # Fast setup and configuration job
  setup:
    name: üöÄ Setup & Configuration
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      test-level: ${{ steps.config.outputs.test-level }}
      matrix: ${{ steps.config.outputs.matrix }}
      cache-key: ${{ steps.config.outputs.cache-key }}
      should-run-security: ${{ steps.config.outputs.should-run-security }}
      should-run-performance: ${{ steps.config.outputs.should-run-performance }}
    steps:
      - name: Checkout (minimal)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Detect Changed Files
        id: changes
        run: |
          echo "Detecting changed files for smart CI optimization..."
          
          # For PRs, compare against the base branch
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head.sha }})
          else
            # For pushes, compare against previous commit
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check if changes are PatchManager-only
          PATCHMANAGER_ONLY="true"
          CORE_CHANGES="false"
          
          while IFS= read -r file; do
            echo "Checking: $file"
            case "$file" in
              # PatchManager changes (allowed for minimal testing)
              aither-core/modules/PatchManager/*) 
                echo "  -> PatchManager change detected" ;;
              docs/PATCHMANAGER*) 
                echo "  -> PatchManager documentation change" ;;
              *.md) 
                echo "  -> Documentation change" ;;
              # Core system changes (require full testing)
              aither-core/modules/LabRunner/*|aither-core/modules/DevEnvironment/*|aither-core/modules/TestingFramework/*|aither-core/core-runner.ps1|aither-core/shared/*|tests/*)
                echo "  -> Core system change detected"
                CORE_CHANGES="true"
                PATCHMANAGER_ONLY="false" ;;
              # CI/Workflow changes (require full testing)
              .github/workflows/*)
                echo "  -> CI/Workflow change detected"
                CORE_CHANGES="true"
                PATCHMANAGER_ONLY="false" ;;
              *)
                echo "  -> Other change detected"
                PATCHMANAGER_ONLY="false" ;;
            esac
          done <<< "$CHANGED_FILES"
          
          echo "patchmanager-only=$PATCHMANAGER_ONLY" >> $GITHUB_OUTPUT
          echo "core-changes=$CORE_CHANGES" >> $GITHUB_OUTPUT
          echo "changed-files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Configure Pipeline
        id: config
        run: |
          # Check if this is a PatchManager-only change
          PATCHMANAGER_ONLY="${{ steps.changes.outputs.patchmanager-only }}"
          
          # Determine test level
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            LEVEL="${{ github.event.inputs.test_level }}"
          elif [ "$PATCHMANAGER_ONLY" = "true" ]; then
            # PatchManager-only changes use minimal testing
            LEVEL="PatchManager"
            echo "üéØ PatchManager-only changes detected - using minimal test suite"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            LEVEL="Standard"
          else
            LEVEL="Quick"
          fi
          echo "test-level=$LEVEL" >> $GITHUB_OUTPUT

          # Configure matrices and settings based on level
          case $LEVEL in
            "PatchManager")
              # Minimal testing for PatchManager-only changes
              echo 'matrix={"os":["ubuntu-latest"],"include":[{"os":"ubuntu-latest","shell":"pwsh","runner":"ubuntu-latest"}]}' >> $GITHUB_OUTPUT
              echo "should-run-security=true" >> $GITHUB_OUTPUT
              echo "should-run-performance=false" >> $GITHUB_OUTPUT
              echo "should-run-core-tests=false" >> $GITHUB_OUTPUT
              echo "should-run-patchmanager-tests=true" >> $GITHUB_OUTPUT
              ;;
            "Quick")
              echo 'matrix={"os":["ubuntu-latest","windows-latest"],"include":[{"os":"ubuntu-latest","shell":"pwsh","runner":"ubuntu-latest"},{"os":"windows-latest","shell":"pwsh","runner":"windows-latest"}]}' >> $GITHUB_OUTPUT
              echo "should-run-security=false" >> $GITHUB_OUTPUT
              echo "should-run-performance=false" >> $GITHUB_OUTPUT
              echo "should-run-core-tests=true" >> $GITHUB_OUTPUT
              echo "should-run-patchmanager-tests=true" >> $GITHUB_OUTPUT
              ;;
            "Standard")
              echo 'matrix={"os":["ubuntu-latest","windows-latest","macos-latest"],"include":[{"os":"ubuntu-latest","shell":"pwsh","runner":"ubuntu-latest"},{"os":"windows-latest","shell":"pwsh","runner":"windows-latest"},{"os":"macos-latest","shell":"pwsh","runner":"macos-latest"}]}' >> $GITHUB_OUTPUT
              echo "should-run-security=true" >> $GITHUB_OUTPUT
              echo "should-run-performance=false" >> $GITHUB_OUTPUT
              echo "should-run-core-tests=true" >> $GITHUB_OUTPUT
              echo "should-run-patchmanager-tests=true" >> $GITHUB_OUTPUT
              ;;
            "Complete")
              echo 'matrix={"os":["ubuntu-latest","windows-latest","macos-latest","ubuntu-20.04"],"include":[{"os":"ubuntu-latest","shell":"pwsh","runner":"ubuntu-latest"},{"os":"windows-latest","shell":"pwsh","runner":"windows-latest"},{"os":"macos-latest","shell":"pwsh","runner":"macos-latest"},{"os":"ubuntu-20.04","shell":"pwsh","runner":"ubuntu-20.04"}]}' >> $GITHUB_OUTPUT
              echo "should-run-security=true" >> $GITHUB_OUTPUT
              echo "should-run-performance=true" >> $GITHUB_OUTPUT
              echo "should-run-core-tests=true" >> $GITHUB_OUTPUT
              echo "should-run-patchmanager-tests=true" >> $GITHUB_OUTPUT
              ;;
          esac

          # Generate cache key
          echo "cache-key=pwsh-modules-${{ hashFiles('**/RequiredModules.psd1', '**/modules/**/*.psd1') }}-${{ env.CACHE_VERSION }}" >> $GITHUB_OUTPUT

  # Parallel job 1: Lightning-fast linting
  lint:
    name: üîç Lint (${{ matrix.os }})
    runs-on: ${{ matrix.runner }}
    needs: setup
    timeout-minutes: 8
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache PowerShell Modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.local/share/powershell/Modules
            ~/Documents/PowerShell/Modules
            C:\Users\runneradmin\Documents\PowerShell\Modules
          key: ${{ needs.setup.outputs.cache-key }}
          restore-keys: |
            pwsh-modules-${{ runner.os }}-${{ env.CACHE_VERSION }}

      - name: Setup PowerShell (Cached)
        shell: pwsh
        run: |
          # Fast module installation with caching
          $modules = @('PSScriptAnalyzer')
          foreach ($module in $modules) {
            if (-not (Get-Module -ListAvailable $module)) {
              Install-Module -Name $module -Force -Scope CurrentUser -SkipPublisherCheck
            }
          }

      - name: Lightning Lint Analysis
        shell: pwsh
        run: |
          Write-Host "üîç Running optimized PowerShell analysis..." -ForegroundColor Cyan

          # Use comprehensive analysis if available, otherwise optimized fallback
          if (Test-Path './comprehensive-lint-analysis.ps1') {
            pwsh -File './comprehensive-lint-analysis.ps1' -Severity 'Error' -FastMode -Parallel
          } else {
            # Ultra-fast parallel analysis
            $scriptFiles = Get-ChildItem -Path . -Filter '*.ps1' -Recurse | Where-Object {
              $_.FullName -notmatch 'tests[/\\].*\.Tests\.ps1$' -and
              $_.FullName -notmatch '(temp|\.temp|test-.*\.ps1)' -and
              (Get-Content $_.FullName -Raw -ErrorAction SilentlyContinue)
            }

            $jobs = $scriptFiles | ForEach-Object -Parallel {
              $file = $_
              try {
                $analysis = Invoke-ScriptAnalyzer -Path $file.FullName -Severity Error -ErrorAction SilentlyContinue
                return @{
                  File = $file.Name
                  Errors = $analysis
                  Success = $true
                }
              } catch {
                return @{
                  File = $file.Name
                  Error = $_.Exception.Message
                  Success = $false
                }
              }
            } -ThrottleLimit 4

            $errorCount = ($jobs | Where-Object { $_.Errors -or -not $_.Success }).Count
            if ($errorCount -gt 0) {
              Write-Error "Found $errorCount files with errors"
              exit 1
            }
            Write-Host "‚úÖ All $($scriptFiles.Count) files passed lint analysis" -ForegroundColor Green
          }

  # Parallel job 2: Core testing
  test:
    name: üß™ Test (${{ matrix.os }})
    runs-on: ${{ matrix.runner }}
    needs: setup
    timeout-minutes: 15
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache PowerShell Modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.local/share/powershell/Modules
            ~/Documents/PowerShell/Modules
            C:\Users\runneradmin\Documents\PowerShell\Modules
          key: ${{ needs.setup.outputs.cache-key }}
          restore-keys: |
            pwsh-modules-${{ runner.os }}-${{ env.CACHE_VERSION }}

      - name: Setup Test Environment (Cached)
        shell: pwsh
        run: |
          # Fast cached setup
          $modules = @('Pester', 'PSScriptAnalyzer')
          foreach ($module in $modules) {
            if (-not (Get-Module -ListAvailable $module)) {
              Install-Module -Name $module -Force -Scope CurrentUser -SkipPublisherCheck
            }
          }

      - name: Run Optimized Tests
        shell: pwsh
        run: |
          Write-Host "üß™ Running optimized test suite..." -ForegroundColor Cyan

          $testLevel = "${{ needs.setup.outputs.test-level }}"
          $shouldRunCore = "${{ needs.setup.outputs.should-run-core-tests }}"
          $shouldRunPatchManager = "${{ needs.setup.outputs.should-run-patchmanager-tests }}"

          Write-Host "Test Configuration:" -ForegroundColor Yellow
          Write-Host "  Level: $testLevel" -ForegroundColor White
          Write-Host "  Core Tests: $shouldRunCore" -ForegroundColor White
          Write-Host "  PatchManager Tests: $shouldRunPatchManager" -ForegroundColor White

          # For PatchManager-only changes, run minimal validation
          if ($testLevel -eq "PatchManager") {
            Write-Host "üéØ Running PatchManager-only validation..." -ForegroundColor Cyan
            
            # Test PatchManager module specifically
            try {
              Write-Host "Testing PatchManager module import..." -ForegroundColor Yellow
              Import-Module './aither-core/modules/PatchManager/PatchManager.psm1' -Force -ErrorAction Stop
              Write-Host "‚úÖ PatchManager module imported successfully" -ForegroundColor Green
              
              # Test key functions are available
              $functions = @('Invoke-PatchWorkflow', 'New-PatchIssue', 'New-PatchPR', 'Invoke-PatchRollback')
              foreach ($func in $functions) {
                if (Get-Command $func -ErrorAction SilentlyContinue) {
                  Write-Host "‚úÖ Function $func available" -ForegroundColor Green
                } else {
                  Write-Error "‚ùå Function $func not found"
                  exit 1
                }
              }
              
              # Quick syntax validation of PatchManager files
              Write-Host "Validating PatchManager PowerShell syntax..." -ForegroundColor Yellow
              $patchFiles = Get-ChildItem -Path './aither-core/modules/PatchManager' -Filter '*.ps1' -Recurse
              foreach ($file in $patchFiles) {
                $errors = $null
                $null = [System.Management.Automation.PSParser]::Tokenize((Get-Content $file.FullName -Raw), [ref]$errors)
                if ($errors) {
                  Write-Error "Syntax errors in $($file.Name): $($errors.Count) errors"
                  exit 1
                }
              }
              Write-Host "‚úÖ All PatchManager files have valid PowerShell syntax" -ForegroundColor Green
              
            } catch {
              Write-Error "PatchManager validation failed: $($_.Exception.Message)"
              exit 1
            }
            
            Write-Host "‚úÖ PatchManager-only validation completed successfully" -ForegroundColor Green
            return
          }

          # For full test runs, use bulletproof validation
          if (Test-Path './tests/Run-BulletproofValidation.ps1') {
            # First check if the script supports MaxParallelJobs parameter
            $scriptHelp = Get-Help './tests/Run-BulletproofValidation.ps1' -Parameter MaxParallelJobs -ErrorAction SilentlyContinue

            if ($scriptHelp) {
              # Script supports MaxParallelJobs - use full parameter set
              $params = @{
                ValidationLevel = $testLevel
                MaxParallelJobs = 4
                CI = $true
              }

              if ($testLevel -eq "Quick") {
                $params.FailFast = $true
              }

              Write-Host "Using enhanced validation with parallel jobs..." -ForegroundColor Yellow
              pwsh -File './tests/Run-BulletproofValidation.ps1' @params
            } else {
              # Script doesn't support MaxParallelJobs - use basic parameters
              Write-Host "Using basic validation (MaxParallelJobs not supported)..." -ForegroundColor Yellow
              $basicParams = "-ValidationLevel $testLevel -CI"
              if ($testLevel -eq "Quick") {
                $basicParams += " -FailFast"
              }

              Invoke-Expression "pwsh -File './tests/Run-BulletproofValidation.ps1' $basicParams"
            }
          } else {
            # Fallback parallel testing
            Write-Host "Running parallel module validation..." -ForegroundColor Yellow
            $modules = Get-ChildItem -Path './aither-core/modules' -Directory -ErrorAction SilentlyContinue

            $results = $modules | ForEach-Object -Parallel {
              $module = $_
              try {
                Import-Module $module.FullName -Force -ErrorAction Stop
                return @{ Module = $module.Name; Success = $true }
              } catch {
                return @{ Module = $module.Name; Success = $false; Error = $_.Exception.Message }
              }
            } -ThrottleLimit 4

            $failed = $results | Where-Object { -not $_.Success }
            if ($failed) {
              $failed | ForEach-Object { Write-Error "Module $($_.Module): $($_.Error)" }
              exit 1
            }

            Write-Host "‚úÖ All $($modules.Count) modules validated successfully" -ForegroundColor Green
          }

  # Parallel job 3: Security scanning (conditional)
  security:
    name: üõ°Ô∏è Security Scan
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should-run-security == 'true'
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Security Analysis
        shell: pwsh
        run: |
          Write-Host "üõ°Ô∏è Running security analysis..." -ForegroundColor Cyan

          # Check for sensitive patterns - simplified patterns to avoid regex parsing issues
          $sensitivePatterns = @(
            'password\s*[:=]\s*["\']?[\w]{8,}',
            'secret\s*[:=]\s*["\']?[\w]{8,}',
            'api.?key\s*[:=]\s*["\']?[\w]{20,}',
            'token\s*[:=]\s*["\']?[\w]{20,}'
          )

          $violations = @()
          $scriptFiles = Get-ChildItem -Path . -Filter '*.ps1' -Recurse -ErrorAction SilentlyContinue
          
          foreach ($file in $scriptFiles) {
            try {
              $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
              if ($content) {
                foreach ($pattern in $sensitivePatterns) {
                  if ($content -match $pattern) {
                    $match = $matches[0] -replace '[\r\n]', ' '
                    if ($match.Length -gt 50) { $match = $match.Substring(0, 50) + "..." }
                    $violations += "Potential security issue in $($file.Name): $match"
                  }
                }
              }
            } catch {
              Write-Host "Warning: Could not scan file $($file.FullName): $($_.Exception.Message)" -ForegroundColor Yellow
            }
          }

          if ($violations.Count -gt 0) {
            $violations | ForEach-Object { Write-Warning $_ }
            Write-Error "Security violations found: $($violations.Count) issues detected"
            exit 1
          }

          Write-Host "‚úÖ No security violations detected" -ForegroundColor Green

  # Parallel job 4: Performance benchmarks (conditional)
  performance:
    name: ‚ö° Performance
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should-run-performance == 'true'
    timeout-minutes: 12
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Performance Benchmarks
        shell: pwsh
        run: |
          Write-Host "‚ö° Running performance benchmarks..." -ForegroundColor Cyan

          # Benchmark key operations
          $benchmarks = @(
            @{
              Name = "Module Loading"
              Script = {
                $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
                Get-ChildItem './aither-core/modules' -Directory | ForEach-Object {
                  Import-Module $_.FullName -Force -ErrorAction SilentlyContinue
                }
                $stopwatch.Stop()
                return $stopwatch.ElapsedMilliseconds
              }
            },
            @{
              Name = "Core Runner Initialization"
              Script = {
                $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
                if (Test-Path './aither-core/aither-core.ps1') {
                  # Simulate initialization without full execution
                  $content = Get-Content './aither-core/aither-core.ps1' -Raw
                }
                $stopwatch.Stop()
                return $stopwatch.ElapsedMilliseconds
              }
            }
          )

          foreach ($benchmark in $benchmarks) {
            $time = & $benchmark.Script
            Write-Host "$($benchmark.Name): ${time}ms" -ForegroundColor $(if ($time -lt 5000) { 'Green' } elseif ($time -lt 10000) { 'Yellow' } else { 'Red' })

            # Fail if performance is too slow
            if ($time -gt 15000) {
              Write-Error "$($benchmark.Name) took ${time}ms (>15s threshold)"
              exit 1
            }
          }

  # Parallel job 5: Build validation
  build:
    name: üì¶ Build
    runs-on: ${{ matrix.os }}
    needs: setup
    timeout-minutes: 10
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fast Build Validation
        shell: pwsh
        run: |
          Write-Host "üì¶ Validating build process..." -ForegroundColor Cyan

          # Quick build validation
          if (Test-Path './build/Quick-Build.ps1') {
            pwsh -File './build/Quick-Build.ps1' -Validate
          } else {
            # Basic structure validation
            $required = @(
              'aither-core/aither-core.ps1',
              'aither-core/modules',
              'configs'
            )

            foreach ($path in $required) {
              if (-not (Test-Path $path)) {
                Write-Error "Missing required component: $path"
                exit 1
              }
            }

            Write-Host "‚úÖ Build structure validated" -ForegroundColor Green
          }

  # Consolidation and status job
  status:
    name: üìä Pipeline Status
    runs-on: ubuntu-latest
    needs: [setup, lint, test, build, security, performance]
    if: always()
    timeout-minutes: 3
    steps:
      - name: Pipeline Summary
        run: |
          echo "üöÄ Parallel CI/CD Pipeline Results:"
          echo "Test Level: ${{ needs.setup.outputs.test-level }}"
          echo "Lint Status: ${{ needs.lint.result }}"
          echo "Test Status: ${{ needs.test.result }}"
          echo "Build Status: ${{ needs.build.result }}"
          echo "Security Status: ${{ needs.security.result }}"
          echo "Performance Status: ${{ needs.performance.result }}"

          # Check for failures
          if [[ "${{ needs.lint.result }}" == "failure" || "${{ needs.test.result }}" == "failure" || "${{ needs.build.result }}" == "failure" ]]; then
            echo "‚ùå Pipeline failed"
            exit 1
          else
            echo "‚úÖ Pipeline succeeded"
          fi

  # AutoMerge job (if enabled via workflow dispatch)
  automerge:
    name: ü§ñ AutoMerge
    runs-on: ubuntu-latest
    needs: [setup, lint, test, build, security, performance]
    if: |
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.enable_automerge == 'true' &&
      github.event_name == 'pull_request' &&
      needs.lint.result == 'success' &&
      needs.test.result == 'success' &&
      needs.build.result == 'success'
    timeout-minutes: 5
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Enable AutoMerge
        shell: pwsh
        run: |
          Write-Host "ü§ñ Enabling AutoMerge for PR..." -ForegroundColor Cyan

          # Import PatchManager for AutoMerge functionality
          if (Test-Path './aither-core/modules/PatchManager/PatchManager.psm1') {
            Import-Module './aither-core/modules/PatchManager/PatchManager.psm1' -Force

            $prNumber = $env:GITHUB_REF -replace 'refs/pull/(\d+)/merge', '$1'

            if ($prNumber -match '^\d+$') {
              Enable-AutoMerge -PRNumber $prNumber -MergeMethod 'squash' -RequiredChecks @('parallel-ci') -DelayMinutes 2
              Write-Host "‚úÖ AutoMerge enabled for PR #$prNumber" -ForegroundColor Green
            } else {
              Write-Warning "Could not determine PR number from ref: $env:GITHUB_REF"
            }
          }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
