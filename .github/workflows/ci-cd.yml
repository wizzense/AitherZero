name: Comprehensive CI/CD Pipeline

on:
  push:
    branches: [ develop ]  # Only trigger on develop, not main to avoid conflicts
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - 'LICENSE'
  pull_request:
    branches: [ main, develop ]
    types: [ opened, synchronize, reopened ]  # Exclude 'closed' to prevent conflicts with build-release
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - 'LICENSE'
  workflow_dispatch:
    inputs:
      test_level:
        description: 'Test Level (Quick/Standard/Complete)'
        required: false
        default: 'Standard'
        type: choice
        options:
          - Quick
          - Standard
          - Complete

# Prevent duplicate runs and conflicts with build-release workflow
concurrency:
  group: ci-cd-${{ github.ref }}-${{ github.event_name }}
  cancel-in-progress: true

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1
  CI: true

permissions:
  contents: read
  issues: write
  pull-requests: write
  checks: write

jobs:
  # Dynamic test matrix based on event type
  setup:
    runs-on: ubuntu-latest
    outputs:
      test-level: ${{ steps.determine-level.outputs.level }}
      matrix: ${{ steps.determine-level.outputs.matrix }}
    steps:
      - name: Determine test level and matrix
        id: determine-level
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            LEVEL="${{ github.event.inputs.test_level }}"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            LEVEL="Standard"
          else
            LEVEL="Quick"
          fi

          echo "level=$LEVEL" >> $GITHUB_OUTPUT

          case $LEVEL in
            "Quick")
              echo 'matrix={"os":["ubuntu-latest","windows-latest"],"include":[{"os":"ubuntu-latest","shell":"pwsh"},{"os":"windows-latest","shell":"pwsh"}]}' >> $GITHUB_OUTPUT
              ;;
            "Standard")
              echo 'matrix={"os":["ubuntu-latest","windows-latest","macos-latest"],"include":[{"os":"ubuntu-latest","shell":"pwsh"},{"os":"windows-latest","shell":"pwsh"},{"os":"macos-latest","shell":"pwsh"}]}' >> $GITHUB_OUTPUT
              ;;
            "Complete")
              echo 'matrix={"os":["ubuntu-latest","windows-latest","macos-latest","ubuntu-20.04","windows-2019"],"include":[{"os":"ubuntu-latest","shell":"pwsh"},{"os":"windows-latest","shell":"pwsh"},{"os":"macos-latest","shell":"pwsh"},{"os":"ubuntu-20.04","shell":"pwsh"},{"os":"windows-2019","shell":"pwsh"}]}' >> $GITHUB_OUTPUT
              ;;
          esac

  # PowerShell linting and syntax validation
  lint:
    name: Lint & Syntax Check (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: setup
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
      fail-fast: false
    defaults:
      run:
        shell: ${{ matrix.shell }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PowerShell 7+
        uses: microsoft/setup-powershell@v1
        with:
          powershell-version: '7.x'

      - name: Verify PowerShell Setup
        shell: pwsh
        run: |
          Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)" -ForegroundColor Green
          Write-Host "Platform: $($PSVersionTable.Platform)" -ForegroundColor Green
          Write-Host "Edition: $($PSVersionTable.PSEdition)" -ForegroundColor Green
          
          # Verify parallel processing capability
          if ($PSVersionTable.PSVersion.Major -ge 7) {
            Write-Host "‚úÖ Parallel processing available" -ForegroundColor Green
          } else {
            Write-Host "‚ö†Ô∏è Sequential processing mode" -ForegroundColor Yellow
          }

      - name: Install PSScriptAnalyzer
        shell: pwsh
        run: |
          if (-not (Get-Module -ListAvailable PSScriptAnalyzer)) {
            Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser
          }

      - name: Validate Linting Script
        shell: pwsh
        run: |
          Write-Host "üîç Validating linting script availability..." -ForegroundColor Cyan
          
          if (-not (Test-Path './comprehensive-lint-analysis.ps1')) {
            Write-Error "‚ùå Linting script './comprehensive-lint-analysis.ps1' not found!"
            Write-Host "Available files in root:" -ForegroundColor Yellow
            Get-ChildItem -Path . -Filter "*.ps1" | ForEach-Object { Write-Host "  ‚Ä¢ $($_.Name)" -ForegroundColor Cyan }
            exit 1
          }
          
          Write-Host "‚úÖ Linting script found" -ForegroundColor Green

      - name: Run Comprehensive PowerShell Analysis
        shell: pwsh
        run: |
          Write-Host "üîç Running comprehensive PowerShell analysis..." -ForegroundColor Cyan

          try {
            # Execute comprehensive linting with enhanced error handling
            pwsh -File './comprehensive-lint-analysis.ps1' -Severity 'All' -FailOnErrors -Detailed -VerboseOutput
            Write-Host "‚úÖ Comprehensive analysis completed successfully" -ForegroundColor Green
          } catch {
            Write-Error "‚ùå Comprehensive analysis failed: $($_.Exception.Message)"
            
            # Fallback to basic analysis for debugging
            Write-Host "üîÑ Attempting fallback analysis..." -ForegroundColor Yellow
            
            # Basic fallback analysis (retained for emergency use)
            Write-Warning "Falling back to basic analysis for debugging"
            $results = @()
            $patterns = @('*.ps1', '*.psm1', '*.psd1')
            foreach ($pattern in $patterns) {
              $files = Get-ChildItem -Path . -Filter $pattern -Recurse -ErrorAction SilentlyContinue
              foreach ($file in $files) {
                # Skip test files and temporary files, but NOT configuration files
                if (($file.FullName -match 'tests[/\\].*\.Tests\.ps1$') -or
                    ($file.FullName -match '(temp|\.temp)') -or
                    ($file.FullName -match 'test-.*\.ps1$')) {
                  continue
                }

                Write-Host "Analyzing: $($file.FullName)" -ForegroundColor Cyan
                try {
                  # Check if file has content before analyzing
                $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
                if (-not $content -or $content.Trim() -eq '') {
                  Write-Warning "Skipping empty file: $($file.Name)"
                  continue
                }

                $analysis = Invoke-ScriptAnalyzer -Path $file.FullName -Settings './tests/config/PSScriptAnalyzerSettings.psd1' -Severity Warning,Error
                if ($analysis) {
                  $results += $analysis
                  $analysis | ForEach-Object {
                    Write-Warning "$($_.ScriptName):$($_.Line) - $($_.Message)"
                  }
                }
                } catch {
                  Write-Warning "Could not analyze $($file.FullName): $($_.Exception.Message)"
                }
              }
            }

            $errorCount = ($results | Where-Object Severity -eq 'Error').Count
            $warningCount = ($results | Where-Object Severity -eq 'Warning').Count

            Write-Host "Analysis complete: $errorCount errors, $warningCount warnings" -ForegroundColor Yellow

            if ($errorCount -gt 0) {
              Write-Error "Script analysis found $errorCount errors"
              exit 1
            }
            
            # If fallback succeeds, still exit with error to indicate primary script failure
            Write-Warning "Fallback analysis completed, but primary script failed"
            exit 1
          }

      - name: PowerShell Syntax Check
        shell: pwsh
        run: |
          Write-Host "üîß Running PowerShell syntax validation..." -ForegroundColor Cyan

          $errors = @()
          $patterns = @('*.ps1', '*.psm1')
          $totalFiles = 0
          $validFiles = 0
          $emptyFiles = 0

          foreach ($pattern in $patterns) {
            $files = Get-ChildItem -Path . -Filter $pattern -Recurse -ErrorAction SilentlyContinue
            foreach ($file in $files) {
              # Skip test files and temporary files, but NOT configuration files
              if (($file.FullName -match 'tests[/\\].*\.Tests\.ps1$') -or
                  ($file.FullName -match '(temp|\.temp)') -or
                  ($file.FullName -match 'test-.*\.ps1$')) {
                continue
              }

              $totalFiles++
              Write-Host "Syntax checking: $($file.FullName)" -ForegroundColor Cyan

              try {
                # Check if file has content
                $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
                if (-not $content -or $content.Trim() -eq '') {
                  $emptyFiles++
                  Write-Host "‚ö†Ô∏è  Empty file: $($file.Name)" -ForegroundColor Yellow
                  continue
                }

                $null = [System.Management.Automation.PSParser]::Tokenize($content, [ref]$null)
                $validFiles++
                Write-Host "‚úì Syntax OK: $($file.Name)" -ForegroundColor Green
              } catch {
                $errors += "Syntax error in $($file.FullName): $($_.Exception.Message)"
                Write-Error "‚ùå Syntax error in $($file.FullName): $($_.Exception.Message)"
              }
            }
          }

          Write-Host ""
          Write-Host "üìä Syntax Check Summary:" -ForegroundColor Yellow
          Write-Host "  Total files: $totalFiles" -ForegroundColor White
          Write-Host "  Valid files: $validFiles" -ForegroundColor Green
          Write-Host "  Empty files: $emptyFiles" -ForegroundColor Yellow
          Write-Host "  Error files: $($errors.Count)" -ForegroundColor $(if ($errors.Count -gt 0) { 'Red' } else { 'Green' })

          if ($errors.Count -gt 0) {
            Write-Error "Found $($errors.Count) syntax errors"
            exit 1
          }

  # Comprehensive test suite
  test:
    name: Test Suite (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: [setup, lint]
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
      fail-fast: false
    defaults:
      run:
        shell: ${{ matrix.shell }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PowerShell environment
        shell: pwsh
        run: |
          Write-Host "Setting up PowerShell environment..." -ForegroundColor Cyan
          Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)" -ForegroundColor Green
          Write-Host "Platform: $($PSVersionTable.Platform)" -ForegroundColor Green

      - name: Install test dependencies
        shell: pwsh
        run: |
          $modules = @('Pester')
          foreach ($module in $modules) {
            if (-not (Get-Module -ListAvailable $module)) {
              Write-Host "Installing $module..." -ForegroundColor Yellow
              Install-Module -Name $module -Force -Scope CurrentUser
            }
          }

      - name: Run bulletproof validation
        shell: pwsh
        run: |
          $testLevel = "${{ needs.setup.outputs.test-level }}"
          Write-Host "Running $testLevel level tests..." -ForegroundColor Cyan

          # Map CI test levels to bulletproof validation levels
          $validationLevel = switch ($testLevel) {
            "Quick" { "Quick" }
            "Standard" { "Standard" }
            "Complete" { "Complete" }
            default { "Standard" }
          }

          if (Test-Path './tests/Run-BulletproofValidation.ps1') {
            pwsh -File './tests/Run-BulletproofValidation.ps1' -ValidationLevel $validationLevel -CI -FailFast
          } elseif (Test-Path './Quick-ModuleCheck.ps1') {
            Write-Host "Running Quick Module Check as fallback..." -ForegroundColor Yellow
            pwsh -File './Quick-ModuleCheck.ps1' -MaxParallelJobs 4
          } else {
            Write-Warning "Bulletproof validation script not found, running basic tests"
            if (Test-Path './tests') {
              $testFiles = Get-ChildItem -Path './tests' -Filter '*.Tests.ps1' -Recurse
              if ($testFiles) {
                Invoke-Pester -Path $testFiles.FullName -Output Detailed
              } else {
                Write-Host "No test files found, running basic module validation..." -ForegroundColor Yellow
                # Basic module test as last resort
                if (Test-Path './aither-core/modules') {
                  $modules = Get-ChildItem -Path './aither-core/modules' -Directory | Where-Object { $_.Name -ne 'packages-microsoft-prod.deb' }
                  $successCount = 0
                  foreach ($module in $modules) {
                    try {
                      Import-Module $module.FullName -Force -ErrorAction Stop -WarningAction SilentlyContinue
                      $successCount++
                    } catch {
                      Write-Warning "Module $($module.Name) failed: $($_.Exception.Message)"
                    }
                  }
                  Write-Host "Basic validation: $successCount/$($modules.Count) modules loaded successfully" -ForegroundColor Green
                }
              }
            }
          }

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}
          path: |
            tests/results/
            logs/
          retention-days: 30

  # Build validation
  build:
    name: Build Test (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: [setup, lint]
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
      fail-fast: false
    defaults:
      run:
        shell: ${{ matrix.shell }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PowerShell environment
        shell: pwsh
        run: |
          Write-Host "Setting up build environment..." -ForegroundColor Cyan
          Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)" -ForegroundColor Green

      - name: Test module imports
        shell: pwsh
        run: |
          Write-Host "Testing module imports..." -ForegroundColor Cyan

          if (Test-Path './aither-core/modules') {
            $modules = Get-ChildItem -Path './aither-core/modules' -Directory | Where-Object { $_.Name -ne 'packages-microsoft-prod.deb' }
            $importErrors = @()
            $successCount = 0

            foreach ($module in $modules) {
              try {
                Write-Host "Testing import: $($module.Name)" -ForegroundColor Yellow
                Import-Module $module.FullName -Force -ErrorAction Stop -WarningAction SilentlyContinue
                Write-Host "‚úì Successfully imported: $($module.Name)" -ForegroundColor Green
                $successCount++
              } catch {
                $importErrors += "Failed to import $($module.Name): $($_.Exception.Message)"
                Write-Warning "Failed to import $($module.Name): $($_.Exception.Message)"
              }
            }

            $successRate = [math]::Round(($successCount / $modules.Count) * 100, 1)
            Write-Host "Module import summary: $successCount/$($modules.Count) modules ($successRate%) imported successfully" -ForegroundColor $(if ($successRate -ge 80) { 'Green' } else { 'Yellow' })

            if ($successRate -lt 50) {
              Write-Error "Less than 50% of modules imported successfully - this indicates serious issues"
              exit 1
            }
          } else {
            Write-Host "No modules directory found, skipping module import tests" -ForegroundColor Yellow
          }

      - name: Validate build scripts
        shell: pwsh
        run: |
          Write-Host "Validating build scripts..." -ForegroundColor Cyan

          # Debug: Show current directory and what exists
          Write-Host "Current directory: $(Get-Location)" -ForegroundColor Yellow
          Write-Host "Directory contents:" -ForegroundColor Yellow
          Get-ChildItem | ForEach-Object { Write-Host "  $($_.Name)" -ForegroundColor Cyan }

          $buildScripts = @()

          # Check for build directory scripts
          if (Test-Path './build') {
            $buildDirScripts = Get-ChildItem -Path './build' -Filter '*.ps1' -ErrorAction SilentlyContinue
            if ($buildDirScripts) {
              $buildScripts += $buildDirScripts
              Write-Host "Found $($buildDirScripts.Count) scripts in ./build directory" -ForegroundColor Green
            }
          } else {
            Write-Host "Build directory ./build not found" -ForegroundColor Red
          }

          # Check for main aither-core script (correct path)
          if (Test-Path './aither-core/aither-core.ps1') {
            $buildScripts += Get-Item './aither-core/aither-core.ps1'
            Write-Host "Found aither-core.ps1" -ForegroundColor Green
          } else {
            Write-Host "Main script ./aither-core/aither-core.ps1 not found" -ForegroundColor Red
          }

          if ($buildScripts.Count -eq 0) {
            Write-Error "No build scripts found - this should not happen!"
            exit 1
          }

          Write-Host "Validating $($buildScripts.Count) build scripts..." -ForegroundColor Cyan
          foreach ($script in $buildScripts) {
            Write-Host "Validating: $($script.Name)" -ForegroundColor Yellow
            try {
              # Test with -WhatIf to avoid actual execution
              if ($script.Name -eq 'aither-core.ps1') {
                pwsh -File $script.FullName -NonInteractive -WhatIf -ErrorAction Stop
              } else {
                # For other scripts, just test syntax
                $null = [System.Management.Automation.PSParser]::Tokenize((Get-Content $script.FullName -Raw), [ref]$null)
              }
              Write-Host "‚úì Validated: $($script.Name)" -ForegroundColor Green
            } catch {
              Write-Error "Build script validation failed for $($script.Name): $($_.Exception.Message)"
              exit 1
            }
          }

  # Security scanning
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check if code scanning is enabled
        id: check-code-scanning
        shell: pwsh
        run: |
          Write-Host "Checking if code scanning is enabled..." -ForegroundColor Cyan
          $codeScanningEnabled = $false
          try {
            $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/code-scanning/alerts" -Headers @{ Authorization = "token ${{ secrets.GITHUB_TOKEN }}" }
            if ($response.Count -gt 0) {
              $codeScanningEnabled = $true
            }
            Write-Host "Code scanning enabled: $codeScanningEnabled" -ForegroundColor Green
          } catch {
            Write-Warning "Code scanning API not accessible: $($_.Exception.Message)"
            Write-Host "Code scanning enabled: false" -ForegroundColor Yellow
          }

          echo "enabled=$codeScanningEnabled" >> $env:GITHUB_OUTPUT

          if (-not $codeScanningEnabled) {
            Write-Warning "Code scanning is not enabled for this repository. Security scan will be skipped."
          }

      - name: Run Trivy vulnerability scanner
        if: steps.check-code-scanning.outputs.enabled == 'true'
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload Trivy scan results
        if: steps.check-code-scanning.outputs.enabled == 'true' && always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

      - name: PowerShell security check
        shell: pwsh
        run: |
          Write-Host "Running PowerShell security checks..." -ForegroundColor Cyan

          # Check for common security issues (excluding test files and legitimate uses)
          $securityIssues = @()
          $patterns = @('*.ps1', '*.psm1')

          foreach ($pattern in $patterns) {
            $files = Get-ChildItem -Path . -Filter $pattern -Recurse -ErrorAction SilentlyContinue
            foreach ($file in $files) {
              # Skip test files, bootstrap scripts, and security test files
              if ($file.FullName -match '(test|Test|Tests|bootstrap|Bootstrap|quick-download)' -or
                  $file.FullName -match 'tests[/\\]' -or
                  $file.FullName -match 'SecurityValidation') {
                continue
              }

              $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
              if (-not $content) { continue }

              # Check for potentially dangerous patterns (excluding legitimate uses)
              # Flag Invoke-Expression only in non-installer scripts
              if ($content -match 'Invoke-Expression|iex\s' -and
                  $file.FullName -notmatch '(Install|Download|Provider|Installer)') {
                $securityIssues += "Potential code injection risk in $($file.FullName): Invoke-Expression usage"
              }

              # Flag ConvertTo-SecureString only when used unsafely (not in credential modules or tests)
              if ($content -match 'ConvertTo-SecureString.*-AsPlainText.*-Force' -and
                  $file.FullName -notmatch '(SecureCredentials|Test|credential)') {
                $securityIssues += "Insecure credential handling in $($file.FullName): Plain text to SecureString conversion"
              }

              # Just log web requests for review (informational only)
              if ($content -match 'System\.Net\.WebClient|Invoke-WebRequest') {
                Write-Host "Info: Web request found in $($file.Name) - review for security" -ForegroundColor Yellow
              }
            }
          }

          if ($securityIssues.Count -gt 0) {
            foreach ($issue in $securityIssues) {
              Write-Warning $issue
            }
            Write-Warning "Found $($securityIssues.Count) potential security issues (review recommended but not blocking)"
            # Don't exit with error - make this informational rather than blocking
          } else {
            Write-Host "No critical security issues detected" -ForegroundColor Green
          }

  # Performance testing (on Standard/Complete levels)
  performance:
    name: Performance Test
    runs-on: ubuntu-latest
    needs: [setup, test]
    if: contains(fromJson('["Standard", "Complete"]'), needs.setup.outputs.test-level)
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run performance tests
        shell: pwsh
        run: |
          Write-Host "Running performance tests..." -ForegroundColor Cyan

          if (Test-Path './tests/performance') {
            $perfTests = Get-ChildItem -Path './tests/performance' -Filter '*.Tests.ps1' -ErrorAction SilentlyContinue
            if ($perfTests) {
              foreach ($test in $perfTests) {
                Write-Host "Running: $($test.Name)" -ForegroundColor Yellow
                pwsh -File $test.FullName
              }
            } else {
              Write-Host "No performance tests found" -ForegroundColor Yellow
            }
          } else {
            Write-Host "No performance test directory found" -ForegroundColor Yellow
          }

  # CI summary and PR automation
  summary:
    name: CI/CD Summary
    runs-on: ubuntu-latest
    needs: [setup, lint, test, build, security]
    if: always()
    permissions:
      contents: read
      issues: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate CI summary
        shell: pwsh
        run: |
          $summary = @"
          # üöÄ CI/CD Pipeline Summary

          **Test Level**: ${{ needs.setup.outputs.test-level }}
          **Trigger**: ${{ github.event_name }}
          **Branch**: ${{ github.ref_name }}
          **Commit**: ${{ github.sha }}

          ## Job Results
          - **Lint**: ${{ needs.lint.result }}
          - **Test**: ${{ needs.test.result }}
          - **Build**: ${{ needs.build.result }}
          - **Security**: ${{ needs.security.result }}

          ## Platform Coverage
          Testing completed on multiple platforms for cross-platform compatibility.

          ## Next Steps
          "@

          if ("${{ needs.test.result }}" -eq "success" -and "${{ needs.build.result }}" -eq "success") {
            $summary += "`n‚úÖ **Ready for merge** - All checks passed"
          } else {
            $summary += "`n‚ùå **Not ready** - Some checks failed"
          }

          Write-Host $summary

          # Write to GitHub step summary
          $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8

      - name: Comment on PR (if applicable)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const summary = `## ü§ñ CI/CD Automation Results

            **Test Level**: ${{ needs.setup.outputs.test-level }}
            **Overall Status**: ${{ job.status }}

            ### Job Results
            - Lint & Syntax: ${{ needs.lint.result }}
            - Test Suite: ${{ needs.test.result }}
            - Build Validation: ${{ needs.build.result }}
            - Security Scan: ${{ needs.security.result }}

            ### Platform Coverage
            ‚úÖ Multi-platform testing completed

            `;

            // Determine status message based on results
            const allPassed = '${{ needs.test.result }}' === 'success' && '${{ needs.build.result }}' === 'success';
            const statusMessage = allPassed
              ? 'üéâ **All checks passed!** Ready for review and merge.'
              : '‚ö†Ô∏è **Some checks failed.** Please review the logs and fix any issues.';

            const finalSummary = summary + statusMessage + `

            ---
            *This comment was automatically generated by the CI/CD pipeline.*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: finalSummary
            });
