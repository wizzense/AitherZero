---
name: Intelligent Report Analyzer & Issue Creator

# Automatically analyze comprehensive reports and create targeted issues/PRs for AI agents
on:
  # DISABLED: workflow_run trigger was creating duplicate issues
  # workflow_run:
  #   workflows: ["Intelligent CI Orchestrator", "CI Pipeline"]
  #   types: [completed]
  # DISABLED: Daily schedule was creating unnecessary issues
  # schedule:
  #   # Daily analysis of accumulated issues and opportunities
  #   - cron: '0 6 * * *'  # 6 AM UTC daily
  workflow_dispatch:
    inputs:
      analysis_mode:
        description: 'Analysis mode'
        type: choice
        options: ['standard', 'comprehensive', 'optimization-focus']
        default: 'standard'
      create_prs:
        description: 'Create PRs for auto-fixable issues'
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  checks: write

jobs:
  analyze-reports:
    name: ü§ñ Intelligent Report Analysis
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'schedule' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       (github.event.workflow_run.conclusion == 'success' ||
        github.event.workflow_run.conclusion == 'failure' ||
        github.event.workflow_run.conclusion == 'action_required'))

    outputs:
      critical-issues-found: ${{ steps.analysis.outputs.critical-issues-found }}
      optimization-opportunities: ${{ steps.analysis.outputs.optimization-opportunities }}
      security-concerns: ${{ steps.analysis.outputs.security-concerns }}

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üîç Debug Trigger Context
        shell: pwsh
        run: |
          Write-Host "üîç Workflow Trigger Debug Info:" -ForegroundColor Cyan
          Write-Host "  Event Name: ${{ github.event_name }}"
          Write-Host "  Workflow Run ID: ${{ github.event.workflow_run.id }}"
          Write-Host "  Workflow Run Conclusion: ${{ github.event.workflow_run.conclusion }}"
          Write-Host "  Workflow Run Status: ${{ github.event.workflow_run.status }}"
          Write-Host "  Actor: ${{ github.actor }}"
          Write-Host "  Repository: ${{ github.repository }}"
          Write-Host ""

      - name: üìä Download Latest Reports
        if: github.event.workflow_run
        uses: dawidd6/action-download-artifact@v6
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          run_id: ${{ github.event.workflow_run.id }}
          name: core-analysis-results
          path: ./latest-reports
        continue-on-error: true

      - name: ü§ñ Intelligent Analysis Engine
        id: analysis
        shell: pwsh
        run: |
          Write-Host "ü§ñ Starting intelligent report analysis..." -ForegroundColor Cyan
          Write-Host "  Analysis Mode: ${{ github.event.inputs.analysis_mode || 'standard' }}"
          Write-Host "  Current Directory: $(Get-Location)"
          Write-Host "  Available Files: $(Get-ChildItem -Recurse | Select-Object -First 10 | ForEach-Object { $_.Name })"

          # Initialize analysis results
          $analysisResults = @{
            Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
            CriticalIssues = @()
            OptimizationOpportunities = @()
            SecurityConcerns = @()
            TechnicalDebt = @()
            PerformanceIssues = @()
            Summary = @{}
          }

          # Analyze PSScriptAnalyzer results
          Write-Host "üìã Analyzing PSScriptAnalyzer results..." -ForegroundColor Yellow

          $psAnalysisFiles = Get-ChildItem -Path "tests/analysis" -Filter "*Summary*.json" -ErrorAction SilentlyContinue |
                            Sort-Object LastWriteTime -Descending | Select-Object -First 1

          if ($psAnalysisFiles) {
            $psAnalysis = Get-Content $psAnalysisFiles.FullName | ConvertFrom-Json

            # Categorize PSScriptAnalyzer findings
            $errorCount = 0
            $warningCount = 0
            $infoCount = 0

            if ($psAnalysis.Summary.BySeverity.Error) { $errorCount = $psAnalysis.Summary.BySeverity.Error }
            if ($psAnalysis.Summary.BySeverity.Warning) { $warningCount = $psAnalysis.Summary.BySeverity.Warning }
            if ($psAnalysis.Summary.BySeverity.Information) { $infoCount = $psAnalysis.Summary.BySeverity.Information }

            # Critical issues requiring immediate attention
            if ($errorCount -gt 0) {
              $analysisResults.CriticalIssues += @{
                Type = "CodeQuality"
                Severity = "Critical"
                Title = "PSScriptAnalyzer Critical Errors"
                Description = "$errorCount critical errors found in code analysis"
                Count = $errorCount
                AutoFixable = $true
                Priority = "P0"
              }
            }

            # Optimization opportunities
            if ($warningCount -gt 50) {
              $analysisResults.OptimizationOpportunities += @{
                Type = "CodeCleanup"
                Severity = "Medium"
                Title = "Code Quality Improvements"
                Description = "$warningCount warnings identified for code cleanup"
                Count = $warningCount
                AutoFixable = $true
                Priority = "P2"
              }
            }

            # Analyze by rule for targeted fixes
            if ($psAnalysis.Summary.ByRule) {
              foreach ($rule in $psAnalysis.Summary.ByRule.PSObject.Properties) {
                if ($rule.Value -gt 10) {
                  $analysisResults.TechnicalDebt += @{
                    Type = "RuleViolation"
                    Rule = $rule.Name
                    Count = $rule.Value
                    AutoFixable = ($rule.Name -match "TrailingWhitespace|BOMForUnicode|OutputType")
                    Priority = if ($rule.Value -gt 50) { "P1" } else { "P3" }
                  }
                }
              }
            }
          }

          # Analyze Project Reports
          Write-Host "üìã Analyzing Project Reports..." -ForegroundColor Yellow

          $projectReports = Get-ChildItem -Path "tests/reports" -Filter "*ProjectReport*.json" -ErrorAction SilentlyContinue |
                           Sort-Object LastWriteTime -Descending | Select-Object -First 1

          if ($projectReports) {
            $projectReport = Get-Content $projectReports.FullName | ConvertFrom-Json

            # Analyze test coverage and health
            if ($projectReport.TestSummary) {
              $testCoverage = 0
              if ($projectReport.TestSummary.CodeCoverage) {
                $testCoverage = [int]($projectReport.TestSummary.CodeCoverage -replace '%', '')
              }

              if ($testCoverage -lt 70) {
                $analysisResults.CriticalIssues += @{
                  Type = "TestCoverage"
                  Severity = "High"
                  Title = "Low Test Coverage"
                  Description = "Test coverage is $testCoverage% (target: 70%)"
                  AutoFixable = $false
                  Priority = "P1"
                  RequiresHumanInput = $true
                }
              }
            }

            # Analyze documentation coverage
            if ($projectReport.HelpCoverage -and $projectReport.HelpCoverage -lt 0.5) {
              $analysisResults.OptimizationOpportunities += @{
                Type = "Documentation"
                Severity = "Medium"
                Title = "Documentation Gaps"
                Description = "Help coverage is $($projectReport.HelpCoverage * 100)% (target: 50%)"
                AutoFixable = $false
                Priority = "P2"
                RequiresHumanInput = $true
              }
            }
          }

          # Add baseline analysis if no issues found or in comprehensive mode
          $comprehensiveMode = "${{ github.event.inputs.analysis_mode }}" -eq "comprehensive"
          if ($analysisResults.CriticalIssues.Count -eq 0 -and $analysisResults.OptimizationOpportunities.Count -eq 0) {
            Write-Host "üìã No critical issues found in reports. Running baseline analysis..." -ForegroundColor Yellow

            # Always check for potential workflow improvements
            $analysisResults.OptimizationOpportunities += @{
              Type = "WorkflowOptimization"
              Severity = "Low"
              Title = "Workflow Performance Review"
              Description = "Regular review of GitHub Actions workflow performance and efficiency"
              AutoFixable = $false
              Priority = "P3"
              RequiresHumanInput = $true
            }

            # Check if this is part of comprehensive analysis
            if ($comprehensiveMode) {
              $analysisResults.OptimizationOpportunities += @{
                Type = "ComprehensiveReview"
                Severity = "Medium"
                Title = "Comprehensive System Analysis"
                Description = "Scheduled comprehensive review of system architecture and performance"
                AutoFixable = $false
                Priority = "P2"
                RequiresHumanInput = $true
              }
            }
          }

          # Generate summary
          $analysisResults.Summary = @{
            TotalCriticalIssues = $analysisResults.CriticalIssues.Count
            TotalOptimizationOpportunities = $analysisResults.OptimizationOpportunities.Count
            TotalSecurityConcerns = $analysisResults.SecurityConcerns.Count
            AutoFixableCount = ($analysisResults.CriticalIssues + $analysisResults.OptimizationOpportunities |
                               Where-Object { $_.AutoFixable }).Count
          }

          # Save analysis results
          $analysisResults | ConvertTo-Json -Depth 5 | Out-File "intelligent-analysis.json"

          # Set outputs for downstream jobs
          "critical-issues-found=$($analysisResults.CriticalIssues.Count -gt 0)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "optimization-opportunities=$($analysisResults.OptimizationOpportunities.Count)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "security-concerns=$($analysisResults.SecurityConcerns.Count)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          Write-Host "‚úÖ Analysis complete!" -ForegroundColor Green
          Write-Host "  Critical Issues: $($analysisResults.CriticalIssues.Count)"
          Write-Host "  Optimization Opportunities: $($analysisResults.OptimizationOpportunities.Count)"
          Write-Host "  Auto-fixable Items: $($analysisResults.Summary.AutoFixableCount)"

      - name: üìä Upload Analysis Results
        uses: actions/upload-artifact@v4
        with:
          name: intelligent-analysis-results
          path: intelligent-analysis.json
          retention-days: 30

  create-targeted-issues:
    name: üìù Create Targeted Issues
    runs-on: ubuntu-latest
    needs: analyze-reports
    if: needs.analyze-reports.outputs.critical-issues-found == 'true' || needs.analyze-reports.outputs.optimization-opportunities > '0'

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üìä Download Analysis Results
        uses: actions/download-artifact@v4
        with:
          name: intelligent-analysis-results
          path: ./analysis-results

      - name: üìù Create Intelligent Issues
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Load analysis results
            const analysisPath = './analysis-results/intelligent-analysis.json';
            if (!fs.existsSync(analysisPath)) {
              console.log('No analysis results found');
              return;
            }

            const analysis = JSON.parse(fs.readFileSync(analysisPath, 'utf8'));
            console.log('üìä Processing analysis results...');

            // Create issues for critical problems
            for (const issue of analysis.CriticalIssues) {
              const issueTitle = `üö® ${issue.Title} (${issue.Priority})`;
              const issueBody = `## üö® Critical Issue Detected

              **Type:** ${issue.Type}
              **Severity:** ${issue.Severity}
              **Priority:** ${issue.Priority}

              ### üìã Description
              ${issue.Description}

              ### üîß Details
              ${issue.Count ? `- **Count:** ${issue.Count} occurrences` : ''}
              ${issue.AutoFixable ? '- **Auto-fixable:** ‚úÖ Yes' : '- **Auto-fixable:** ‚ùå No'}
              ${issue.RequiresHumanInput ? '- **Human input required:** Yes' : ''}

              ### ü§ñ AI Agent Instructions

              @copilot Please investigate and ${issue.AutoFixable ? 'automatically fix' : 'provide recommendations for'} this ${issue.Type.toLowerCase()} issue:

              1. **Analyze** the specific occurrences of this issue
              2. **${issue.AutoFixable ? 'Implement fixes' : 'Recommend solutions'}** following best practices
              3. **Test** any changes thoroughly
              4. **Update** this issue with progress and findings
              ${issue.AutoFixable ? '5. **Submit** a PR with the fixes' : ''}

              ### üìä Context
              - **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
              - **Analysis Timestamp:** ${analysis.Timestamp}
              - **Git Ref:** ${context.ref}

              ---
              *This issue was automatically created by the Intelligent Report Analyzer*`;

              const labels = ['automated-issue', issue.Priority.toLowerCase(), issue.Type.toLowerCase()];
              if (issue.AutoFixable) labels.push('auto-fixable');
              if (issue.RequiresHumanInput) labels.push('needs-human-input');

              try {
                const createdIssue = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: issueBody,
                  labels: labels,
                  assignees: ['copilot']
                });
                console.log(`‚úÖ Created critical issue #${createdIssue.data.number}: ${issueTitle}`);
              } catch (error) {
                console.error(`‚ùå Failed to create issue: ${error.message}`);
              }
            }

            // Create optimization opportunity issues (batch similar ones)
            const optimizationBatches = {};
            for (const opp of analysis.OptimizationOpportunities) {
              if (!optimizationBatches[opp.Type]) {
                optimizationBatches[opp.Type] = [];
              }
              optimizationBatches[opp.Type].push(opp);
            }

            for (const [type, opportunities] of Object.entries(optimizationBatches)) {
              const totalCount = opportunities.reduce((sum, opp) => sum + (opp.Count || 1), 0);
              const autoFixable = opportunities.every(opp => opp.AutoFixable);

              const issueTitle = `üéØ ${type} Optimization Opportunities (${totalCount} items)`;
              const issueBody = `## üéØ Code Optimization Opportunities

              **Type:** ${type}
              **Total Items:** ${totalCount}
              **Auto-fixable:** ${autoFixable ? '‚úÖ Yes' : '‚ùå Partial'}

              ### üìã Opportunities Identified
              ${opportunities.map(opp =>
                `- **${opp.Title}:** ${opp.Description} (Priority: ${opp.Priority})`
              ).join('\n')}

              ### ü§ñ AI Agent Instructions

              @copilot Please optimize these ${type.toLowerCase()} opportunities:

              1. **Review** each optimization opportunity listed above
              2. **Prioritize** by impact and effort required
              3. **Implement** improvements in logical batches
              4. **Test** changes to ensure no regressions
              5. **Document** improvements made
              6. **Submit** PR(s) with the optimizations

              ### üìä Context
              - **Analysis Timestamp:** ${analysis.Timestamp}
              - **Auto-fixable Items:** ${opportunities.filter(opp => opp.AutoFixable).length}/${opportunities.length}

              ---
              *This issue was automatically created by the Intelligent Report Analyzer*`;

              const labels = ['automated-issue', 'optimization', type.toLowerCase()];
              if (autoFixable) labels.push('auto-fixable');

              try {
                const createdIssue = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: issueBody,
                  labels: labels,
                  assignees: ['copilot']
                });
                console.log(`‚úÖ Created optimization issue #${createdIssue.data.number}: ${issueTitle}`);
              } catch (error) {
                console.error(`‚ùå Failed to create optimization issue: ${error.message}`);
              }
            }

            console.log('üìù Issue creation complete!');

  auto-create-prs:
    name: ü§ñ Auto-Create PRs for Fixable Issues
    runs-on: ubuntu-latest
    needs: [analyze-reports, create-targeted-issues]
    if: github.event.inputs.create_prs == 'true' && needs.analyze-reports.outputs.critical-issues-found == 'true'

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üìä Download Analysis Results
        uses: actions/download-artifact@v4
        with:
          name: intelligent-analysis-results
          path: ./analysis-results

      - name: ü§ñ Create Auto-Fix PRs
        uses: actions/github-script@v7
        with:
          script: |
            // This would trigger Copilot to automatically create PRs for auto-fixable issues
            // Implementation would depend on specific Copilot integration capabilities

            const fs = require('fs');
            const analysis = JSON.parse(fs.readFileSync('./analysis-results/intelligent-analysis.json', 'utf8'));

            const autoFixableIssues = [...analysis.CriticalIssues, ...analysis.OptimizationOpportunities]
              .filter(issue => issue.AutoFixable);

            console.log(`ü§ñ Found ${autoFixableIssues.length} auto-fixable issues`);

            for (const issue of autoFixableIssues) {
              // Create a comment mentioning @copilot with specific instructions
              const commentBody = `ü§ñ **Auto-Fix Request**

              @copilot Please automatically create a PR to fix this ${issue.Type} issue:

              **Issue:** ${issue.Title}
              **Description:** ${issue.Description}
              **Priority:** ${issue.Priority}

              **Instructions:**
              1. Create a new branch: \`copilot/auto-fix-${issue.Type.toLowerCase()}-${Date.now()}\`
              2. Implement the necessary fixes
              3. Add appropriate tests if needed
              4. Submit PR with detailed description of changes

              This is an automated request from the Intelligent Report Analyzer.`;

              // This would be posted as a repository dispatch or comment to trigger Copilot
              console.log(`üìù Auto-fix request prepared for: ${issue.Title}`);
            }

  cleanup-old-issues:
    name: üßπ Cleanup Old Automated Issues
    runs-on: ubuntu-latest
    needs: create-targeted-issues
    if: always()

    steps:
      - name: üßπ Close Resolved Automated Issues
        uses: actions/github-script@v7
        with:
          script: |
            // Find and close old automated issues that are no longer relevant
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'automated-issue',
              state: 'open',
              per_page: 100
            });

            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

            for (const issue of issues) {
              const issueDate = new Date(issue.created_at);

              // Close issues older than 30 days that haven't been updated
              if (issueDate < thirtyDaysAgo && new Date(issue.updated_at) < thirtyDaysAgo) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed'
                });

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: 'ü§ñ **Auto-closing stale issue**\n\nThis automated issue has been open for 30+ days without updates and is being closed. If the issue persists, it will be automatically recreated in future analysis runs.'
                });

                console.log(`üßπ Closed stale issue #${issue.number}: ${issue.title}`);
              }
            }
