{"comment":"Exported from Tanium Server 7.7.3.8199 at 2025-07-30T21:10:18","version":2,"object_list":{"sensors":[{"content_set":{"name":"Core Content"},"name":"Installed Applications","hash":1511329504,"source_name":"","category":"Applications","description":"List of applications and application versions on the client. \nThe list includes symlinked applications from guest OSes if the client has Parallels installed.\nExample: Mozilla Firefox | 16.0.1","queries":[{"platform":"AIX","script_type":"UnixShell","script":"#!/bin/sh\n#pkg_name|pkg_vers|nothing|Not Uninstallable\n\ncheck_binary_exists() {\n    BINARY=\"$1\"\n    if command -v \"$BINARY\" > /dev/null 2>&1; then\n        return 0\n    else\n        return 1\n    fi\n}\n\n__wrap_command() {\n  _command=\"$1\"\n  shift\n  \"$_command\" \"$@\"\n}\n\n__kill_signal_pid_after() {\n  _signal=\"$1\"\n  _start_seconds=\"$2\"\n  _after=\"$3\"\n  _pid=\"$4\"\n  _tick=\"1\"\n\n  [ -z \"$_signal\" ] || [ -z \"$_after\" ] || [ -z \"$_pid\" ] && return 86\n\n  while (((SECONDS - _start_seconds) <= _after)); do\n    sleep \"$_tick\"\n  done && kill -0 \"$_pid\" > /dev/null 2> /dev/null && kill -s \"$_signal\" \"$_pid\" > /dev/null 2> /dev/null\n}\n\nrun_within_timeframe() {\n  _sigterm_after=50\n  _sigkill_after=55\n  _start_seconds=\"$SECONDS\"\n\n  if [ -n \"$TANIUM_SIGTERM_AFTER\" ]; then\n    _sigterm_after=\"$TANIUM_SIGTERM_AFTER\"\n  fi\n\n  if [ -n \"$TANIUM_SIGKILL_AFTER\" ]; then\n    _sigkill_after=\"$TANIUM_SIGKILL_AFTER\"\n  fi\n\n  __wrap_command \"$@\" &\n  _wrap_pid=\"$!\"\n\n  __kill_signal_pid_after TERM \"$_start_seconds\" \"$_sigterm_after\" \"$_wrap_pid\" &\n  __kill_signal_pid_after KILL \"$_start_seconds\" \"$_sigkill_after\" \"$_wrap_pid\" &\n\n  wait %1 > /dev/null 2> /dev/null\n  kill %2 %3 > /dev/null 2> /dev/null\n  wait %2 %3 > /dev/null 2> /dev/null\n\n  (((SECONDS - _start_seconds) >= _sigkill_after)) && return 3\n  (((SECONDS - _start_seconds) >= _sigterm_after)) && return 2\n\n  return 0\n}\n\n__rpm_is_locked() {\n\techo \"TSE-Error: RPM is locked by another process\"\n\texit\n}\n\nAbortIfRpmLocked() {\n\n\tif ! command -v rpm >/dev/null 2>/dev/null ; then\n\t\treturn\n\tfi\n\n\tif [ ! -d /var/lib/rpm ] ; then\n\t\treturn\n\tfi\n\n\tif ps -eo pid,comm,args | grep -v grep | grep -q '[ \\/]rpm' ; then\n\t\t__rpm_is_locked\n\tfi\n}\n\nlslpp -Lcq | awk -F: '{ print $2\"@@@\"$3 }' | while read -r pkg ; do\n\techo \"$pkg@@@nothing@@@Not Uninstallable\" | sed 's/\\|/_/g' | sed 's/@@@/|/g'\ndone\n\nif check_binary_exists \"rpm\" ; then\n\tAbortIfRpmLocked\n\trun_within_timeframe rpm -qa --queryformat \"%{NAME}@@@%{VERSION}@@@nothing@@@Not Uninstallable\\n\"| sed 's/\\|/_/g' | sed 's/@@@/|/g'\nfi\n# Copyright 2025, Tanium Inc."},{"platform":"Linux","script_type":"UnixShell","script":"#!/bin/sh\n##\n## Script Name: installed_applications.sh\n## Purpose: To query the list of installed applications on\n##          a Linux system.\n##\n\ncheck_binary_exists() {\n    BINARY=\"$1\"\n    if command -v \"$BINARY\" > /dev/null 2>&1; then\n        return 0\n    else\n        return 1\n    fi\n}\n\nsafe_rpm_readonly() {\n\t# safe_rpm_readonly drops permissions so that the\n\t# database is not corrupted on unclean process shutdown.\n\tif id \"nobody\" >/dev/null; then\n\t\tsu nobody -s /bin/sh -c \"rpm $*\"\n\telse\n\t\techo \"TSE-Error: low privilege cannot be obtained, will not run rpm command.\"\n\tfi\n}\n\n__rpm_is_locked() {\n\techo \"TSE-Error: RPM is locked by another process\"\n\texit\n}\n\nAbortIfRpmLocked() {\n\n\tif ! command -v rpm >/dev/null 2>/dev/null ; then\n\t\treturn\n\tfi\n\n\tif [ ! -d /var/lib/rpm ] ; then\n\t\treturn\n\tfi\n\n\tif ps -eo pid,comm,args | grep -v grep | grep -q '[ \\/]rpm' ; then\n\t\t__rpm_is_locked\n\tfi\n}\n\nPACKAGE_MANAGER_FOUND=0\n\nif check_binary_exists \"rpm\" ; then\n\tAbortIfRpmLocked\n\tsafe_rpm_readonly '-qa --queryformat \"%{NAME}@@@%{VERSION}@@@nothing@@@Not Uninstallable\\n\"' | sed 's/|/_/g' | sed 's/@@@/|/g'\n\tPACKAGE_MANAGER_FOUND=1\nfi\n\nif check_binary_exists \"dpkg\" ; then\n\tdpkg -l | awk '$1 == \"ii\" {print $2\"@@@\"$3\"@@@nothing@@@Not Uninstallable\"}' | sed 's/|/_/g' | sed 's/@@@/|/g'\n\tPACKAGE_MANAGER_FOUND=1\nfi\nif [ 0 = \"$PACKAGE_MANAGER_FOUND\" ]; then\n\techo \"Unknown Linux Distribution\"\nfi\n# Copyright 2025, Tanium Inc."},{"platform":"Mac","script_type":"Python","script":"from typing import Dict\nimport plistlib\nimport tanium\nimport subprocess\n\ndef add_app_to_results(app: Dict[str, str]) -> None:\n    try:\n        version = app.get('version', '')\n        result_str = f'{app[\"_name\"]}|{version}|nothing|Not Uninstallable'\n        tanium.results.add(result_str)\n    except Exception:\n        pass\n\ndef get_apps_data():\n    apps_data_cmd = [\"/usr/sbin/system_profiler\", \"-xml\", \"SPApplicationsDataType\"]\n    try:\n        with subprocess.Popen(apps_data_cmd, stdout=subprocess.PIPE) as proc:\n            apps_data = proc.stdout.read()\n        return plistlib.loads(apps_data)[0][\"_items\"]\n    except Exception:\n        pass\n\n    return None\n\ndef main():\n    apps = get_apps_data()\n\n    if not apps:\n        exit()\n\n    for app in apps:\n        if \"VMWare\" not in app[\"_name\"]:\n            add_app_to_results(app)\n\nif __name__ == \"__main__\":\n    main()\n# Copyright 2025, Tanium Inc."},{"platform":"Solaris","script_type":"UnixShell","script":"#!/bin/sh\nspc=\"[\\ \\       ]\"\npkginfo -l -c application | egrep 'PKGINST:|VERSION:' | sed 's/\\|/_/g' | paste - - | sed s/\"$spc\"*PKGINST:\"$spc\"*// | sed s/\"$spc\"*VERSION:\"$spc\"*/\\|/ | while read p\ndo\n   app=`echo $p | awk -F\\| '{print $1}'`\n   ver=`echo $p | awk -F\\| '{print $2}'`\n   ver=`echo $ver | awk -F, '{print $1}'`\n   echo \"$app|$ver|nothing|Not Uninstallable\"\ndone\n# Copyright 2025, Tanium Inc."},{"platform":"Windows","script_type":"VBScript","script":"'========================================\n' Installed Applications\n'========================================\n' This sensor will return information in the uninstall areas of the registry.\n' There are two hidden columns which can be filtered on despite the fact that\n' they're hidden, and can also feed actions.\n' if the uninstallstring is msi based, it is altered to show the\n' silent uninstall options and marked as \"Is Uninstallable\"\n' finally, if it's a user installed application, it will note that\n' The columns look like:\n' Name|Version|Silent Uninstall String|Uninstallable\n\nOption Explicit\n\nConst INCLUDE_APPS_WITHOUT_UNINSTALL_STRING = True\nConst INCLUDE_APPS_LABELED_AS_SYSTEM_COMPONENTS = False\n\nConst HKLM = &H80000002\nConst HKEY_USERS = &H80000003\n\nDim objReg : Set objReg = Getx64RegistryProvider()\nDim objRegEx : Set objRegEx = New RegExp\n\nDim strKeyNative : strKeyNative = \"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\nDim strKeyWow : strKeyWow = \"SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\n\nDim arrSubKeys, arrUserKeys, strUserKey\nDim strKeyPath : For Each strKeyPath In Array(strKeyNative, strKeyWow)\n\tobjReg.EnumKey HKLM, strKeyPath, arrSubKeys\n\tIf IsArray(arrSubKeys) Then _\n\t\tGetApplications HKLM, strKeyPath, arrSubKeys\nNext\n\n'Search applications installed to HKEY_Users\nobjReg.EnumKey HKEY_USERS, \"\", arrUserKeys\nFor Each strUserKey In arrUserKeys\n\tobjReg.EnumKey HKEY_USERS, strUserKey & \"\\\" & strKeyNative, arrSubKeys\n\tIf IsArray(arrSubKeys) Then _\n\t\tGetApplications HKEY_USERS, strUserKey & \"\\\" & strKeyNative, arrSubKeys\nNext\n\nSub GetApplications(HIVE, strKeyPath, arrSubKeys)\n\t'On Error Resume Next\n\tDim dicUninstallKeys : Set dicUninstallKeys = CreateObject(\"Scripting.Dictionary\")\n\tdicUninstallKeys.CompareMode = vbTextCompare\n\t\n\tDim strKey : For Each strKey In arrSubKeys\n\t\tdicUninstallKeys(strKey) = \"\"\n\tNext\n\t\n\tFor Each strKey In dicUninstallKeys.Keys\n\t\tDim strDisplayName, intSystemComponent, strParentKey, strVersion, strUninstallString\n\t\t\n\t\tDim strValueToCheck : For Each strValueToCheck In Array(\"DisplayName\", \"QuietDisplayName\", \"HiddenDisplayName\")\n\t\t\tobjReg.GetStringValue HIVE, strKeyPath & \"\\\" & strKey, strValueToCheck, strDisplayName\n\t\t\tIf Len(strDisplayName) > 0 Then Exit For\n\t\tNext\n\t\t\n\t\tDo\n\t\t\tIf (IsNull(strDisplayName) = True) Or (strDisplayName = \"\") Then Exit Do\n\t\t\tIf InStr(strDisplayName, \"Hotfix\") > 0 Then Exit Do\n\t\t\tIf Left(strDisplayName, 10) = \"Update for\" Then Exit Do\n\t \t\tIf InStr(strDisplayName, \"Security Update for\") > 0 Then Exit Do\n\t\t\t\n\t\t\tIf INCLUDE_APPS_LABELED_AS_SYSTEM_COMPONENTS = False Then\n\t\t\t\tobjReg.GetDWORDValue  HIVE, strKeyPath & \"\\\" & strKey, \"SystemComponent\", intSystemComponent\n\t\t\t\tIf intSystemComponent = 1 Then Exit Do\n\t\t\tEnd If\n\t\t\t\n\t\t\tobjReg.GetStringValue HIVE, strKeyPath & \"\\\" & strKey, \"ParentKeyName\", strParentKey\n\t\t\tIf Len(strParentKey) > 0 Then\n\t\t\t\t'Make sure the parent Key actually exists before existing\n\t\t\t\tIf dicUninstallKeys.Exists(strParentKey) Then Exit Do\n\t\t\tEnd If\n\t\t\t\n\t\t\tobjReg.GetStringValue HIVE, strKeyPath & \"\\\" & strKey, \"UninstallString\", strUninstallString\n\t\t\tIf IsNull(strUninstallString) Then\n\t\t\t\t'Some vendors have used REG_EXPAND_SZ value type for UninstallString. Attempt secondary read.\n\t\t\t\tobjReg.GetExpandedStringValue HIVE, strKeyPath & \"\\\" & strKey, \"UninstallString\", strUninstallString\n\t\t\t\tIf IsNull(strUninstallString) Then\n\t\t\t\t\tIf INCLUDE_APPS_WITHOUT_UNINSTALL_STRING = False Then Exit Do\n\t\t\t\t\tstrUninstallString = \"No Uninstall String\"\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\t\t\n\t\t\t' assume it's not uninstallable\n\t\t\tDim strUninstallable : strUninstallable = \"Not Uninstallable\"\n\t\t\t\n\t\t\tIf InStr(1, strUninstallString, \"msiexec\", vbTextCompare) Then\n\t\t\t\t' msiexec uninstall commands can be fed into our uninstall package\n\t\t\t\t' Replace any /I with /X and add silent flags\n\t\t\t\t'strUninstallString = Replace(strUninstallString, \"/I\", \"/X\") & \" /qn /noreboot\"\n\t \t\t\tstrUninstallable = \"Is Uninstallable\"\n\t\t\tEnd If\n\t\t\t\n\t\t\tobjReg.GetStringValue HIVE, strKeyPath & \"\\\" & strKey, \"DisplayVersion\", strVersion\n\t\t\tIf IsNull(strVersion) Then\n\t\t\t\tstrVersion = GetVersionInString(strDisplayName)\n\t\t\tEnd If\n\t\t\t\n\t\t\tstrDisplayName = Replace(strDisplayName, \"|\", \"_\")\n\t\t\tIf HIVE = HKEY_USERS Then strUninstallString = \"\" ' Do not return uninstall strings from user hives\n\t\t\t\n\t\t\tWScript.Echo strDisplayName & \"|\" & strVersion & \"|\" & strUninstallString & \"|\" & strUninstallable\n\t\t\t\n\t\t\tExit Do\n\t\tLoop\n\tNext\nEnd Sub 'GetApplications\n\nFunction GetVersionInString(ByVal strTemp)\n' examine a string and attempt to extract a version\n' e.g. \"SQL Server 2014 (64-bit)\" returns \"2014\"\n' e.g. \"FooBar2 12.3.7\" returns \"12.3.7\"\n' e.g. \"FooBar\" returns \"N/A\"\n\tDim strFoundVersion : strFoundVersion = \"N/A\"\n\t' remove trailing parentheses and content from version consideration\n\t' e.g. SQL Server 2014 (64-bit) to SQL Server 2014\n\tWith objRegEx\n\t\t.Pattern = \"\\(.*\\)$\"\n\t\t.Global = False\n\tEnd With\n\tstrTemp = objRegEx.Replace(strTemp, \"\")\n\n\t' find versions in what's left, choose the rightmost one\n\t'Set objRegEx = New RegExp\n\tWith objRegEx\n\t\t.Pattern = \"[\\d]+[\\d.-]*\"\n\t\t.Global = True\n\tEnd With\n\tDim objMatches : Set objMatches = objRegEx.Execute(strTemp)\n\tIf objMatches.Count > 0 Then\n\t\tstrFoundVersion = objMatches.Item(objMatches.Count - 1)\n\tEnd If\n\tGetVersionInString = strFoundVersion\nEnd Function 'GetVersionInString\n\nFunction Getx64RegistryProvider\n\t' Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n\tDim intArchType : intArchType = 64\n\tIf Is64() = False Then intArchType = 32\n\t\n\tDim objCtx : Set objCtx = CreateObject(\"WbemScripting.SWbemNamedValueSet\")\n\tobjCtx.Add \"__ProviderArchitecture\", intArchType\n\tDim objLocator : Set objLocator = CreateObject(\"Wbemscripting.SWbemLocator\")\n\tDim objServices : Set objServices = objLocator.ConnectServer(\"\",\"root\\default\",\"\",\"\",,,,objCtx)\n\tDim objRegProv : Set objRegProv = objServices.Get(\"StdRegProv\")\n\t\n\tSet Getx64RegistryProvider = objRegProv\nEnd Function ' Getx64RegistryProvider\n\nFunction Is64()\n\tIs64 = True\n\tDim objWshShell : Set objWshShell = CreateObject(\"WScript.Shell\")\n\tIf objWshShell.ExpandEnvironmentStrings(\"%PROCESSOR_ARCHITECTURE%\") = \"x86\" Then\n\t\tIf objWshShell.ExpandEnvironmentStrings(\"%PROCESSOR_ARCHITEW6432%\") = \"%PROCESSOR_ARCHITEW6432%\" Then\n\t\t\tIs64 = False\n\t\tEnd If\n\tEnd If\nEnd Function\n' Copyright 2025, Tanium Inc."}],"parameter_definition":"","parameters":"","value_type":"String","max_age_seconds":3600,"ignore_case_flag":1,"delimiter":"|","subcolumns":[{"name":"Name","index":"0","value_type":"String","ignore_case_flag":1,"hidden_flag":0},{"name":"Version","index":"1","value_type":"Version","ignore_case_flag":1,"hidden_flag":0},{"name":"Silent Uninstall String","index":"2","value_type":"String","ignore_case_flag":1,"hidden_flag":0},{"name":"Uninstallable","index":"3","value_type":"String","ignore_case_flag":1,"hidden_flag":0}],"hidden_flag":0,"keep_duplicates_flag":0,"metadata":[{"name":"com.tanium.ai.example_column_values","value":"[\n    {\"column_name\":\"Name\",\"example_values\":[\"Mozilla Firefox\",\"Google Chrome\",\"Microsoft Office\"]},\n    {\"column_name\":\"Version\",\"example_values\":[\"16.0.1\",\"89.0.4389.82\",\"2019\"]},\n    {\"column_name\":\"Silent Uninstall String\",\"example_values\":[\"No Uninstall String\",\"msiexec /X {GUID} /qn\",\"Not Uninstallable\"]},\n    {\"column_name\":\"Uninstallable\",\"example_values\":[\"Not Uninstallable\",\"Is Uninstallable\",\"Not Uninstallable\"]}\n]"},{"name":"com.tanium.ai.example_prompts","value":"[\n    \"What applications are installed on my computer?\",\n    \"List all installed software and their versions.\",\n    \"Show me the applications and their uninstall options.\"\n]"},{"name":"com.tanium.tds.default_harvest","value":""},{"name":"com.tanium.tds.high_cardinality","value":""}]}]}}
