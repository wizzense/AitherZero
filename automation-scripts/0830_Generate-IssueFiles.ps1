#Requires -Version 7.0
<#
.SYNOPSIS
    Generate GitHub issue files from analysis findings
.DESCRIPTION
    Creates individual issue files that can be easily converted to GitHub issues
    Works without GitHub CLI - generates issue templates ready for manual/API creation
.PARAMETER OutputPath
    Directory to save generated issue files
.PARAMETER AnalysisPath
    Path to analysis results directory  
.PARAMETER Format
    Output format: Files, JSON, or Markdown
#>
[CmdletBinding()]
param(
    [string]$OutputPath = "./generated-issues",
    [string]$AnalysisPath = "./reports",
    [ValidateSet('Files', 'JSON', 'Markdown')]
    [string]$Format = 'Files'
)

# Script metadata
$scriptInfo = @{
    Stage = 'Generation'
    Number = '0830'
    Name = 'Generate-IssueFiles'
    Description = 'Generate GitHub issue files without CLI dependency'
    Dependencies = @('0815')
    Tags = @('generation', 'github', 'issues', 'files')
}

function Write-GenStatus {
    param([string]$Message, [string]$Level = "Info")
    $color = switch ($Level) {
        "Error" { "Red" }
        "Warning" { "Yellow" }
        "Success" { "Green" }
        "Critical" { "Magenta" }
        default { "Cyan" }
    }
    Write-Host "üìù $Message" -ForegroundColor $color
}

function Get-SecurityFindings {
    param([string]$Path)
    
    $securityFile = Join-Path $Path "tech-debt/analysis/SecurityIssues-latest.json"
    if (-not (Test-Path $securityFile)) {
        Write-GenStatus "No security analysis found at: $securityFile" "Warning"
        return @()
    }

    try {
        $analysis = Get-Content $securityFile | ConvertFrom-Json
        $findings = @()

        # Critical security issues
        if ($analysis.Results.UnsafeCommands.Count -gt 0) {
            $criticalCount = ($analysis.Results.UnsafeCommands | Where-Object { $_.Severity -eq 'Critical' }).Count
            
            if ($criticalCount -gt 0) {
                $findings += @{
                    Title = "üö® [SECURITY] Critical Security Vulnerabilities ($criticalCount issues)"
                    Priority = "P0-Critical"
                    Type = "security"
                    Count = $criticalCount
                    Labels = @('P0-Critical', 'security', 'vulnerability', 'automated-issue')
                    Details = $analysis.Results.UnsafeCommands | Where-Object { $_.Severity -eq 'Critical' } | Select-Object -First 5
                    Assignee = "copilot"
                }
            }
        }

        # Credential issues
        if ($analysis.Results.PlainTextCredentials.Count -gt 0) {
            $findings += @{
                Title = "üîê [SECURITY] Exposed Credentials ($($analysis.Results.PlainTextCredentials.Count) instances)"
                Priority = "P0-Critical"
                Type = "credentials"
                Count = $analysis.Results.PlainTextCredentials.Count
                Labels = @('P0-Critical', 'security', 'credentials', 'urgent', 'automated-issue')
                Details = $analysis.Results.PlainTextCredentials | Select-Object -First 5
                Assignee = "copilot"
            }
        }

        # Insecure protocols
        if ($analysis.Results.InsecureProtocols.Count -gt 0) {
            $findings += @{
                Title = "üåê [SECURITY] Insecure Protocol Usage ($($analysis.Results.InsecureProtocols.Count) instances)"
                Priority = "P1-High"
                Type = "protocols"
                Count = $analysis.Results.InsecureProtocols.Count
                Labels = @('P1-High', 'security', 'protocols', 'automated-issue')
                Details = $analysis.Results.InsecureProtocols | Select-Object -First 5
                Assignee = "copilot"
            }
        }

        return $findings
    }
    catch {
        Write-GenStatus "Error parsing security analysis: $_" "Error"
        return @()
    }
}

function New-IssueContent {
    param([hashtable]$Finding)
    
    $body = @()
    $body += "## ü§ñ Automated Issue - $($Finding.Type.ToUpper()) Analysis"
    $body += ""
    $body += "**Generated by:** AitherZero Issue Management System"
    $body += "**Analysis Date:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    $body += "**Priority:** $($Finding.Priority)"
    $body += "**Issue Count:** $($Finding.Count)"
    $body += "**Assignee:** @$($Finding.Assignee)"
    $body += ""
    
    switch ($Finding.Type) {
        'security' {
            $body += "## üîí Security Analysis Summary"
            $body += ""
            $body += "Automated security analysis has identified **$($Finding.Count) critical security vulnerabilities** that require immediate attention."
            $body += ""
            $body += "### üìä Finding Details"
            foreach ($detail in $Finding.Details) {
                $body += "- **$($detail.Severity)**: Line $($detail.Line) in ``$($detail.File)``"
                $body += "  - **Issue**: $($detail.Description)"
                $body += "  - **Context**: ``$($detail.Context)``"
                $body += ""
            }
            
            $body += "### üõ†Ô∏è Recommended Actions"
            $body += ""
            $body += "@$($Finding.Assignee) Please address these security vulnerabilities with **HIGHEST PRIORITY**:"
            $body += ""
            $body += "1. **Review each identified location** for security implications"
            $body += "2. **Replace unsafe patterns** with secure alternatives:"
            $body += "   - Replace ``Invoke-Expression`` with direct command execution"
            $body += "   - Use ``SecureString`` for credential handling"
            $body += "   - Implement proper input validation"
            $body += "3. **Test security fixes** to ensure functionality is maintained"
            $body += "4. **Run security analysis** again to verify resolution"
            $body += ""
            $body += "### üéØ Security Best Practices"
            $body += "- Avoid dynamic code execution (``Invoke-Expression``)"
            $body += "- Use secure credential storage mechanisms"
            $body += "- Implement input validation and sanitization"
            $body += "- Follow principle of least privilege"
        }
        
        'credentials' {
            $body += "## üîê Credential Security Issue"
            $body += ""
            $body += "**üö® CRITICAL SECURITY RISK**: Exposed credentials detected in source code."
            $body += ""
            $body += "### üìç Locations Found"
            foreach ($detail in $Finding.Details) {
                $body += "- ``$($detail.File):$($detail.Line)`` - $($detail.Description)"
            }
            $body += ""
            $body += "### ‚ö° IMMEDIATE Actions Required"
            $body += ""
            $body += "@$($Finding.Assignee) **URGENT - STOP EVERYTHING AND FIX THIS NOW**:"
            $body += ""
            $body += "1. **‚ùå REMOVE hardcoded credentials** from source code immediately"
            $body += "2. **üîê USE environment variables** or secure credential stores"
            $body += "3. **üîÑ ROTATE any exposed credentials** if they are real"
            $body += "4. **‚úÖ IMPLEMENT SecureString patterns** for PowerShell"
            $body += "5. **üìù ADD .gitignore entries** for credential files"
            $body += ""
            $body += "**‚ö†Ô∏è WARNING**: This is a **CRITICAL SECURITY VULNERABILITY** that could lead to:"
            $body += "- Unauthorized system access"
            $body += "- Data breaches"
            $body += "- Compliance violations"
            $body += "- Service compromises"
        }
        
        'protocols' {
            $body += "## üåê Insecure Protocol Security Issue"
            $body += ""
            $body += "**Security analysis identified $($Finding.Count) instances** of insecure protocol usage."
            $body += ""
            $body += "### üìç Issues Found"
            foreach ($detail in $Finding.Details) {
                $body += "- **$($detail.Severity)**: ``$($detail.File):$($detail.Line)``"
                $body += "  - **Issue**: $($detail.Description)"
                $body += "  - **Context**: ``$($detail.Context)``"
                $body += ""
            }
            $body += ""
            $body += "### üõ†Ô∏è Resolution Steps"
            $body += ""
            $body += "@$($Finding.Assignee) Please address these protocol security issues:"
            $body += ""
            $body += "1. **Replace HTTP with HTTPS** where possible"
            $body += "2. **Enable certificate validation** (remove `-SkipCertificateCheck`)"
            $body += "3. **Use secure communication channels** for sensitive data"
            $body += "4. **Implement proper TLS/SSL configuration**"
        }
        
        'test-failure' {
            $body += "## üß™ Test Failure Analysis"
            $body += ""
            $body += "Automated testing has detected **$($Finding.Count) test failures** that require immediate attention."
            $body += ""
            if ($Finding.ReportFile) {
                $body += "**Report File:** ``$($Finding.ReportFile)``"
                $body += ""
            }
            
            $body += "### ‚ùå Failed Tests Details"
            foreach ($test in $Finding.Details) {
                $body += "- **$($test.Name)**: $($test.Result)"
                if ($test.Error) {
                    $body += "  - **Error**: $($test.Error)"
                }
            }
            $body += ""
            $body += "### üîß Critical Fix Instructions"
            $body += ""
            $body += "@$($Finding.Assignee) **URGENT**: These test failures indicate broken functionality:"
            $body += ""
            $body += "1. **üîç RUN LOCALLY**: ``./automation-scripts/0402_Run-UnitTests.ps1``"
            $body += "2. **üß™ ANALYZE PATTERNS**: Look for common failure causes"
            $body += "3. **üõ†Ô∏è FIX ROOT CAUSE**: Don't just update tests without fixing code"
            $body += "4. **‚úÖ VERIFY ALL PASS**: Run full test suite before committing"
            $body += "5. **üìù UPDATE TESTS**: Only if requirements have legitimately changed"
        }
        
        'pester-failure' {
            $body += "## üî¥ Pester Unit Test Failures"
            $body += ""
            $body += "**$($Finding.Count) unit tests are currently failing** and need immediate attention."
            $body += ""
            if ($Finding.ReportFile) {
                $body += "**Test Results File:** ``$($Finding.ReportFile)``"
                $body += ""
            }
            
            $body += "### ‚ùå Failed Tests Details"
            foreach ($test in $Finding.Details) {
                $body += "- **$($test.Name)** in ``$($test.File)``"
                if ($test.Message) {
                    $body += "  - **Error**: $($test.Message)"
                }
                $body += ""
            }
            
            $body += "### üö® Critical Action Required"
            $body += ""
            $body += "@$($Finding.Assignee) **URGENT**: These test failures indicate broken functionality:"
            $body += ""
            $body += "1. **üîç INVESTIGATE** each failing test immediately"
            $body += "2. **üèÉ RUN LOCALLY**: ``Invoke-Pester -Path ./tests/unit -Output Detailed``"  
            $body += "3. **üîß FIX ROOT CAUSE** - don't just update tests"
            $body += "4. **‚úÖ VERIFY ALL PASS**: ``./automation-scripts/0402_Run-UnitTests.ps1``"
            $body += "5. **üìù DOCUMENT** what was broken and how it was fixed"
            $body += ""
            $body += "### üéØ Testing Commands"
            $body += "```powershell"
            $body += "# Run all unit tests with detailed output"
            $body += "Invoke-Pester -Path ./tests/unit -Output Detailed"
            $body += ""
            $body += "# Run full test suite validation"
            $body += "./automation-scripts/0409_Run-AllTests.ps1"
            $body += ""
            $body += "# Check test coverage"
            $body += "./automation-scripts/0408_Generate-TestCoverage.ps1"
            $body += "```"
        }
        
        'bugs' {
            $body += "## üêõ System Errors and Bug Analysis"
            $body += ""
            $body += "**$($Finding.Count) system errors** have been detected in logs and need investigation."
            $body += ""
            $body += "### üî• Error Details"
            foreach ($error in $Finding.Details) {
                $body += "- **$($error.Pattern)** in ``$($error.File):$($error.Line)``"
                $body += "  - **Error**: ``$($error.Content)``"
                $body += ""
            }
            
            $body += "### üö® Bug Fix Protocol"
            $body += ""
            $body += "@$($Finding.Assignee) **CRITICAL**: System errors require immediate investigation:"
            $body += ""
            $body += "1. **üìã REPRODUCE** the error conditions"
            $body += "2. **üîç ANALYZE** error patterns and stack traces"
            $body += "3. **üõ†Ô∏è IMPLEMENT** proper error handling"
            $body += "4. **üß™ TEST** error scenarios thoroughly"
            $body += "5. **üìä MONITOR** for error recurrence"
            $body += ""
            $body += "### üéØ Debugging Commands"
            $body += "```powershell"
            $body += "# Check recent error logs"
            $body += "Get-Content ./logs/transcript-*.log | Select-String -Pattern 'ERROR|Exception'"
            $body += ""
            $body += "# Run system validation"
            $body += "./automation-scripts/0409_Run-AllTests.ps1"
            $body += ""
            $body += "# Check application logs"
            $body += "Get-ChildItem ./logs/*.log | ForEach-Object { Select-String -Path $_ -Pattern 'FATAL|CRASH' }"
            $body += "```"
        }
        
        'ci-analysis' {
            $body += "## ‚öôÔ∏è CI/CD Analysis Required"
            $body += ""
            $body += "GitHub Actions environment detected - automated analysis needed for CI/CD pipeline."
            $body += ""
            $body += "### üîç Analysis Scope"
            foreach ($detail in $Finding.Details) {
                $body += "- **$($detail.Description)**"
                $body += "  - **Context**: $($detail.Context)"
                $body += ""
            }
            
            $body += "### üéØ CI/CD Optimization Tasks"
            $body += ""
            $body += "@$($Finding.Assignee) Please analyze and optimize the CI/CD pipeline:"
            $body += ""
            $body += "1. **üìä REVIEW** workflow execution times and success rates"
            $body += "2. **üîç IDENTIFY** bottlenecks and failure points"  
            $body += "3. **‚ö° OPTIMIZE** slow or unreliable steps"
            $body += "4. **üõ°Ô∏è ENHANCE** error handling and retry logic"
            $body += "5. **üìà MONITOR** improvements and track metrics"
        }
    }
    
    $body += ""
    $body += "---"
    $body += "### üìà Impact & Priority"
    
    switch ($Finding.Priority) {
        'P0-Critical' { 
            $body += "**üö® CRITICAL**: Requires immediate attention - security risk or blocking issue"
            $body += "**Expected Resolution Time**: < 4 hours"
            $body += "**Impact**: HIGH - Could lead to security breaches or system compromise"
        }
        'P1-High' { 
            $body += "**‚ö° HIGH**: Should be resolved within 1-2 days"
            $body += "**Expected Resolution Time**: 1-2 days"
            $body += "**Impact**: MEDIUM - Could lead to security vulnerabilities"
        }
        'P2-Medium' { 
            $body += "**üîß MEDIUM**: Should be addressed in current sprint"
            $body += "**Expected Resolution Time**: 1 week"
            $body += "**Impact**: LOW - Improves security posture"
        }
    }
    
    $body += ""
    $body += "**Automation**: This issue was automatically created by AitherZero analysis system"
    $body += "**Next Analysis**: Will run again after changes are made to verify resolution"
    
    return @{
        Title = $Finding.Title
        Body = $body -join "`n"
        Labels = $Finding.Labels
        Priority = $Finding.Priority
        Assignee = $Finding.Assignee
        Type = $Finding.Type
    }
}

function Get-TestFindings {
    param([string]$Path)
    
    $findings = @()
    
    # Look for test report files  
    $testFiles = Get-ChildItem -Path $Path -Filter "TestReport-*.json" -ErrorAction SilentlyContinue | Sort-Object CreationTime -Descending | Select-Object -First 2
    
    foreach ($testFile in $testFiles) {
        try {
            $testReport = Get-Content $testFile.FullName | ConvertFrom-Json
            
            # Check if there are test failures
            if ($testReport.TestResults -and $testReport.TestResults.Details) {
                $failedTests = $testReport.TestResults.Details | Where-Object { $_.Result -eq 'Failed' }
                
                if ($failedTests.Count -gt 0) {
                    $findings += @{
                        Title = "üß™ [TESTS] Test Failures Detected ($($failedTests.Count) failures)"
                        Priority = "P1-High"
                        Type = "test-failure"
                        Count = $failedTests.Count
                        Labels = @('P1-High', 'tests', 'ci-failure', 'bug', 'automated-issue')
                        Details = $failedTests | Select-Object -First 5
                        ReportFile = $testFile.Name
                        Assignee = "copilot"
                    }
                }
            }
        }
        catch {
            Write-GenStatus "Error parsing test report $($testFile.Name): $_" "Warning"
        }
    }
    
    # Check for Pester XML results
    $pesterResults = Get-ChildItem -Path "." -Filter "*TestResults*.xml" -ErrorAction SilentlyContinue | Sort-Object CreationTime -Descending | Select-Object -First 1
    
    if ($pesterResults) {
        try {
            [xml]$pesterXml = Get-Content $pesterResults.FullName
            $failedTests = $pesterXml.SelectNodes("//test-case[@result='Failed']")
            
            if ($failedTests.Count -gt 0) {
                $findings += @{
                    Title = "üî¥ [PESTER] Unit Test Failures ($($failedTests.Count) tests failed)"
                    Priority = "P1-High"
                    Type = "pester-failure"
                    Count = $failedTests.Count
                    Labels = @('P1-High', 'tests', 'pester', 'unit-tests', 'failure', 'bug', 'automated-issue')
                    Details = $failedTests | Select-Object -First 5 | ForEach-Object {
                        @{
                            Name = $_.name
                            Result = $_.result
                            Message = $_.failure.message
                            File = $_.classname
                        }
                    }
                    ReportFile = $pesterResults.Name
                    Assignee = "copilot"
                }
            }
        }
        catch {
            Write-GenStatus "Error parsing Pester results $($pesterResults.Name): $_" "Warning"
        }
    }
    
    return $findings
}

function Get-BugFindings {
    param([string]$Path)
    
    $findings = @()
    
    # Check for error logs and crash dumps
    $errorPatterns = @(
        @{ Path = "logs/*.log"; Pattern = "ERROR|FATAL|EXCEPTION|CRASH"; Description = "Application errors" }
        @{ Path = "*.log"; Pattern = "ERROR|Exception|Failed"; Description = "System errors" }
        @{ Path = "logs/transcript-*.log"; Pattern = "ERROR|Exception|terminating error"; Description = "PowerShell errors" }
    )
    
    $errorCount = 0
    $criticalErrors = @()
    
    foreach ($errorPattern in $errorPatterns) {
        try {
            $logFiles = Get-ChildItem -Path $errorPattern.Path -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 3
            
            foreach ($logFile in $logFiles) {
                if (Test-Path $logFile.FullName) {
                    $errorLines = Select-String -Path $logFile.FullName -Pattern $errorPattern.Pattern -ErrorAction SilentlyContinue | Select-Object -First 5
                    
                    if ($errorLines.Count -gt 0) {
                        $errorCount += $errorLines.Count
                        $criticalErrors += $errorLines | ForEach-Object {
                            @{
                                File = $logFile.Name
                                Line = $_.LineNumber
                                Content = $_.Line.Trim()
                                Pattern = $errorPattern.Description
                            }
                        }
                    }
                }
            }
        }
        catch {
            # Silently continue if log files can't be read
        }
    }
    
    # Create bug issue if errors found
    if ($errorCount -gt 0) {
        $findings += @{
            Title = "üêõ [BUGS] System Errors Detected ($errorCount errors)"
            Priority = "P1-High"
            Type = "bugs"
            Count = $errorCount
            Labels = @('P1-High', 'bug', 'error', 'system', 'automated-issue')
            Details = $criticalErrors | Select-Object -First 5
            Assignee = "copilot"
        }
    }
    
    # Check for GitHub Actions failures (if available)
    if ($env:GITHUB_ACTIONS) {
        # In GitHub Actions, check for workflow failures
        $findings += @{
            Title = "‚öôÔ∏è [CI] GitHub Actions Analysis Required"
            Priority = "P2-Medium"
            Type = "ci-analysis"
            Count = 1
            Labels = @('P2-Medium', 'ci', 'github-actions', 'automated-issue')
            Details = @(@{
                Description = "Automated analysis of GitHub Actions workflow needed"
                Context = "Running in GitHub Actions environment"
            })
            Assignee = "copilot"
        }
    }
    
    return $findings
}

# Main execution
try {
    Write-GenStatus "üöÄ Starting GitHub Issue File Generation..." "Critical"
    Write-Host ""
    
    # Create output directory
    if (-not (Test-Path $OutputPath)) {
        New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
        Write-GenStatus "Created output directory: $OutputPath" "Info"
    }
    
    # Clean previous files
    Get-ChildItem -Path $OutputPath -Filter "*.md" | Remove-Item -Force
    Get-ChildItem -Path $OutputPath -Filter "*.json" | Remove-Item -Force
    
    # Get all findings
    Write-GenStatus "Analyzing security findings..." "Info"
    $securityFindings = Get-SecurityFindings -Path $AnalysisPath
    Write-GenStatus "Found $($securityFindings.Count) security issue categories" "Success"
    
    Write-GenStatus "Analyzing test failures..." "Info"
    $testFindings = Get-TestFindings -Path $AnalysisPath
    Write-GenStatus "Found $($testFindings.Count) test failure categories" "Success"
    
    Write-GenStatus "Analyzing system errors and bugs..." "Info"
    $bugFindings = Get-BugFindings -Path $AnalysisPath
    Write-GenStatus "Found $($bugFindings.Count) bug/error categories" "Success"
    
    # Combine all findings
    $findings = @()
    $findings += $securityFindings
    $findings += $testFindings  
    $findings += $bugFindings
    
    if ($findings.Count -eq 0) {
        Write-GenStatus "‚ùå No security issues found to generate!" "Error"
        Write-GenStatus "Check that analysis has been run and results exist at: $AnalysisPath" "Info"
        exit 1
    }
    
    $issueFiles = @()
    $allIssues = @()
    
    for ($i = 0; $i -lt $findings.Count; $i++) {
        $finding = $findings[$i]
        $issueContent = New-IssueContent -Finding $finding
        $allIssues += $issueContent
        
        $fileName = "issue-$(($i + 1).ToString('00'))-$($finding.Type)"
        
        if ($Format -eq 'Files' -or $Format -eq 'Markdown') {
            # Create individual markdown files
            $mdFile = Join-Path $OutputPath "$fileName.md"
            
            $mdContent = @()
            $mdContent += "# $($issueContent.Title)"
            $mdContent += ""
            $mdContent += "**Labels**: $($issueContent.Labels -join ', ')"
            $mdContent += "**Priority**: $($issueContent.Priority)"
            $mdContent += "**Assignee**: $($issueContent.Assignee)"
            $mdContent += ""
            $mdContent += $issueContent.Body
            
            Set-Content -Path $mdFile -Value ($mdContent -join "`n") -Encoding UTF8
            $issueFiles += $mdFile
            
            Write-GenStatus "Generated: $mdFile" "Success"
        }
    }
    
    if ($Format -eq 'Files' -or $Format -eq 'JSON') {
        # Create combined JSON file for API usage
        $jsonFile = Join-Path $OutputPath "all-issues.json"
        $allIssues | ConvertTo-Json -Depth 10 | Set-Content -Path $jsonFile -Encoding UTF8
        $issueFiles += $jsonFile
        
        Write-GenStatus "Generated: $jsonFile" "Success"
    }
    
    # Create a summary script
    $summaryFile = Join-Path $OutputPath "CREATE-ISSUES.md"
    $summary = @()
    $summary += "# üö® CRITICAL: GitHub Issues Ready for Creation"
    $summary += ""
    $summary += "**Generated**: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    $summary += "**Issues Found**: $($findings.Count) categories"
    $summary += ""
    $summary += "## üî• IMMEDIATE ACTION REQUIRED"
    $summary += ""
    $summary += "The analysis has found **CRITICAL SECURITY ISSUES** that need immediate attention:"
    
    foreach ($issue in $allIssues) {
        $urgency = if ($issue.Priority -eq 'P0-Critical') { "üö® **CRITICAL**" } else { "‚ö° **HIGH**" }
        $summary += "- $urgency $($issue.Title)"
    }
    
    $summary += ""
    $summary += "## üìã How to Create These Issues"
    $summary += ""
    $summary += "### Option 1: Manual Creation (Recommended)"
    $summary += "1. Go to: https://github.com/wizzense/AitherZero/issues/new"
    $summary += "2. Copy content from individual .md files in this directory"
    $summary += "3. Create each issue with appropriate labels and assignee"
    $summary += ""
    $summary += "### Option 2: GitHub CLI (if available)"
    $summary += '```bash'
    
    for ($i = 0; $i -lt $allIssues.Count; $i++) {
        $issue = $allIssues[$i]
        $fileName = "issue-$(($i + 1).ToString('00'))-$($issue.Type).md"
        $labelString = $issue.Labels -join ','
        $summary += "gh issue create --title `"$($issue.Title)`" --body-file `"$fileName`" --label `"$labelString`" --assignee $($issue.Assignee)"
    }
    
    $summary += '```'
    $summary += ""
    $summary += "### Option 3: GitHub API"
    $summary += "Use the all-issues.json file with GitHub's REST API"
    $summary += ""
    $summary += "## üéØ Priority Order"
    $summary += "1. **P0-Critical**: Fix immediately (< 4 hours)"
    $summary += "2. **P1-High**: Fix within 1-2 days"  
    $summary += "3. **P2-Medium**: Fix within 1 week"
    
    Set-Content -Path $summaryFile -Value ($summary -join "`n") -Encoding UTF8
    
    Write-Host ""
    Write-GenStatus "‚úÖ Issue Generation Complete!" "Success"
    Write-Host ""
    Write-GenStatus "üìÅ Generated Files:" "Info"
    foreach ($file in $issueFiles) {
        Write-Host "  ‚Ä¢ $(Split-Path $file -Leaf)" -ForegroundColor White
    }
    Write-Host "  ‚Ä¢ CREATE-ISSUES.md (üìã Instructions)" -ForegroundColor Yellow
    
    Write-Host ""
    Write-GenStatus "üö® NEXT STEPS:" "Critical"
    Write-Host "1. Open: $summaryFile" -ForegroundColor Red
    Write-Host "2. Follow instructions to create GitHub issues" -ForegroundColor Red
    Write-Host "3. Prioritize P0-Critical issues first!" -ForegroundColor Red
    
    exit 0
}
catch {
    Write-GenStatus "‚ùå Generation failed: $_" "Error"
    Write-Host $_.ScriptStackTrace -ForegroundColor Red
    exit 1
}

