#Requires -Version 7.0
<#
.SYNOPSIS
    Generate GitHub issue files from analysis findings
.DESCRIPTION
    Creates individual issue files that can be easily converted to GitHub issues
    Works without GitHub CLI - generates issue templates ready for manual/API creation
.PARAMETER OutputPath
    Directory to save generated issue files
.PARAMETER AnalysisPath
    Path to analysis results directory  
.PARAMETER Format
    Output format: Files, JSON, or Markdown
#>
[CmdletBinding()]
param(
    [string]$OutputPath = "./generated-issues",
    [string]$AnalysisPath = "./reports",
    [ValidateSet('Files', 'JSON', 'Markdown')]
    [string]$Format = 'Files'
)

# Script metadata
$scriptInfo = @{
    Stage = 'Generation'
    Number = '0830'
    Name = 'Generate-IssueFiles'
    Description = 'Generate GitHub issue files without CLI dependency'
    Dependencies = @('0815')
    Tags = @('generation', 'github', 'issues', 'files')
}

function Write-GenStatus {
    param([string]$Message, [string]$Level = "Info")
    $color = switch ($Level) {
        "Error" { "Red" }
        "Warning" { "Yellow" }
        "Success" { "Green" }
        "Critical" { "Magenta" }
        default { "Cyan" }
    }
    Write-Host "üìù $Message" -ForegroundColor $color
}

function Get-SecurityFindings {
    param([string]$Path)
    
    $securityFile = Join-Path $Path "tech-debt/analysis/SecurityIssues-latest.json"
    if (-not (Test-Path $securityFile)) {
        Write-GenStatus "No security analysis found at: $securityFile" "Warning"
        return @()
    }

    try {
        $analysis = Get-Content $securityFile | ConvertFrom-Json
        $findings = @()

        # Critical security issues
        if ($analysis.Results.UnsafeCommands.Count -gt 0) {
            $criticalCount = ($analysis.Results.UnsafeCommands | Where-Object { $_.Severity -eq 'Critical' }).Count
            
            if ($criticalCount -gt 0) {
                $findings += @{
                    Title = "üö® [SECURITY] Critical Security Vulnerabilities ($criticalCount issues)"
                    Priority = "P0-Critical"
                    Type = "security"
                    Count = $criticalCount
                    Labels = @('P0-Critical', 'security', 'vulnerability', 'automated-issue')
                    Details = $analysis.Results.UnsafeCommands | Where-Object { $_.Severity -eq 'Critical' } | Select-Object -First 5
                    Assignee = "copilot"
                }
            }
        }

        # Credential issues
        if ($analysis.Results.PlainTextCredentials.Count -gt 0) {
            $findings += @{
                Title = "üîê [SECURITY] Exposed Credentials ($($analysis.Results.PlainTextCredentials.Count) instances)"
                Priority = "P0-Critical"
                Type = "credentials"
                Count = $analysis.Results.PlainTextCredentials.Count
                Labels = @('P0-Critical', 'security', 'credentials', 'urgent', 'automated-issue')
                Details = $analysis.Results.PlainTextCredentials | Select-Object -First 5
                Assignee = "copilot"
            }
        }

        # Insecure protocols
        if ($analysis.Results.InsecureProtocols.Count -gt 0) {
            $findings += @{
                Title = "üåê [SECURITY] Insecure Protocol Usage ($($analysis.Results.InsecureProtocols.Count) instances)"
                Priority = "P1-High"
                Type = "protocols"
                Count = $analysis.Results.InsecureProtocols.Count
                Labels = @('P1-High', 'security', 'protocols', 'automated-issue')
                Details = $analysis.Results.InsecureProtocols | Select-Object -First 5
                Assignee = "copilot"
            }
        }

        return $findings
    }
    catch {
        Write-GenStatus "Error parsing security analysis: $_" "Error"
        return @()
    }
}

function New-IssueContent {
    param([hashtable]$Finding)
    
    $body = @()
    $body += "## ü§ñ Automated Issue - $($Finding.Type.ToUpper()) Analysis"
    $body += ""
    $body += "**Generated by:** AitherZero Issue Management System"
    $body += "**Analysis Date:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    $body += "**Priority:** $($Finding.Priority)"
    $body += "**Issue Count:** $($Finding.Count)"
    $body += "**Assignee:** @$($Finding.Assignee)"
    $body += ""
    
    switch ($Finding.Type) {
        'security' {
            $body += "## üîí Security Analysis Summary"
            $body += ""
            $body += "Automated security analysis has identified **$($Finding.Count) critical security vulnerabilities** that require immediate attention."
            $body += ""
            $body += "### üìä Finding Details"
            foreach ($detail in $Finding.Details) {
                $body += "- **$($detail.Severity)**: Line $($detail.Line) in ``$($detail.File)``"
                $body += "  - **Issue**: $($detail.Description)"
                $body += "  - **Context**: ``$($detail.Context)``"
                $body += ""
            }
            
            $body += "### üõ†Ô∏è Recommended Actions"
            $body += ""
            $body += "@$($Finding.Assignee) Please address these security vulnerabilities with **HIGHEST PRIORITY**:"
            $body += ""
            $body += "1. **Review each identified location** for security implications"
            $body += "2. **Replace unsafe patterns** with secure alternatives:"
            $body += "   - Replace ``Invoke-Expression`` with direct command execution"
            $body += "   - Use ``SecureString`` for credential handling"
            $body += "   - Implement proper input validation"
            $body += "3. **Test security fixes** to ensure functionality is maintained"
            $body += "4. **Run security analysis** again to verify resolution"
            $body += ""
            $body += "### üéØ Security Best Practices"
            $body += "- Avoid dynamic code execution (``Invoke-Expression``)"
            $body += "- Use secure credential storage mechanisms"
            $body += "- Implement input validation and sanitization"
            $body += "- Follow principle of least privilege"
        }
        
        'credentials' {
            $body += "## üîê Credential Security Issue"
            $body += ""
            $body += "**üö® CRITICAL SECURITY RISK**: Exposed credentials detected in source code."
            $body += ""
            $body += "### üìç Locations Found"
            foreach ($detail in $Finding.Details) {
                $body += "- ``$($detail.File):$($detail.Line)`` - $($detail.Description)"
            }
            $body += ""
            $body += "### ‚ö° IMMEDIATE Actions Required"
            $body += ""
            $body += "@$($Finding.Assignee) **URGENT - STOP EVERYTHING AND FIX THIS NOW**:"
            $body += ""
            $body += "1. **‚ùå REMOVE hardcoded credentials** from source code immediately"
            $body += "2. **üîê USE environment variables** or secure credential stores"
            $body += "3. **üîÑ ROTATE any exposed credentials** if they are real"
            $body += "4. **‚úÖ IMPLEMENT SecureString patterns** for PowerShell"
            $body += "5. **üìù ADD .gitignore entries** for credential files"
            $body += ""
            $body += "**‚ö†Ô∏è WARNING**: This is a **CRITICAL SECURITY VULNERABILITY** that could lead to:"
            $body += "- Unauthorized system access"
            $body += "- Data breaches"
            $body += "- Compliance violations"
            $body += "- Service compromises"
        }
        
        'protocols' {
            $body += "## üåê Insecure Protocol Security Issue"
            $body += ""
            $body += "**Security analysis identified $($Finding.Count) instances** of insecure protocol usage."
            $body += ""
            $body += "### üìç Issues Found"
            foreach ($detail in $Finding.Details) {
                $body += "- **$($detail.Severity)**: ``$($detail.File):$($detail.Line)``"
                $body += "  - **Issue**: $($detail.Description)"
                $body += "  - **Context**: ``$($detail.Context)``"
                $body += ""
            }
            $body += ""
            $body += "### üõ†Ô∏è Resolution Steps"
            $body += ""
            $body += "@$($Finding.Assignee) Please address these protocol security issues:"
            $body += ""
            $body += "1. **Replace HTTP with HTTPS** where possible"
            $body += "2. **Enable certificate validation** (remove `-SkipCertificateCheck`)"
            $body += "3. **Use secure communication channels** for sensitive data"
            $body += "4. **Implement proper TLS/SSL configuration**"
        }
    }
    
    $body += ""
    $body += "---"
    $body += "### üìà Impact & Priority"
    
    switch ($Finding.Priority) {
        'P0-Critical' { 
            $body += "**üö® CRITICAL**: Requires immediate attention - security risk or blocking issue"
            $body += "**Expected Resolution Time**: < 4 hours"
            $body += "**Impact**: HIGH - Could lead to security breaches or system compromise"
        }
        'P1-High' { 
            $body += "**‚ö° HIGH**: Should be resolved within 1-2 days"
            $body += "**Expected Resolution Time**: 1-2 days"
            $body += "**Impact**: MEDIUM - Could lead to security vulnerabilities"
        }
        'P2-Medium' { 
            $body += "**üîß MEDIUM**: Should be addressed in current sprint"
            $body += "**Expected Resolution Time**: 1 week"
            $body += "**Impact**: LOW - Improves security posture"
        }
    }
    
    $body += ""
    $body += "**Automation**: This issue was automatically created by AitherZero analysis system"
    $body += "**Next Analysis**: Will run again after changes are made to verify resolution"
    
    return @{
        Title = $Finding.Title
        Body = $body -join "`n"
        Labels = $Finding.Labels
        Priority = $Finding.Priority
        Assignee = $Finding.Assignee
        Type = $Finding.Type
    }
}

# Main execution
try {
    Write-GenStatus "üöÄ Starting GitHub Issue File Generation..." "Critical"
    Write-Host ""
    
    # Create output directory
    if (-not (Test-Path $OutputPath)) {
        New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
        Write-GenStatus "Created output directory: $OutputPath" "Info"
    }
    
    # Clean previous files
    Get-ChildItem -Path $OutputPath -Filter "*.md" | Remove-Item -Force
    Get-ChildItem -Path $OutputPath -Filter "*.json" | Remove-Item -Force
    
    # Get findings
    Write-GenStatus "Analyzing security findings..." "Info"
    $findings = Get-SecurityFindings -Path $AnalysisPath
    Write-GenStatus "Found $($findings.Count) security issue categories" "Success"
    
    if ($findings.Count -eq 0) {
        Write-GenStatus "‚ùå No security issues found to generate!" "Error"
        Write-GenStatus "Check that analysis has been run and results exist at: $AnalysisPath" "Info"
        exit 1
    }
    
    $issueFiles = @()
    $allIssues = @()
    
    for ($i = 0; $i -lt $findings.Count; $i++) {
        $finding = $findings[$i]
        $issueContent = New-IssueContent -Finding $finding
        $allIssues += $issueContent
        
        $fileName = "issue-$(($i + 1).ToString('00'))-$($finding.Type)"
        
        if ($Format -eq 'Files' -or $Format -eq 'Markdown') {
            # Create individual markdown files
            $mdFile = Join-Path $OutputPath "$fileName.md"
            
            $mdContent = @()
            $mdContent += "# $($issueContent.Title)"
            $mdContent += ""
            $mdContent += "**Labels**: $($issueContent.Labels -join ', ')"
            $mdContent += "**Priority**: $($issueContent.Priority)"
            $mdContent += "**Assignee**: $($issueContent.Assignee)"
            $mdContent += ""
            $mdContent += $issueContent.Body
            
            Set-Content -Path $mdFile -Value ($mdContent -join "`n") -Encoding UTF8
            $issueFiles += $mdFile
            
            Write-GenStatus "Generated: $mdFile" "Success"
        }
    }
    
    if ($Format -eq 'Files' -or $Format -eq 'JSON') {
        # Create combined JSON file for API usage
        $jsonFile = Join-Path $OutputPath "all-issues.json"
        $allIssues | ConvertTo-Json -Depth 10 | Set-Content -Path $jsonFile -Encoding UTF8
        $issueFiles += $jsonFile
        
        Write-GenStatus "Generated: $jsonFile" "Success"
    }
    
    # Create a summary script
    $summaryFile = Join-Path $OutputPath "CREATE-ISSUES.md"
    $summary = @()
    $summary += "# üö® CRITICAL: GitHub Issues Ready for Creation"
    $summary += ""
    $summary += "**Generated**: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    $summary += "**Issues Found**: $($findings.Count) categories"
    $summary += ""
    $summary += "## üî• IMMEDIATE ACTION REQUIRED"
    $summary += ""
    $summary += "The analysis has found **CRITICAL SECURITY ISSUES** that need immediate attention:"
    
    foreach ($issue in $allIssues) {
        $urgency = if ($issue.Priority -eq 'P0-Critical') { "üö® **CRITICAL**" } else { "‚ö° **HIGH**" }
        $summary += "- $urgency $($issue.Title)"
    }
    
    $summary += ""
    $summary += "## üìã How to Create These Issues"
    $summary += ""
    $summary += "### Option 1: Manual Creation (Recommended)"
    $summary += "1. Go to: https://github.com/wizzense/AitherZero/issues/new"
    $summary += "2. Copy content from individual .md files in this directory"
    $summary += "3. Create each issue with appropriate labels and assignee"
    $summary += ""
    $summary += "### Option 2: GitHub CLI (if available)"
    $summary += '```bash'
    
    for ($i = 0; $i -lt $allIssues.Count; $i++) {
        $issue = $allIssues[$i]
        $fileName = "issue-$(($i + 1).ToString('00'))-$($issue.Type).md"
        $labelString = $issue.Labels -join ','
        $summary += "gh issue create --title `"$($issue.Title)`" --body-file `"$fileName`" --label `"$labelString`" --assignee $($issue.Assignee)"
    }
    
    $summary += '```'
    $summary += ""
    $summary += "### Option 3: GitHub API"
    $summary += "Use the all-issues.json file with GitHub's REST API"
    $summary += ""
    $summary += "## üéØ Priority Order"
    $summary += "1. **P0-Critical**: Fix immediately (< 4 hours)"
    $summary += "2. **P1-High**: Fix within 1-2 days"  
    $summary += "3. **P2-Medium**: Fix within 1 week"
    
    Set-Content -Path $summaryFile -Value ($summary -join "`n") -Encoding UTF8
    
    Write-Host ""
    Write-GenStatus "‚úÖ Issue Generation Complete!" "Success"
    Write-Host ""
    Write-GenStatus "üìÅ Generated Files:" "Info"
    foreach ($file in $issueFiles) {
        Write-Host "  ‚Ä¢ $(Split-Path $file -Leaf)" -ForegroundColor White
    }
    Write-Host "  ‚Ä¢ CREATE-ISSUES.md (üìã Instructions)" -ForegroundColor Yellow
    
    Write-Host ""
    Write-GenStatus "üö® NEXT STEPS:" "Critical"
    Write-Host "1. Open: $summaryFile" -ForegroundColor Red
    Write-Host "2. Follow instructions to create GitHub issues" -ForegroundColor Red
    Write-Host "3. Prioritize P0-Critical issues first!" -ForegroundColor Red
    
    exit 0
}
catch {
    Write-GenStatus "‚ùå Generation failed: $_" "Error"
    Write-Host $_.ScriptStackTrace -ForegroundColor Red
    exit 1
}

