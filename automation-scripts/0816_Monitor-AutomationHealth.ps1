#Requires -Version 7.0
<#
.SYNOPSIS
    Monitors the health and effectiveness of the automated copilot agent system
.DESCRIPTION
    Tracks automated issue creation, PR generation, resolution rates, and system performance
.PARAMETER OutputFormat
    Format for output (Console, JSON, HTML)
.PARAMETER SaveReport
    Save detailed report to file
.PARAMETER Days
    Number of days to analyze (default: 7)
#>
[CmdletBinding()]
param(
    [ValidateSet('Console', 'JSON', 'HTML')]
    [string]$OutputFormat = 'Console',
    
    [switch]$SaveReport,
    
    [ValidateRange(1, 90)]
    [int]$Days = 7
)

# Script metadata
$scriptInfo = @{
    Stage = 'Monitoring'
    Number = '0815'
    Name = 'Monitor-AutomationHealth'
    Description = 'Monitors automated copilot agent system health and metrics'
    Dependencies = @('gh', 'git')
    Tags = @('monitoring', 'automation', 'analytics', 'copilot')
    RequiresAdmin = $false
}

# Initialize logging
$script:LoggingAvailable = $false
try {
    $loggingPath = Join-Path (Split-Path $PSScriptRoot -Parent) "domains/utilities/Logging.psm1"
    if (Test-Path $loggingPath) {
        Import-Module $loggingPath -Force -Global
        $script:LoggingAvailable = $true
    }
} catch {
    # Fallback to basic output
}

function Write-ScriptLog {
    param(
        [string]$Message,
        [string]$Level = 'Information'
    )

    if (Get-Command Write-CustomLog -ErrorAction SilentlyContinue) {
        Write-CustomLog -Message $Message -Level $Level
    } else {
        $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        $prefix = switch ($Level) {
            'Error' { 'ERROR' }
            'Warning' { 'WARN' }
            'Debug' { 'DEBUG' }
            default { 'INFO' }
        }
        Write-Host "[$timestamp] [$prefix] $Message"
    }
}

function Get-AutomationMetrics {
    <#
    .SYNOPSIS
        Collects metrics about the automated copilot agent system
    #>
    param(
        [int]$DaysToAnalyze = 7
    )
    
    Write-ScriptLog "Collecting automation metrics for the last $DaysToAnalyze days"
    
    $metrics = @{
        Period = @{
            Days = $DaysToAnalyze
            StartDate = (Get-Date).AddDays(-$DaysToAnalyze).ToString('yyyy-MM-dd')
            EndDate = (Get-Date).ToString('yyyy-MM-dd')
        }
        Issues = @{
            AutoCreated = 0
            CopilotAssigned = 0
            Resolved = 0
            OpenCritical = 0
            AverageResolutionHours = 0
        }
        PullRequests = @{
            AutoGenerated = 0
            Merged = 0
            Closed = 0
            AverageMergeHours = 0
        }
        WorkflowRuns = @{
            AutomatedAgent = 0
            PRAutomation = 0
            SuccessRate = 0
        }
        Health = @{
            SystemStatus = 'Unknown'
            LastAnalysis = $null
            ActiveIssues = 0
            RecentActivity = $false
        }
        Trends = @{
            IssueCreationTrend = 'Unknown'
            ResolutionTrend = 'Unknown'
            EfficiencyTrend = 'Unknown'
        }
    }
    
    try {
        # Check if GitHub CLI is available
        $ghAvailable = Get-Command gh -ErrorAction SilentlyContinue
        if (-not $ghAvailable) {
            Write-ScriptLog "GitHub CLI not available - using mock data for demonstration" -Level Warning
            return Get-MockMetrics -Days $DaysToAnalyze
        }
        
        # Get automated issues (created by workflows)
        Write-ScriptLog "Analyzing automated issues..."
        $autoIssuesJson = gh api repos/:owner/:repo/issues -f state=all -f labels=auto-created -f since=(Get-Date).AddDays(-$DaysToAnalyze).ToString('yyyy-MM-ddTHH:mm:ssZ') --paginate 2>$null
        
        if ($autoIssuesJson) {
            $autoIssues = $autoIssuesJson | ConvertFrom-Json
            $metrics.Issues.AutoCreated = $autoIssues.Count
            
            # Count copilot-assigned issues
            $copilotIssues = $autoIssues | Where-Object { $_.assignees | Where-Object { $_.login -eq 'copilot' } }
            $metrics.Issues.CopilotAssigned = $copilotIssues.Count
            
            # Count resolved issues
            $resolvedIssues = $autoIssues | Where-Object { $_.state -eq 'closed' }
            $metrics.Issues.Resolved = $resolvedIssues.Count
            
            # Count open critical issues
            $criticalIssues = $autoIssues | Where-Object { 
                $_.state -eq 'open' -and ($_.labels | Where-Object { $_.name -match 'critical|P0' })
            }
            $metrics.Issues.OpenCritical = $criticalIssues.Count
            
            # Calculate average resolution time
            if ($resolvedIssues.Count -gt 0) {
                $resolutionTimes = $resolvedIssues | ForEach-Object {
                    if ($_.closed_at -and $_.created_at) {
                        $created = [DateTime]::Parse($_.created_at)
                        $closed = [DateTime]::Parse($_.closed_at)
                        ($closed - $created).TotalHours
                    }
                } | Where-Object { $_ -ne $null }
                
                if ($resolutionTimes.Count -gt 0) {
                    $metrics.Issues.AverageResolutionHours = [Math]::Round(($resolutionTimes | Measure-Object -Average).Average, 1)
                }
            }
        }
        
        # Get automated PRs
        Write-ScriptLog "Analyzing automated pull requests..."
        $autoPRsJson = gh api repos/:owner/:repo/pulls -f state=all -f since=(Get-Date).AddDays(-$DaysToAnalyze).ToString('yyyy-MM-ddTHH:mm:ssZ') --paginate 2>$null
        
        if ($autoPRsJson) {
            $allPRs = $autoPRsJson | ConvertFrom-Json
            $autoPRs = $allPRs | Where-Object { 
                $_.title -match 'Automated fix|ü§ñ' -or 
                ($_.labels | Where-Object { $_.name -match 'automated-fix|copilot-generated' })
            }
            
            $metrics.PullRequests.AutoGenerated = $autoPRs.Count
            $metrics.PullRequests.Merged = ($autoPRs | Where-Object { $_.merged_at }).Count
            $metrics.PullRequests.Closed = ($autoPRs | Where-Object { $_.state -eq 'closed' }).Count
            
            # Calculate average merge time
            $mergedPRs = $autoPRs | Where-Object { $_.merged_at }
            if ($mergedPRs.Count -gt 0) {
                $mergeTimes = $mergedPRs | ForEach-Object {
                    if ($_.merged_at -and $_.created_at) {
                        $created = [DateTime]::Parse($_.created_at)
                        $merged = [DateTime]::Parse($_.merged_at)
                        ($merged - $created).TotalHours
                    }
                } | Where-Object { $_ -ne $null }
                
                if ($mergeTimes.Count -gt 0) {
                    $metrics.PullRequests.AverageMergeHours = [Math]::Round(($mergeTimes | Measure-Object -Average).Average, 1)
                }
            }
        }
        
        # Get workflow runs
        Write-ScriptLog "Analyzing workflow runs..."
        $workflowsJson = gh api repos/:owner/:repo/actions/runs -f created=">{0}" -f created="<{1}" --paginate 2>$null -f (Get-Date).AddDays(-$DaysToAnalyze).ToString('yyyy-MM-dd') -f (Get-Date).ToString('yyyy-MM-dd')
        
        if ($workflowsJson) {
            $workflows = $workflowsJson | ConvertFrom-Json
            $automatedWorkflows = $workflows.workflow_runs | Where-Object { 
                $_.name -match 'Automated Copilot|Copilot PR Automation'
            }
            
            $metrics.WorkflowRuns.AutomatedAgent = ($automatedWorkflows | Where-Object { $_.name -match 'Automated Copilot' }).Count
            $metrics.WorkflowRuns.PRAutomation = ($automatedWorkflows | Where-Object { $_.name -match 'PR Automation' }).Count
            
            if ($automatedWorkflows.Count -gt 0) {
                $successfulRuns = $automatedWorkflows | Where-Object { $_.conclusion -eq 'success' }
                $metrics.WorkflowRuns.SuccessRate = [Math]::Round(($successfulRuns.Count / $automatedWorkflows.Count) * 100, 1)
            }
        }
        
        # Determine system health
        $metrics.Health.LastAnalysis = Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC'
        $metrics.Health.ActiveIssues = $metrics.Issues.CopilotAssigned - $metrics.Issues.Resolved
        $metrics.Health.RecentActivity = ($metrics.Issues.AutoCreated -gt 0) -or ($metrics.PullRequests.AutoGenerated -gt 0)
        
        # Determine overall system status
        if ($metrics.Issues.OpenCritical -gt 5) {
            $metrics.Health.SystemStatus = 'Critical'
        } elseif ($metrics.Issues.OpenCritical -gt 2 -or $metrics.WorkflowRuns.SuccessRate -lt 80) {
            $metrics.Health.SystemStatus = 'Warning'
        } elseif ($metrics.Health.RecentActivity -and $metrics.WorkflowRuns.SuccessRate -gt 90) {
            $metrics.Health.SystemStatus = 'Healthy'
        } else {
            $metrics.Health.SystemStatus = 'Monitoring'
        }
        
        # Calculate trends (simplified - would need historical data for real trends)
        $metrics.Trends.IssueCreationTrend = if ($metrics.Issues.AutoCreated -gt ($DaysToAnalyze * 0.5)) { 'High' } elseif ($metrics.Issues.AutoCreated -gt 0) { 'Moderate' } else { 'Low' }
        $metrics.Trends.ResolutionTrend = if ($metrics.Issues.Resolved -ge $metrics.Issues.AutoCreated * 0.8) { 'Excellent' } elseif ($metrics.Issues.Resolved -ge $metrics.Issues.AutoCreated * 0.5) { 'Good' } else { 'Needs Improvement' }
        $metrics.Trends.EfficiencyTrend = if ($metrics.Issues.AverageResolutionHours -le 4) { 'Excellent' } elseif ($metrics.Issues.AverageResolutionHours -le 24) { 'Good' } else { 'Needs Improvement' }
        
    } catch {
        Write-ScriptLog "Error collecting metrics: $($_.Exception.Message)" -Level Error
        return Get-MockMetrics -Days $DaysToAnalyze
    }
    
    return $metrics
}

function Get-MockMetrics {
    param([int]$Days = 7)
    
    # Return mock data for demonstration when GitHub CLI is not available
    return @{
        Period = @{
            Days = $Days
            StartDate = (Get-Date).AddDays(-$Days).ToString('yyyy-MM-dd')
            EndDate = (Get-Date).ToString('yyyy-MM-dd')
        }
        Issues = @{
            AutoCreated = 12
            CopilotAssigned = 12
            Resolved = 9
            OpenCritical = 1
            AverageResolutionHours = 3.2
        }
        PullRequests = @{
            AutoGenerated = 8
            Merged = 7
            Closed = 8
            AverageMergeHours = 1.8
        }
        WorkflowRuns = @{
            AutomatedAgent = 14
            PRAutomation = 8
            SuccessRate = 92.3
        }
        Health = @{
            SystemStatus = 'Healthy'
            LastAnalysis = Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC'
            ActiveIssues = 3
            RecentActivity = $true
        }
        Trends = @{
            IssueCreationTrend = 'Moderate'
            ResolutionTrend = 'Good'
            EfficiencyTrend = 'Excellent'
        }
    }
}

function Format-ConsoleOutput {
    param([hashtable]$Metrics)
    
    Write-Host ""
    Write-Host "ü§ñ " -NoNewline -ForegroundColor Cyan
    Write-Host "AitherZero Automated Copilot Agent System Health Report" -ForegroundColor White
    Write-Host "=" * 70 -ForegroundColor Gray
    
    # System Status
    $statusColor = switch ($Metrics.Health.SystemStatus) {
        'Healthy' { 'Green' }
        'Warning' { 'Yellow' }
        'Critical' { 'Red' }
        default { 'Gray' }
    }
    Write-Host "üìä Overall System Status: " -NoNewline -ForegroundColor White
    Write-Host $Metrics.Health.SystemStatus -ForegroundColor $statusColor
    Write-Host "üìÖ Analysis Period: $($Metrics.Period.StartDate) to $($Metrics.Period.EndDate) ($($Metrics.Period.Days) days)" -ForegroundColor Gray
    Write-Host "üïí Last Analysis: $($Metrics.Health.LastAnalysis)" -ForegroundColor Gray
    Write-Host ""
    
    # Issue Metrics
    Write-Host "üìã Issue Management Metrics:" -ForegroundColor Cyan
    Write-Host "  ‚ú® Auto-Created Issues: $($Metrics.Issues.AutoCreated)" -ForegroundColor White
    Write-Host "  üë§ Copilot Assigned: $($Metrics.Issues.CopilotAssigned)" -ForegroundColor White
    Write-Host "  ‚úÖ Resolved: $($Metrics.Issues.Resolved)" -ForegroundColor Green
    Write-Host "  üö® Open Critical: $($Metrics.Issues.OpenCritical)" -ForegroundColor $(if($Metrics.Issues.OpenCritical -gt 0) {'Red'} else {'Green'})
    Write-Host "  ‚è±Ô∏è  Avg Resolution Time: $($Metrics.Issues.AverageResolutionHours) hours" -ForegroundColor White
    
    # Calculate resolution rate
    $resolutionRate = if ($Metrics.Issues.AutoCreated -gt 0) { 
        [Math]::Round(($Metrics.Issues.Resolved / $Metrics.Issues.AutoCreated) * 100, 1) 
    } else { 0 }
    Write-Host "  üìà Resolution Rate: $resolutionRate%" -ForegroundColor $(if($resolutionRate -gt 80) {'Green'} elseif($resolutionRate -gt 50) {'Yellow'} else {'Red'})
    Write-Host ""
    
    # PR Metrics
    Write-Host "üîÑ Pull Request Automation:" -ForegroundColor Cyan
    Write-Host "  ü§ñ Auto-Generated PRs: $($Metrics.PullRequests.AutoGenerated)" -ForegroundColor White
    Write-Host "  ‚úÖ Merged: $($Metrics.PullRequests.Merged)" -ForegroundColor Green
    Write-Host "  üìù Closed: $($Metrics.PullRequests.Closed)" -ForegroundColor White
    Write-Host "  ‚è±Ô∏è  Avg Merge Time: $($Metrics.PullRequests.AverageMergeHours) hours" -ForegroundColor White
    
    # Calculate merge rate
    $mergeRate = if ($Metrics.PullRequests.AutoGenerated -gt 0) { 
        [Math]::Round(($Metrics.PullRequests.Merged / $Metrics.PullRequests.AutoGenerated) * 100, 1) 
    } else { 0 }
    Write-Host "  üìà Merge Rate: $mergeRate%" -ForegroundColor $(if($mergeRate -gt 80) {'Green'} elseif($mergeRate -gt 50) {'Yellow'} else {'Red'})
    Write-Host ""
    
    # Workflow Metrics
    Write-Host "‚öôÔ∏è  Workflow Automation:" -ForegroundColor Cyan
    Write-Host "  üîç Agent Runs: $($Metrics.WorkflowRuns.AutomatedAgent)" -ForegroundColor White
    Write-Host "  üîÑ PR Automation Runs: $($Metrics.WorkflowRuns.PRAutomation)" -ForegroundColor White
    Write-Host "  ‚úÖ Success Rate: $($Metrics.WorkflowRuns.SuccessRate)%" -ForegroundColor $(if($Metrics.WorkflowRuns.SuccessRate -gt 90) {'Green'} elseif($Metrics.WorkflowRuns.SuccessRate -gt 70) {'Yellow'} else {'Red'})
    Write-Host ""
    
    # Trends
    Write-Host "üìà System Trends:" -ForegroundColor Cyan
    Write-Host "  üìã Issue Creation: $($Metrics.Trends.IssueCreationTrend)" -ForegroundColor White
    Write-Host "  ‚úÖ Resolution Efficiency: $($Metrics.Trends.ResolutionTrend)" -ForegroundColor White
    Write-Host "  ‚ö° Processing Speed: $($Metrics.Trends.EfficiencyTrend)" -ForegroundColor White
    Write-Host ""
    
    # System Health Details
    Write-Host "üí° Health Insights:" -ForegroundColor Cyan
    Write-Host "  üîÑ Recent Activity: $(if($Metrics.Health.RecentActivity) {'Active'} else {'Quiet'})" -ForegroundColor $(if($Metrics.Health.RecentActivity) {'Green'} else {'Yellow'})
    Write-Host "  üìä Active Issues: $($Metrics.Health.ActiveIssues)" -ForegroundColor White
    
    # Recommendations
    Write-Host ""
    Write-Host "üéØ Recommendations:" -ForegroundColor Yellow
    
    if ($Metrics.Issues.OpenCritical -gt 0) {
        Write-Host "  ‚ö†Ô∏è  Address $($Metrics.Issues.OpenCritical) critical issue(s) immediately" -ForegroundColor Red
    }
    
    if ($resolutionRate -lt 50) {
        Write-Host "  üìà Improve issue resolution rate (currently $resolutionRate%)" -ForegroundColor Yellow
    }
    
    if ($Metrics.WorkflowRuns.SuccessRate -lt 90) {
        Write-Host "  üîß Investigate workflow failures (success rate: $($Metrics.WorkflowRuns.SuccessRate)%)" -ForegroundColor Yellow
    }
    
    if ($Metrics.Issues.AverageResolutionHours -gt 8) {
        Write-Host "  ‚è∞ Optimize resolution time (currently $($Metrics.Issues.AverageResolutionHours) hours)" -ForegroundColor Yellow
    }
    
    if ($Metrics.Health.SystemStatus -eq 'Healthy' -and $Metrics.WorkflowRuns.SuccessRate -gt 90) {
        Write-Host "  ‚úÖ System is operating efficiently - continue monitoring" -ForegroundColor Green
    }
}

function Export-Report {
    param(
        [hashtable]$Metrics,
        [string]$Format = 'JSON'
    )
    
    $timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'
    $filename = "automation-health-report-$timestamp"
    
    switch ($Format) {
        'JSON' {
            $filepath = "$filename.json"
            $Metrics | ConvertTo-Json -Depth 10 | Set-Content $filepath -Encoding UTF8
            Write-ScriptLog "Report saved to: $filepath"
        }
        'HTML' {
            $filepath = "$filename.html"
            # Generate HTML report (simplified version)
            $html = @"
<!DOCTYPE html>
<html>
<head>
    <title>AitherZero Automation Health Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { color: #2E86AB; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .metric { margin: 10px 0; padding: 10px; background: #f5f5f5; border-left: 4px solid #2E86AB; }
        .status-healthy { color: #28a745; }
        .status-warning { color: #ffc107; }
        .status-critical { color: #dc3545; }
    </style>
</head>
<body>
    <h1 class="header">ü§ñ AitherZero Automation Health Report</h1>
    <p><strong>Generated:</strong> $(Get-Date)</p>
    <p><strong>Period:</strong> $($Metrics.Period.Days) days ($($Metrics.Period.StartDate) to $($Metrics.Period.EndDate))</p>
    
    <div class="metric">
        <h3>System Status: <span class="status-$($Metrics.Health.SystemStatus.ToLower())">$($Metrics.Health.SystemStatus)</span></h3>
    </div>
    
    <div class="metric">
        <h3>Issue Management</h3>
        <ul>
            <li>Auto-Created: $($Metrics.Issues.AutoCreated)</li>
            <li>Resolved: $($Metrics.Issues.Resolved)</li>
            <li>Open Critical: $($Metrics.Issues.OpenCritical)</li>
            <li>Avg Resolution: $($Metrics.Issues.AverageResolutionHours) hours</li>
        </ul>
    </div>
    
    <div class="metric">
        <h3>PR Automation</h3>
        <ul>
            <li>Generated: $($Metrics.PullRequests.AutoGenerated)</li>
            <li>Merged: $($Metrics.PullRequests.Merged)</li>
            <li>Avg Merge Time: $($Metrics.PullRequests.AverageMergeHours) hours</li>
        </ul>
    </div>
    
    <div class="metric">
        <h3>Workflow Performance</h3>
        <ul>
            <li>Success Rate: $($Metrics.WorkflowRuns.SuccessRate)%</li>
            <li>Agent Runs: $($Metrics.WorkflowRuns.AutomatedAgent)</li>
            <li>PR Automation: $($Metrics.WorkflowRuns.PRAutomation)</li>
        </ul>
    </div>
</body>
</html>
"@
            $html | Set-Content $filepath -Encoding UTF8
            Write-ScriptLog "HTML report saved to: $filepath"
        }
    }
    
    return $filepath
}

# Main execution
try {
    Write-ScriptLog "Starting automated copilot agent system health analysis"
    
    # Collect metrics
    $metrics = Get-AutomationMetrics -DaysToAnalyze $Days
    
    # Output results
    switch ($OutputFormat) {
        'Console' {
            Format-ConsoleOutput -Metrics $metrics
        }
        'JSON' {
            $metrics | ConvertTo-Json -Depth 10
        }
        'HTML' {
            # Would generate HTML output here
            Write-ScriptLog "HTML output format not yet implemented for console display" -Level Warning
            Format-ConsoleOutput -Metrics $metrics
        }
    }
    
    # Save report if requested
    if ($SaveReport) {
        $reportPath = Export-Report -Metrics $metrics -Format $OutputFormat
        Write-ScriptLog "Report saved successfully: $reportPath"
    }
    
    # Return system status for use in other scripts
    return $metrics.Health.SystemStatus
    
} catch {
    Write-ScriptLog "Fatal error in automation health monitoring: $($_.Exception.Message)" -Level Error
    Write-ScriptLog "Stack trace: $($_.ScriptStackTrace)" -Level Debug
    exit 1
}