# Track-DocumentationState.ps1 - Smart Documentation State Tracking System
# Part of AitherZero Smart Documentation Automation

[CmdletBinding()]
param(
    [Parameter(Mandatory = $false)]
    [string]$StateFilePath = ".github/documentation-state.json",

    [Parameter(Mandatory = $false)]
    [string]$ProjectRoot = (Get-Location),

    [Parameter(Mandatory = $false)]
    [switch]$Initialize,

    [Parameter(Mandatory = $false)]
    [switch]$Analyze,

    [Parameter(Mandatory = $false)]
    [switch]$Export
)

# Find project root if not specified
if (-not (Test-Path $ProjectRoot)) {
    . "$PSScriptRoot/../../aither-core/shared/Find-ProjectRoot.ps1"
    $ProjectRoot = Find-ProjectRoot
}

# Import logging if available
if (Test-Path "$ProjectRoot/aither-core/modules/Logging") {
    Import-Module "$ProjectRoot/aither-core/modules/Logging" -Force -ErrorAction SilentlyContinue
}

function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    if (Get-Command Write-CustomLog -ErrorAction SilentlyContinue) {
        Write-CustomLog -Message $Message -Level $Level
    } else {
        Write-Host "[$Level] $Message" -ForegroundColor $(if($Level -eq "ERROR"){"Red"} elseif($Level -eq "WARN"){"Yellow"} else{"Green"})
    }
}

function Initialize-DocumentationState {
    <#
    .SYNOPSIS
    Initializes a new documentation state tracking file

    .DESCRIPTION
    Creates the initial state file with default schema and scans existing documentation
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$StateFilePath,

        [Parameter(Mandatory = $true)]
        [string]$ProjectRoot
    )

    Write-Log "Initializing documentation state tracking..." -Level "INFO"

    # Create directory if it doesn't exist
    $stateDir = Split-Path $StateFilePath -Parent
    if (-not (Test-Path $stateDir)) {
        New-Item -ItemType Directory -Path $stateDir -Force | Out-Null
    }

    # Initialize state schema
    $initialState = @{
        version = "1.0"
        lastScan = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
        configuration = @{
            changeThresholds = @{
                characterDeltaPercent = 20
                staleDays = 30
                codeChangeReviewDays = 7
                minSignificantChange = 100
            }
            autoGeneration = @{
                enabled = $true
                maxPerRun = 5
                requireApproval = $false
            }
            reviewFlagging = @{
                createIssues = $true
                labels = @("documentation", "review-needed", "auto-flagged")
            }
        }
        directories = @{}
        statistics = @{
            totalDirectories = 0
            directoriesWithReadmes = 0
            lastReviewCount = 0
            lastAutoGenerated = 0
        }
    }

    # Scan existing documentation
    $directories = Get-ChildItem -Path $ProjectRoot -Directory -Recurse | Where-Object {
        $_.FullName -notmatch '(\.git|node_modules|\.vscode|bin|obj|target)'
    }

    Write-Log "Scanning $($directories.Count) directories for existing documentation..." -Level "INFO"

    foreach ($dir in $directories) {
        $relativePath = $dir.FullName.Replace($ProjectRoot, "").Replace("\", "/")
        if (-not $relativePath.StartsWith("/")) {
            $relativePath = "/$relativePath"
        }

        $readmePath = Join-Path $dir.FullName "README.md"
        $directoryState = @{
            readmeExists = Test-Path $readmePath
            readmeLastModified = if (Test-Path $readmePath) { (Get-Item $readmePath).LastWriteTime.ToString("yyyy-MM-ddTHH:mm:ssZ") } else { $null }
            lastContentScan = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
            totalCharCount = 0
            fileCount = 0
            changesSinceLastReadme = $false
            contentDeltaPercent = 0
            reviewStatus = "unknown"
            flaggedForReview = $false
            lastAutoGenerated = $null
            directoryType = Get-DirectoryType -Path $dir.FullName -ProjectRoot $ProjectRoot
        }

        # Calculate initial content metrics
        try {
            $files = Get-ChildItem -Path $dir.FullName -File -Recurse -ErrorAction SilentlyContinue
            $directoryState.fileCount = $files.Count

            if ($files.Count -gt 0) {
                $totalChars = 0
                foreach ($file in $files) {
                    if ($file.Extension -in @('.ps1', '.psm1', '.psd1', '.md', '.txt', '.json', '.yaml', '.yml', '.tf')) {
                        try {
                            $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
                            if ($content) {
                                $totalChars += $content.Length
                            }
                        } catch {
                            # Skip files that can't be read
                        }
                    }
                }
                $directoryState.totalCharCount = $totalChars
            }
        } catch {
            Write-Log "Warning: Could not analyze content for $relativePath - $($_.Exception.Message)" -Level "WARN"
        }

        # Set initial review status
        if ($directoryState.readmeExists) {
            $readmeAge = (Get-Date) - [DateTime]::Parse($directoryState.readmeLastModified)
            if ($readmeAge.Days -gt 30) {
                $directoryState.reviewStatus = "stale"
                $directoryState.flaggedForReview = $true
            } else {
                $directoryState.reviewStatus = "current"
            }
        } else {
            $directoryState.reviewStatus = "missing"
            $directoryState.flaggedForReview = $true
        }

        $initialState.directories[$relativePath] = $directoryState
    }

    # Update statistics
    $initialState.statistics.totalDirectories = $initialState.directories.Count
    $initialState.statistics.directoriesWithReadmes = ($initialState.directories.Values | Where-Object { $_.readmeExists }).Count
    $initialState.statistics.lastReviewCount = ($initialState.directories.Values | Where-Object { $_.flaggedForReview }).Count

    # Save state file
    $initialState | ConvertTo-Json -Depth 10 | Set-Content -Path $StateFilePath -Encoding UTF8

    Write-Log "Documentation state initialized: $($initialState.statistics.totalDirectories) directories, $($initialState.statistics.directoriesWithReadmes) with READMEs, $($initialState.statistics.lastReviewCount) flagged for review" -Level "SUCCESS"

    return $initialState
}

function Get-DirectoryType {
    <#
    .SYNOPSIS
    Determines the type of directory for documentation templating
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path,

        [Parameter(Mandatory = $true)]
        [string]$ProjectRoot
    )

    $relativePath = $Path.Replace($ProjectRoot, "").Replace("\", "/")

    # Determine directory type based on path patterns
    if ($relativePath -match "/aither-core/modules/([^/]+)$") {
        return "powershell-module"
    } elseif ($relativePath -match "/opentofu/") {
        return "infrastructure"
    } elseif ($relativePath -match "/configs/") {
        return "configuration"
    } elseif ($relativePath -match "/scripts/") {
        return "scripts"
    } elseif ($relativePath -match "/tests/") {
        return "tests"
    } elseif ($relativePath -match "/build/") {
        return "build"
    } elseif ($relativePath -match "/(\.github|\.vscode)/") {
        return "tooling"
    } else {
        return "generic"
    }
}

function Get-DocumentationState {
    <#
    .SYNOPSIS
    Loads the current documentation state from file
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$StateFilePath
    )

    if (-not (Test-Path $StateFilePath)) {
        Write-Log "State file not found: $StateFilePath" -Level "WARN"
        return $null
    }

    try {
        $content = Get-Content -Path $StateFilePath -Raw -Encoding UTF8
        $state = $content | ConvertFrom-Json -AsHashtable
        Write-Log "Loaded documentation state: $($state.directories.Count) directories tracked" -Level "INFO"
        return $state
    } catch {
        Write-Log "Error loading state file: $($_.Exception.Message)" -Level "ERROR"
        return $null
    }
}

function Update-DocumentationState {
    <#
    .SYNOPSIS
    Updates the documentation state with current analysis
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$State,

        [Parameter(Mandatory = $true)]
        [string]$StateFilePath,

        [Parameter(Mandatory = $true)]
        [string]$ProjectRoot
    )

    Write-Log "Updating documentation state..." -Level "INFO"

    $scanTime = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
    $State.lastScan = $scanTime

    # Reset counters
    $reviewCount = 0
    $autoGenerated = 0
    $totalWithReadmes = 0

    foreach ($dirPath in $State.directories.Keys) {
        $dirState = $State.directories[$dirPath]
        $fullPath = Join-Path $ProjectRoot $dirPath.TrimStart('/')

        if (Test-Path $fullPath) {
            # Update scan time
            $dirState.lastContentScan = $scanTime

            # Check README status
            $readmePath = Join-Path $fullPath "README.md"
            $readmeExists = Test-Path $readmePath

            if ($readmeExists -and -not $dirState.readmeExists) {
                # README was created
                $dirState.readmeExists = $true
                $dirState.readmeLastModified = (Get-Item $readmePath).LastWriteTime.ToString("yyyy-MM-ddTHH:mm:ssZ")
                $dirState.reviewStatus = "current"
                $dirState.flaggedForReview = $false
                Write-Log "README created for $dirPath" -Level "SUCCESS"
            } elseif ($readmeExists) {
                # Update README timestamp if it changed
                $currentModified = (Get-Item $readmePath).LastWriteTime.ToString("yyyy-MM-ddTHH:mm:ssZ")
                if ($currentModified -ne $dirState.readmeLastModified) {
                    $dirState.readmeLastModified = $currentModified
                    $dirState.reviewStatus = "current"
                    $dirState.flaggedForReview = $false
                    Write-Log "README updated for $dirPath" -Level "INFO"
                }
            }

            # Update counters
            if ($readmeExists) { $totalWithReadmes++ }
            if ($dirState.flaggedForReview) { $reviewCount++ }
            if ($dirState.lastAutoGenerated) { $autoGenerated++ }
        }
    }

    # Update statistics
    $State.statistics.directoriesWithReadmes = $totalWithReadmes
    $State.statistics.lastReviewCount = $reviewCount
    $State.statistics.lastAutoGenerated = $autoGenerated

    # Save updated state
    try {
        $State | ConvertTo-Json -Depth 10 | Set-Content -Path $StateFilePath -Encoding UTF8
        Write-Log "Documentation state updated successfully" -Level "SUCCESS"
    } catch {
        Write-Log "Error saving state file: $($_.Exception.Message)" -Level "ERROR"
        throw
    }
}

function Export-DocumentationReport {
    <#
    .SYNOPSIS
    Exports a human-readable documentation report
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$State,

        [Parameter(Mandatory = $false)]
        [string]$OutputPath = "documentation-report.md"
    )

    Write-Log "Generating documentation report..." -Level "INFO"

    $report = @"
# Documentation State Report

**Generated:** $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
**Last Scan:** $($State.lastScan)

## Summary Statistics

- **Total Directories:** $($State.statistics.totalDirectories)
- **With READMEs:** $($State.statistics.directoriesWithReadmes)
- **Coverage:** $([math]::Round($State.statistics.directoriesWithReadmes / $State.statistics.totalDirectories * 100, 1))%
- **Flagged for Review:** $($State.statistics.lastReviewCount)
- **Auto-Generated:** $($State.statistics.lastAutoGenerated)

## Directory Status

| Directory | Type | README | Status | Last Modified |
|-----------|------|--------|--------|---------------|
"@

    foreach ($dirPath in ($State.directories.Keys | Sort-Object)) {
        $dirState = $State.directories[$dirPath]
        $readmeStatus = if ($dirState.readmeExists) { "✅" } else { "❌" }
        $status = switch ($dirState.reviewStatus) {
            "current" { "✅ Current" }
            "stale" { "⚠️ Stale" }
            "missing" { "❌ Missing" }
            default { "❓ Unknown" }
        }
        $lastModified = if ($dirState.readmeLastModified) {
            ([DateTime]::Parse($dirState.readmeLastModified)).ToString("yyyy-MM-dd")
        } else {
            "N/A"
        }

        $report += "`n| $dirPath | $($dirState.directoryType) | $readmeStatus | $status | $lastModified |"
    }

    $report += @"

## Flagged for Review

"@

    $flaggedDirs = $State.directories.GetEnumerator() | Where-Object { $_.Value.flaggedForReview }
    if ($flaggedDirs.Count -gt 0) {
        foreach ($dir in $flaggedDirs) {
            $reason = switch ($dir.Value.reviewStatus) {
                "missing" { "Missing README" }
                "stale" { "README older than 30 days" }
                default { "Unknown reason" }
            }
            $report += "`n- **$($dir.Key)** - $reason"
        }
    } else {
        $report += "`nNo directories flagged for review."
    }

    $report += @"

## Configuration

- **Character Delta Threshold:** $($State.configuration.changeThresholds.characterDeltaPercent)%
- **Stale Threshold:** $($State.configuration.changeThresholds.staleDays) days
- **Auto-Generation:** $($State.configuration.autoGeneration.enabled)
- **Max Auto-Gen per Run:** $($State.configuration.autoGeneration.maxPerRun)

"@

    Set-Content -Path $OutputPath -Value $report -Encoding UTF8
    Write-Log "Documentation report exported to: $OutputPath" -Level "SUCCESS"
}

# Main execution
try {
    $stateFilePath = Join-Path $ProjectRoot $StateFilePath

    if ($Initialize) {
        $state = Initialize-DocumentationState -StateFilePath $stateFilePath -ProjectRoot $ProjectRoot
    } else {
        $state = Get-DocumentationState -StateFilePath $stateFilePath

        if (-not $state) {
            Write-Log "No existing state found. Run with -Initialize to create initial state." -Level "WARN"
            exit 1
        }

        if ($Analyze) {
            Update-DocumentationState -State $state -StateFilePath $stateFilePath -ProjectRoot $ProjectRoot
        }
    }

    if ($Export) {
        Export-DocumentationReport -State $state -OutputPath (Join-Path $ProjectRoot "documentation-report.md")
    }

    Write-Log "Documentation state tracking completed successfully" -Level "SUCCESS"

} catch {
    Write-Log "Documentation state tracking failed: $($_.Exception.Message)" -Level "ERROR"
    exit 1
}
