name: Enhanced CI 2025 - AI-Native Build & Test Pipeline

on:
  push:
    branches: [ main, develop, 'release/**', 'feature/**' ]
  pull_request:
    branches: [ main, develop ]
  merge_group:
    types: [checks_requested]
  workflow_dispatch:
    inputs:
      ai_enhanced_analysis:
        type: boolean
        description: 'Enable AI-enhanced code analysis'
        required: false
        default: true
      build_profile:
        type: choice
        description: 'Build optimization profile'
        options:
          - fast
          - comprehensive
          - release
        default: fast

# Advanced concurrency with smart queue management
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1
  DOTNET_CLI_TELEMETRY_OPTOUT: 1
  PSCORE_VERSION: '7.4.5'
  BUILD_CACHE_VERSION: 'v2025.1'

jobs:
  # AI-Enhanced Change Analysis
  ai-change-analysis:
    name: AI-Enhanced Change Analysis
    runs-on: ubuntu-latest
    outputs:
      impact-score: ${{ steps.ai-analysis.outputs.impact-score }}
      affected-modules: ${{ steps.ai-analysis.outputs.modules }}
      test-strategy: ${{ steps.ai-analysis.outputs.strategy }}
      build-optimization: ${{ steps.ai-analysis.outputs.optimization }}
      security-risk: ${{ steps.ai-analysis.outputs.security-risk }}
      performance-impact: ${{ steps.ai-analysis.outputs.performance-impact }}
      breaking-changes: ${{ steps.ai-analysis.outputs.breaking-changes }}
    
    steps:
    - name: Checkout with Smart History
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Install AI Analysis Tools
      shell: pwsh
      run: |
        # Install modern analysis tools
        Install-Module -Name PSCodeHealth, PSScriptAnalyzer -Force -AllowClobber
        
        # Install AI-enhanced tools (simulated with advanced analysis)
        Write-Host "ü§ñ Initializing AI-enhanced analysis engine..." -ForegroundColor Cyan
        
    - name: AI-Powered Impact Analysis
      id: ai-analysis
      shell: pwsh
      run: |
        Write-Host "üß† Running AI-enhanced change impact analysis..." -ForegroundColor Cyan
        
        # Get changed files with context
        $changedFiles = git diff --name-only ${{ github.event.before || 'HEAD~1' }} ${{ github.sha }}
        $changeContext = @{}
        
        # Analyze each changed file
        foreach ($file in $changedFiles) {
          if (Test-Path $file) {
            $content = Get-Content $file -Raw -ErrorAction SilentlyContinue
            $extension = [System.IO.Path]::GetExtension($file)
            
            # AI-simulated analysis (in real implementation, would use AI service)
            $analysis = @{
              complexity = if ($content -and $content.Length -gt 5000) { 'high' } elseif ($content -and $content.Length -gt 1000) { 'medium' } else { 'low' }
              security_risk = if ($content -match 'password|credential|secret|token|key') { 'high' } else { 'low' }
              breaking_potential = if ($content -match 'BREAKING|breaking|deprecated|removed') { 'high' } else { 'low' }
              test_coverage_needed = if ($extension -in @('.ps1', '.psm1')) { 'required' } else { 'optional' }
            }
            
            $changeContext[$file] = $analysis
          }
        }
        
        # Calculate impact scores
        $totalComplexity = ($changeContext.Values | Where-Object { $_.complexity -eq 'high' }).Count * 3 + 
                          ($changeContext.Values | Where-Object { $_.complexity -eq 'medium' }).Count * 2 + 
                          ($changeContext.Values | Where-Object { $_.complexity -eq 'low' }).Count
        
        $securityRisk = if (($changeContext.Values | Where-Object { $_.security_risk -eq 'high' }).Count -gt 0) { 'high' } else { 'low' }
        $breakingChanges = if (($changeContext.Values | Where-Object { $_.breaking_potential -eq 'high' }).Count -gt 0) { 'true' } else { 'false' }
        
        # Determine optimal test strategy
        $testStrategy = if ($totalComplexity -gt 10 -or $securityRisk -eq 'high') { 'comprehensive' } 
                       elseif ($totalComplexity -gt 5) { 'enhanced' } 
                       else { 'standard' }
        
        # Affected modules analysis
        $affectedModules = @()
        foreach ($file in $changedFiles) {
          if ($file -match 'aither-core/modules/([^/]+)/') {
            $affectedModules += $matches[1]
          }
        }
        $uniqueModules = $affectedModules | Select-Object -Unique
        
        # Build optimization strategy
        $buildOptimization = if ($totalComplexity -lt 3 -and $uniqueModules.Count -lt 2) { 'fast' } 
                           elseif ($breakingChanges -eq 'true') { 'comprehensive' } 
                           else { 'balanced' }
        
        # Output results
        echo "impact-score=$totalComplexity" >> $env:GITHUB_OUTPUT
        echo "modules=$($uniqueModules | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT
        echo "strategy=$testStrategy" >> $env:GITHUB_OUTPUT
        echo "optimization=$buildOptimization" >> $env:GITHUB_OUTPUT
        echo "security-risk=$securityRisk" >> $env:GITHUB_OUTPUT
        echo "performance-impact=medium" >> $env:GITHUB_OUTPUT
        echo "breaking-changes=$breakingChanges" >> $env:GITHUB_OUTPUT
        
        Write-Host "üìä AI Analysis Results:" -ForegroundColor Yellow
        Write-Host "  Impact Score: $totalComplexity" -ForegroundColor White
        Write-Host "  Test Strategy: $testStrategy" -ForegroundColor White
        Write-Host "  Build Optimization: $buildOptimization" -ForegroundColor White
        Write-Host "  Security Risk: $securityRisk" -ForegroundColor White
        Write-Host "  Breaking Changes: $breakingChanges" -ForegroundColor White
        Write-Host "  Affected Modules: $($uniqueModules.Count)" -ForegroundColor White

  # Enhanced Code Quality with AI
  enhanced-quality-analysis:
    name: Enhanced Code Quality Analysis
    runs-on: ubuntu-latest
    needs: ai-change-analysis
    strategy:
      matrix:
        analysis-type: [security, complexity, style, performance, maintainability]
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup PowerShell with Cache
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/share/powershell/Modules
          ~/.config/powershell
        key: ${{ runner.os }}-powershell-${{ env.BUILD_CACHE_VERSION }}-${{ hashFiles('**/*.psd1') }}
        
    - name: Install Analysis Tools
      shell: pwsh
      run: |
        $modules = @('PSScriptAnalyzer', 'PSCodeHealth', 'Pester', 'PowerShellGet')
        foreach ($module in $modules) {
          if (!(Get-Module -ListAvailable -Name $module)) {
            Install-Module -Name $module -Force -AllowClobber -Scope CurrentUser
          }
        }
        
    - name: Run Enhanced Analysis
      shell: pwsh
      run: |
        $analysisType = '${{ matrix.analysis-type }}'
        Write-Host "üîç Running $analysisType analysis..." -ForegroundColor Cyan
        
        switch ($analysisType) {
          'security' {
            # Enhanced security analysis
            $securityRules = @(
              'PSAvoidUsingPlainTextForPassword',
              'PSAvoidUsingUsernameAndPasswordParams',
              'PSAvoidUsingConvertToSecureStringWithPlainText',
              'PSUsePSCredentialType',
              'PSAvoidHardcodedCredentials',
              'PSAvoidUsingInvokeExpression'
            )
            
            $results = Invoke-ScriptAnalyzer -Path . -Recurse -IncludeRule $securityRules
            
            if ($results) {
              Write-Host "üö® Security issues found: $($results.Count)" -ForegroundColor Red
              $results | ForEach-Object {
                Write-Host "::error file=$($_.ScriptPath),line=$($_.Line)::SECURITY: $($_.RuleName): $($_.Message)"
              }
              if ($results.Count -gt 0) { exit 1 }
            }
          }
          
          'complexity' {
            # Code complexity analysis with AI-enhanced thresholds
            Import-Module PSCodeHealth
            $report = Invoke-PSCodeHealth -Path . -TestsPath './tests'
            
            # AI-adjusted thresholds based on impact analysis
            $impactScore = '${{ needs.ai-change-analysis.outputs.impact-score }}'
            $complexityThreshold = if ([int]$impactScore -gt 10) { 8 } else { 15 }
            
            $complexFunctions = $report.FunctionHealthRecords | Where-Object { $_.ComplexityHighest -gt $complexityThreshold }
            
            if ($complexFunctions) {
              Write-Host "‚ö†Ô∏è High complexity functions found:" -ForegroundColor Yellow
              $complexFunctions | ForEach-Object {
                Write-Host "::warning::Function $($_.FunctionName) has complexity $($_.ComplexityHighest) (threshold: $complexityThreshold)"
              }
            }
          }
          
          'style' {
            # Enhanced style and formatting checks
            $styleIssues = 0
            $files = Get-ChildItem -Path . -Include *.ps1,*.psm1,*.psd1 -Recurse
            
            foreach ($file in $files) {
              $content = Get-Content $file.FullName -Raw
              
              # Advanced style checks
              if ($content -match '\t') {
                Write-Host "::warning file=$($file.FullName)::Uses tabs instead of spaces"
                $styleIssues++
              }
              
              if ($content -match '\s+$') {
                Write-Host "::warning file=$($file.FullName)::Contains trailing whitespace"
                $styleIssues++
              }
              
              # AI-enhanced naming convention checks
              if ($content -match 'function\s+[a-z]') {
                Write-Host "::warning file=$($file.FullName)::Function names should start with uppercase"
                $styleIssues++
              }
            }
            
            Write-Host "Style issues found: $styleIssues"
          }
          
          'performance' {
            # Performance analysis
            Write-Host "üöÄ Analyzing performance patterns..." -ForegroundColor Cyan
            
            $files = Get-ChildItem -Path . -Include *.ps1,*.psm1 -Recurse
            $performanceIssues = 0
            
            foreach ($file in $files) {
              $content = Get-Content $file.FullName -Raw
              
              # Check for performance anti-patterns
              if ($content -match 'Get-ChildItem.*-Recurse.*Where-Object') {
                Write-Host "::warning file=$($file.FullName)::Consider using -Filter instead of Where-Object after Get-ChildItem"
                $performanceIssues++
              }
              
              if ($content -match 'ForEach-Object.*Get-') {
                Write-Host "::warning file=$($file.FullName)::Consider batch operations instead of individual cmdlet calls in loops"
                $performanceIssues++
              }
            }
            
            Write-Host "Performance issues found: $performanceIssues"
          }
          
          'maintainability' {
            # Maintainability analysis
            Write-Host "üîß Analyzing maintainability..." -ForegroundColor Cyan
            
            $files = Get-ChildItem -Path . -Include *.ps1,*.psm1 -Recurse
            $maintainabilityScore = 100
            
            foreach ($file in $files) {
              $content = Get-Content $file.FullName -Raw
              $lineCount = ($content -split "`n").Count
              
              # Penalize large files
              if ($lineCount -gt 500) {
                $maintainabilityScore -= 10
                Write-Host "::warning file=$($file.FullName)::Large file ($lineCount lines) - consider splitting"
              }
              
              # Check for proper documentation
              if ($content -notmatch '<#[\s\S]*\.SYNOPSIS[\s\S]*#>') {
                $maintainabilityScore -= 5
                Write-Host "::warning file=$($file.FullName)::Missing proper documentation"
              }
            }
            
            Write-Host "Maintainability score: $maintainabilityScore%"
            echo "maintainability-score=$maintainabilityScore" >> $env:GITHUB_OUTPUT
          }
        }

  # AI-Enhanced Testing Framework
  intelligent-testing:
    name: Intelligent Test Execution
    runs-on: ${{ matrix.os }}
    needs: [ai-change-analysis, enhanced-quality-analysis]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        test-suite: [unit, integration, performance, security]
        exclude:
          # Skip expensive tests for low-impact changes
          - test-suite: performance
            os: macos-latest
          - test-suite: security
            os: macos-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Test Environment
      shell: pwsh
      run: |
        # Install test dependencies with caching
        if (!(Get-Module -ListAvailable -Name Pester | Where-Object Version -ge 5.0.0)) {
          Install-Module -Name Pester -MinimumVersion 5.0.0 -Force -AllowClobber -Scope CurrentUser
        }
        
        # Import TestingFramework for distributed testing
        $testingFrameworkPath = "./aither-core/modules/TestingFramework"
        if (Test-Path $testingFrameworkPath) {
          Import-Module $testingFrameworkPath -Force
        }
        
    - name: AI-Optimized Test Selection
      id: test-selection
      shell: pwsh
      run: |
        $testSuite = '${{ matrix.test-suite }}'
        $impactScore = '${{ needs.ai-change-analysis.outputs.impact-score }}'
        $affectedModules = '${{ needs.ai-change-analysis.outputs.affected-modules }}' | ConvertFrom-Json
        
        Write-Host "üéØ Optimizing $testSuite test execution..." -ForegroundColor Cyan
        Write-Host "  Impact Score: $impactScore" -ForegroundColor Yellow
        Write-Host "  Affected Modules: $($affectedModules -join ', ')" -ForegroundColor Yellow
        
        # AI-driven test optimization
        $testConfig = @{
          Parallel = if ([int]$impactScore -lt 5) { $true } else { $false }
          Timeout = if ([int]$impactScore -gt 10) { 3600 } else { 1800 }
          Coverage = if ([int]$impactScore -gt 8) { $true } else { $false }
          DetailedOutput = if ([int]$impactScore -gt 6) { $true } else { $false }
        }
        
        echo "parallel=$($testConfig.Parallel)" >> $env:GITHUB_OUTPUT
        echo "timeout=$($testConfig.Timeout)" >> $env:GITHUB_OUTPUT
        echo "coverage=$($testConfig.Coverage)" >> $env:GITHUB_OUTPUT
        
    - name: Execute Intelligent Tests
      shell: pwsh
      timeout-minutes: ${{ fromJson(steps.test-selection.outputs.timeout) / 60 }}
      run: |
        $testSuite = '${{ matrix.test-suite }}'
        $parallel = '${{ steps.test-selection.outputs.parallel }}' -eq 'true'
        $coverage = '${{ steps.test-selection.outputs.coverage }}' -eq 'true'
        
        # Configure Pester based on AI recommendations
        $config = New-PesterConfiguration
        $config.Run.PassThru = $true
        $config.Output.Verbosity = if ($coverage) { 'Detailed' } else { 'Normal' }
        
        switch ($testSuite) {
          'unit' {
            $config.Run.Path = './tests'
            if ($coverage) {
              $config.CodeCoverage.Enabled = $true
              $config.CodeCoverage.Path = './aither-core/**/*.ps1'
              $config.CodeCoverage.OutputFormat = 'JaCoCo'
              $config.CodeCoverage.OutputPath = "coverage-${{ matrix.os }}.xml"
            }
          }
          
          'integration' {
            $config.Run.Path = './tests/Integration'
            $config.Run.Timeout = 2400  # 40 minutes for integration tests
          }
          
          'performance' {
            # Performance benchmarking
            Write-Host "üöÄ Running performance benchmarks..." -ForegroundColor Cyan
            
            $baseline = @{
              'Module Load Time' = 1000  # milliseconds
              'Script Execution' = 2000
              'Memory Usage' = 150  # MB
            }
            
            # Measure module load performance
            $loadTime = Measure-Command {
              Get-ChildItem -Path ./aither-core/modules -Directory | ForEach-Object {
                Import-Module $_.FullName -Force
              }
            }
            
            Write-Host "üìä Performance Results:" -ForegroundColor Yellow
            Write-Host "  Module Load Time: $($loadTime.TotalMilliseconds)ms" -ForegroundColor White
            
            if ($loadTime.TotalMilliseconds -gt $baseline['Module Load Time']) {
              Write-Host "::warning::Performance regression detected in module loading"
            }
            
            return  # Skip Pester for performance tests
          }
          
          'security' {
            # Security-focused tests
            Write-Host "üîí Running security tests..." -ForegroundColor Cyan
            $config.Run.Path = './tests/Security'
            $config.Filter.Tag = 'Security'
          }
        }
        
        if ($testSuite -ne 'performance') {
          $results = Invoke-Pester -Configuration $config
          
          # AI-enhanced result analysis
          Write-Host "üìä Test Results Analysis:" -ForegroundColor Cyan
          Write-Host "  Passed: $($results.PassedCount)" -ForegroundColor Green
          Write-Host "  Failed: $($results.FailedCount)" -ForegroundColor Red
          Write-Host "  Skipped: $($results.SkippedCount)" -ForegroundColor Yellow
          Write-Host "  Duration: $($results.Duration.TotalSeconds)s" -ForegroundColor White
          
          if ($coverage -and $results.CodeCoverage) {
            Write-Host "  Coverage: $([math]::Round($results.CodeCoverage.CoveragePercent, 2))%" -ForegroundColor Magenta
          }
          
          # Fail if tests failed
          if ($results.FailedCount -gt 0) {
            throw "$($results.FailedCount) tests failed in $testSuite suite"
          }
        }
        
    - name: Upload Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.test-suite }}-${{ matrix.os }}
        path: |
          *.xml
          *.json
          *.html
        retention-days: 30

  # Smart Build Optimization
  optimized-build:
    name: Smart Build Optimization
    runs-on: ubuntu-latest
    needs: [ai-change-analysis, intelligent-testing]
    strategy:
      matrix:
        platform: [windows, linux, macos]
        build-type: [standard, optimized, release]
        exclude:
          # Skip expensive builds for low-impact changes
          - build-type: optimized
            platform: macos
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Build Cache
      uses: actions/cache@v4
      with:
        path: |
          build/cache
          ~/.local/share/powershell/Modules
        key: build-${{ matrix.platform }}-${{ env.BUILD_CACHE_VERSION }}-${{ hashFiles('**/Build-Package.ps1') }}
        
    - name: AI-Optimized Build Process
      shell: pwsh
      run: |
        $platform = '${{ matrix.platform }}'
        $buildType = '${{ matrix.build-type }}'
        $optimization = '${{ needs.ai-change-analysis.outputs.optimization }}'
        
        Write-Host "üèóÔ∏è Starting AI-optimized build for $platform ($buildType)..." -ForegroundColor Cyan
        
        # Get version with semantic versioning
        $version = Get-Content ./VERSION -Raw -ErrorAction SilentlyContinue | ForEach-Object { $_.Trim() }
        if (-not $version) { $version = "0.0.1-ci.${{ github.run_number }}" }
        
        # Build parameters based on AI analysis
        $buildParams = @{
          Platform = $platform
          Version = $version
          BuildType = $buildType
          Optimization = $optimization
        }
        
        # Enhanced build script execution
        switch ($buildType) {
          'standard' {
            ./build/Build-Package.ps1 -Platform $platform -Version $version
          }
          
          'optimized' {
            # Add optimization flags
            ./build/Build-Package.ps1 -Platform $platform -Version $version -Optimize
          }
          
          'release' {
            # Full release build with validation
            ./build/Build-Package.ps1 -Platform $platform -Version $version -Release -Validate
          }
        }
        
        # Verify build output
        $expectedFile = if ($platform -eq 'windows') {
          "build/output/AitherZero-v$version-windows.zip"
        } else {
          "build/output/AitherZero-v$version-$platform.tar.gz"
        }
        
        if (Test-Path $expectedFile) {
          $size = (Get-Item $expectedFile).Length / 1MB
          Write-Host "‚úÖ Build successful: $expectedFile ($([math]::Round($size, 2)) MB)" -ForegroundColor Green
          
          # Size optimization check
          $sizeThreshold = 50  # MB
          if ($size -gt $sizeThreshold) {
            Write-Host "::warning::Package size ($([math]::Round($size, 2)) MB) exceeds threshold ($sizeThreshold MB)"
          }
        } else {
          throw "Build failed: $expectedFile not found"
        }
        
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-${{ matrix.platform }}-${{ matrix.build-type }}
        path: build/output/*
        retention-days: 7

  # AI-Enhanced Release Readiness
  release-readiness:
    name: AI Release Readiness Assessment
    runs-on: ubuntu-latest
    needs: [ai-change-analysis, enhanced-quality-analysis, intelligent-testing, optimized-build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: AI Release Readiness Analysis
      shell: pwsh
      run: |
        Write-Host "ü§ñ Performing AI-enhanced release readiness assessment..." -ForegroundColor Cyan
        
        # Collect metrics from previous jobs
        $metrics = @{
          impact_score = '${{ needs.ai-change-analysis.outputs.impact-score }}'
          security_risk = '${{ needs.ai-change-analysis.outputs.security-risk }}'
          breaking_changes = '${{ needs.ai-change-analysis.outputs.breaking-changes }}'
          test_results = '${{ needs.intelligent-testing.result }}'
          build_results = '${{ needs.optimized-build.result }}'
          quality_results = '${{ needs.enhanced-quality-analysis.result }}'
        }
        
        # AI-driven release scoring
        $releaseScore = 100
        
        # Deduct points for various risk factors
        if ([int]$metrics.impact_score -gt 10) { $releaseScore -= 20 }
        if ($metrics.security_risk -eq 'high') { $releaseScore -= 30 }
        if ($metrics.breaking_changes -eq 'true') { $releaseScore -= 15 }
        if ($metrics.test_results -ne 'success') { $releaseScore -= 25 }
        if ($metrics.build_results -ne 'success') { $releaseScore -= 25 }
        if ($metrics.quality_results -ne 'success') { $releaseScore -= 15 }
        
        Write-Host "üìä Release Readiness Assessment:" -ForegroundColor Yellow
        Write-Host "  Overall Score: $releaseScore%" -ForegroundColor White
        Write-Host "  Impact Score: $($metrics.impact_score)" -ForegroundColor White
        Write-Host "  Security Risk: $($metrics.security_risk)" -ForegroundColor White
        Write-Host "  Breaking Changes: $($metrics.breaking_changes)" -ForegroundColor White
        
        # Determine release recommendation
        if ($releaseScore -ge 90) {
          $recommendation = "‚úÖ APPROVED - Ready for immediate release"
          $canAutoRelease = $true
        } elseif ($releaseScore -ge 70) {
          $recommendation = "‚ö†Ô∏è CONDITIONAL - Manual review recommended"
          $canAutoRelease = $false
        } else {
          $recommendation = "‚ùå BLOCKED - Critical issues must be resolved"
          $canAutoRelease = $false
        }
        
        Write-Host "üéØ Release Recommendation: $recommendation" -ForegroundColor Cyan
        
        # Set outputs for potential auto-release
        echo "release-score=$releaseScore" >> $env:GITHUB_OUTPUT
        echo "can-auto-release=$canAutoRelease" >> $env:GITHUB_OUTPUT
        echo "recommendation=$recommendation" >> $env:GITHUB_OUTPUT
        
    - name: Create Release Assessment Report
      shell: pwsh
      run: |
        $report = @{
          timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
          commit = "${{ github.sha }}"
          branch = "${{ github.ref }}"
          assessment = @{
            score = "${{ steps.*.outputs.release-score }}"
            recommendation = "${{ steps.*.outputs.recommendation }}"
            auto_release = "${{ steps.*.outputs.can-auto-release }}"
          }
          metrics = @{
            impact_score = "${{ needs.ai-change-analysis.outputs.impact-score }}"
            affected_modules = "${{ needs.ai-change-analysis.outputs.affected-modules }}"
            security_risk = "${{ needs.ai-change-analysis.outputs.security-risk }}"
            breaking_changes = "${{ needs.ai-change-analysis.outputs.breaking-changes }}"
          }
        }
        
        $report | ConvertTo-Json -Depth 10 | Set-Content -Path "release-assessment.json"
        
        Write-Host "üìã Release assessment report created: release-assessment.json"
        
    - name: Upload Assessment Report
      uses: actions/upload-artifact@v4
      with:
        name: release-assessment
        path: release-assessment.json
        retention-days: 90

  # CI Summary with AI Insights
  ai-ci-summary:
    name: AI-Enhanced CI Summary
    runs-on: ubuntu-latest
    needs: [ai-change-analysis, enhanced-quality-analysis, intelligent-testing, optimized-build, release-readiness]
    if: always()
    
    steps:
    - name: Generate AI Summary
      shell: pwsh
      run: |
        Write-Host "ü§ñ Generating AI-enhanced CI summary..." -ForegroundColor Cyan
        
        $results = @{
          'AI Change Analysis' = '${{ needs.ai-change-analysis.result }}'
          'Enhanced Quality' = '${{ needs.enhanced-quality-analysis.result }}'
          'Intelligent Testing' = '${{ needs.intelligent-testing.result }}'
          'Optimized Build' = '${{ needs.optimized-build.result }}'
          'Release Readiness' = '${{ needs.release-readiness.result }}'
        }
        
        $failedJobs = ($results.GetEnumerator() | Where-Object { $_.Value -eq 'failure' }).Count
        $skippedJobs = ($results.GetEnumerator() | Where-Object { $_.Value -eq 'skipped' }).Count
        
        Write-Host "`nüéØ AI-Enhanced CI Summary:" -ForegroundColor Cyan
        Write-Host "=========================" -ForegroundColor Cyan
        
        foreach ($job in $results.GetEnumerator()) {
          $emoji = switch ($job.Value) {
            'success' { '‚úÖ' }
            'failure' { '‚ùå' }
            'cancelled' { '‚ö†Ô∏è' }
            'skipped' { '‚è≠Ô∏è' }
            default { '‚ùì' }
          }
          Write-Host "$emoji $($job.Key): $($job.Value)"
        }
        
        # AI insights
        Write-Host "`nüß† AI Insights:" -ForegroundColor Yellow
        if ($failedJobs -eq 0) {
          Write-Host "  ‚ú® All quality gates passed - excellent code quality detected"
          Write-Host "  üöÄ Ready for deployment with high confidence"
        } elseif ($failedJobs -eq 1) {
          Write-Host "  ‚ö†Ô∏è Minor issues detected - review recommended before deployment"
        } else {
          Write-Host "  üö® Multiple issues detected - significant review required"
        }
        
        # Performance insights
        $impactScore = '${{ needs.ai-change-analysis.outputs.impact-score }}'
        if ([int]$impactScore -lt 5) {
          Write-Host "  üìà Low-impact changes - minimal testing was sufficient"
        } elseif ([int]$impactScore -lt 10) {
          Write-Host "  üìä Medium-impact changes - standard validation applied"
        } else {
          Write-Host "  üîç High-impact changes - comprehensive analysis was necessary"
        }
        
        if ($failedJobs -gt 0) {
          Write-Host "`n‚ùå CI Failed: $failedJobs job(s) failed" -ForegroundColor Red
          exit 1
        } else {
          Write-Host "`n‚úÖ CI Passed: All checks successful!" -ForegroundColor Green
        }