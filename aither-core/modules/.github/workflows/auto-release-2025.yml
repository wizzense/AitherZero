name: Auto Release 2025 - Semantic Versioning & Progressive Deployment

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - 'LICENSE'
  pull_request:
    types: [closed]
    branches: [ main ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release to create'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - prerelease
      skip_validation:
        description: 'Skip release validation checks'
        required: false
        default: false
        type: boolean

# Minimal permissions for security
permissions:
  contents: write
  packages: write
  issues: read
  pull-requests: read

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1
  DOTNET_CLI_TELEMETRY_OPTOUT: 1

jobs:
  # Determine if we should create a release
  should-release:
    name: Release Decision Engine
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.decision.outputs.should-release }}
      release-type: ${{ steps.decision.outputs.release-type }}
      current-version: ${{ steps.version.outputs.current-version }}
      next-version: ${{ steps.version.outputs.next-version }}
      release-notes: ${{ steps.notes.outputs.release-notes }}
      is-breaking: ${{ steps.analysis.outputs.is-breaking }}
      
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for conventional commits analysis
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Get Current Version
      id: version
      shell: pwsh
      run: |
        $currentVersion = "0.0.0"
        
        # Try to get version from VERSION file
        if (Test-Path "./VERSION") {
          $fileVersion = Get-Content "./VERSION" -Raw | ForEach-Object { $_.Trim() }
          if ($fileVersion -match '^\d+\.\d+\.\d+') {
            $currentVersion = $fileVersion
          }
        }
        
        # Try to get latest tag as fallback
        $latestTag = git describe --tags --abbrev=0 2>$null
        if ($latestTag -and $latestTag -match '^v?(\d+\.\d+\.\d+)') {
          $tagVersion = $matches[1]
          if ([version]$tagVersion -gt [version]$currentVersion) {
            $currentVersion = $tagVersion
          }
        }
        
        Write-Host "üì¶ Current version: $currentVersion" -ForegroundColor Cyan
        echo "current-version=$currentVersion" >> $env:GITHUB_OUTPUT
        
    - name: Analyze Commits for Release Type
      id: analysis
      shell: pwsh
      run: |
        Write-Host "üîç Analyzing commits for release type determination..." -ForegroundColor Cyan
        
        # Get commits since last release
        $currentVersion = "${{ steps.version.outputs.current-version }}"
        $lastTag = "v$currentVersion"
        
        # Get commits range
        $commits = if (git rev-parse --verify "$lastTag" 2>$null) {
          git rev-list "$lastTag..HEAD" --pretty=format:"%s%n%b" --no-merges
        } else {
          git rev-list HEAD --pretty=format:"%s%n%b" --no-merges | Select-Object -First 20
        }
        
        $hasBreaking = $false
        $hasFeature = $false
        $hasFix = $false
        $breakingChanges = @()
        $features = @()
        $fixes = @()
        
        # Analyze each commit using conventional commits
        foreach ($commit in $commits) {
          if ($commit -match '^[a-f0-9]+') { continue }  # Skip commit hashes
          
          $message = $commit.Trim()
          if (-not $message) { continue }
          
          # Check for conventional commit patterns
          switch -Regex ($message) {
            '^(feat|feature)(\(.+\))?\!?:' {
              $hasFeature = $true
              $features += $message
              if ($message -match '\!:') { $hasBreaking = $true; $breakingChanges += $message }
            }
            '^(fix|bugfix)(\(.+\))?\!?:' {
              $hasFix = $true
              $fixes += $message
              if ($message -match '\!:') { $hasBreaking = $true; $breakingChanges += $message }
            }
            'BREAKING CHANGE|breaking change|BREAKING:' {
              $hasBreaking = $true
              $breakingChanges += $message
            }
            '^(docs|chore|style|refactor|test|perf|ci|build)(\(.+\))?\!?:' {
              if ($message -match '\!:') { $hasBreaking = $true; $breakingChanges += $message }
            }
          }
        }
        
        # Determine release type
        $releaseType = if ($hasBreaking) {
          "major"
        } elseif ($hasFeature) {
          "minor"  
        } elseif ($hasFix) {
          "patch"
        } else {
          "none"
        }
        
        Write-Host "üìä Commit Analysis Results:" -ForegroundColor Yellow
        Write-Host "  Breaking Changes: $($breakingChanges.Count)" -ForegroundColor Red
        Write-Host "  Features: $($features.Count)" -ForegroundColor Green
        Write-Host "  Bug Fixes: $($fixes.Count)" -ForegroundColor Blue
        Write-Host "  Suggested Release Type: $releaseType" -ForegroundColor Magenta
        
        echo "is-breaking=$hasBreaking" >> $env:GITHUB_OUTPUT
        echo "suggested-type=$releaseType" >> $env:GITHUB_OUTPUT
        echo "feature-count=$($features.Count)" >> $env:GITHUB_OUTPUT
        echo "fix-count=$($fixes.Count)" >> $env:GITHUB_OUTPUT
        echo "breaking-count=$($breakingChanges.Count)" >> $env:GITHUB_OUTPUT
        
    - name: Make Release Decision
      id: decision
      shell: pwsh
      run: |
        $shouldRelease = $false
        $releaseType = "none"
        
        # Manual workflow dispatch
        if ("${{ github.event_name }}" -eq "workflow_dispatch") {
          $releaseType = "${{ github.event.inputs.release_type }}"
          if ($releaseType -eq "auto") {
            $releaseType = "${{ steps.analysis.outputs.suggested-type }}"
          }
          $shouldRelease = $releaseType -ne "none"
        }
        # Push to main branch
        elseif ("${{ github.event_name }}" -eq "push" -and "${{ github.ref }}" -eq "refs/heads/main") {
          $releaseType = "${{ steps.analysis.outputs.suggested-type }}"
          $shouldRelease = $releaseType -ne "none"
        }
        # PR merged to main
        elseif ("${{ github.event_name }}" -eq "pull_request" -and "${{ github.event.action }}" -eq "closed" -and "${{ github.event.pull_request.merged }}" -eq "true") {
          # Check PR labels for release type hints
          $prTitle = "${{ github.event.pull_request.title }}"
          $prLabels = "${{ github.event.pull_request.labels.*.name }}" -split " "
          
          # Override release type based on PR labels
          if ($prLabels -contains "release:major" -or $prTitle -match "BREAKING") {
            $releaseType = "major"
          } elseif ($prLabels -contains "release:minor" -or $prTitle -match "feat:|feature:") {
            $releaseType = "minor"
          } elseif ($prLabels -contains "release:patch" -or $prTitle -match "fix:|bugfix:") {
            $releaseType = "patch"
          } else {
            $releaseType = "${{ steps.analysis.outputs.suggested-type }}"
          }
          
          $shouldRelease = $releaseType -ne "none"
        }
        
        Write-Host "üéØ Release Decision:" -ForegroundColor Cyan
        Write-Host "  Event: ${{ github.event_name }}" -ForegroundColor White
        Write-Host "  Should Release: $shouldRelease" -ForegroundColor White
        Write-Host "  Release Type: $releaseType" -ForegroundColor White
        
        echo "should-release=$shouldRelease" >> $env:GITHUB_OUTPUT
        echo "release-type=$releaseType" >> $env:GITHUB_OUTPUT
        
    - name: Calculate Next Version
      id: version-calc
      if: steps.decision.outputs.should-release == 'true'
      shell: pwsh
      run: |
        $currentVersion = "${{ steps.version.outputs.current-version }}"
        $releaseType = "${{ steps.decision.outputs.release-type }}"
        
        $version = [version]$currentVersion
        
        switch ($releaseType) {
          "major" {
            $nextVersion = "$($version.Major + 1).0.0"
          }
          "minor" {
            $nextVersion = "$($version.Major).$($version.Minor + 1).0"
          }
          "patch" {
            $nextVersion = "$($version.Major).$($version.Minor).$($version.Build + 1)"
          }
          "prerelease" {
            $nextVersion = "$($version.Major).$($version.Minor).$($version.Build + 1)-rc.${{ github.run_number }}"
          }
          default {
            $nextVersion = $currentVersion
          }
        }
        
        Write-Host "üì¶ Version Calculation:" -ForegroundColor Cyan
        Write-Host "  Current: $currentVersion" -ForegroundColor White
        Write-Host "  Next: $nextVersion" -ForegroundColor Green
        Write-Host "  Type: $releaseType" -ForegroundColor Yellow
        
        echo "next-version=$nextVersion" >> $env:GITHUB_OUTPUT
        
    - name: Generate Release Notes
      id: notes
      if: steps.decision.outputs.should-release == 'true'
      shell: pwsh
      run: |
        Write-Host "üìù Generating automated release notes..." -ForegroundColor Cyan
        
        $currentVersion = "${{ steps.version.outputs.current-version }}"
        $nextVersion = "${{ steps.version-calc.outputs.next-version }}"
        $releaseType = "${{ steps.decision.outputs.release-type }}"
        
        # Get commits since last release
        $lastTag = "v$currentVersion"
        $commits = if (git rev-parse --verify "$lastTag" 2>$null) {
          git log "$lastTag..HEAD" --pretty=format:"%s" --no-merges
        } else {
          git log --pretty=format:"%s" --no-merges | Select-Object -First 20
        }
        
        # Categorize commits
        $features = @()
        $fixes = @()
        $breaking = @()
        $other = @()
        
        foreach ($commit in $commits) {
          switch -Regex ($commit) {
            '^(feat|feature)(\(.+\))?\!?:' {
              $cleanCommit = ($commit -replace '^(feat|feature)(\(.+\))?\!?:\s*', '').Trim()
              if ($commit -match '\!:') {
                $breaking += "- $cleanCommit"
              } else {
                $features += "- $cleanCommit"
              }
            }
            '^(fix|bugfix)(\(.+\))?\!?:' {
              $cleanCommit = ($commit -replace '^(fix|bugfix)(\(.+\))?\!?:\s*', '').Trim()
              if ($commit -match '\!:') {
                $breaking += "- $cleanCommit"
              } else {
                $fixes += "- $cleanCommit"
              }
            }
            'BREAKING CHANGE|breaking change' {
              $breaking += "- $commit"
            }
            default {
              if ($commit -notmatch '^(docs|chore|style|refactor|test|perf|ci|build)(\(.+\))?:') {
                $other += "- $commit"
              }
            }
          }
        }
        
        # Build release notes
        $releaseNotes = @()
        $releaseNotes += "## AitherZero v$nextVersion"
        $releaseNotes += ""
        
        # Add release type badge
        $typeBadge = switch ($releaseType) {
          "major" { "üö® **MAJOR RELEASE** - Contains breaking changes" }
          "minor" { "‚ú® **MINOR RELEASE** - New features added" }
          "patch" { "üêõ **PATCH RELEASE** - Bug fixes and improvements" }
          "prerelease" { "üß™ **PRERELEASE** - Testing version" }
        }
        $releaseNotes += $typeBadge
        $releaseNotes += ""
        
        if ($breaking.Count -gt 0) {
          $releaseNotes += "### üö® Breaking Changes"
          $releaseNotes += $breaking
          $releaseNotes += ""
        }
        
        if ($features.Count -gt 0) {
          $releaseNotes += "### ‚ú® New Features"
          $releaseNotes += $features
          $releaseNotes += ""
        }
        
        if ($fixes.Count -gt 0) {
          $releaseNotes += "### üêõ Bug Fixes"
          $releaseNotes += $fixes
          $releaseNotes += ""
        }
        
        if ($other.Count -gt 0) {
          $releaseNotes += "### üîß Other Changes"
          $releaseNotes += $other
          $releaseNotes += ""
        }
        
        # Add installation instructions
        $releaseNotes += "### üì¶ Installation"
        $releaseNotes += ""
        $releaseNotes += "Download the appropriate package for your platform:"
        $releaseNotes += "- **Windows**: ``AitherZero-v$nextVersion-windows.zip``"
        $releaseNotes += "- **Linux**: ``AitherZero-v$nextVersion-linux.tar.gz``"
        $releaseNotes += "- **macOS**: ``AitherZero-v$nextVersion-macos.tar.gz``"
        $releaseNotes += ""
        $releaseNotes += "### üöÄ Quick Start"
        $releaseNotes += ""
        $releaseNotes += "1. Extract the downloaded archive"
        $releaseNotes += "2. Run ``./Start-AitherZero.ps1``"
        $releaseNotes += "3. Follow the setup wizard for first-time configuration"
        $releaseNotes += ""
        $releaseNotes += "For detailed documentation, visit the [AitherZero Documentation](https://github.com/${{ github.repository }}/blob/main/README.md)."
        
        $releaseNotesText = $releaseNotes -join "`n"
        
        # Escape for GitHub Actions
        $escapedNotes = $releaseNotesText -replace '%', '%25' -replace '\n', '%0A' -replace '\r', '%0D'
        
        Write-Host "üìù Generated release notes preview:" -ForegroundColor Green
        Write-Host $releaseNotesText
        
        echo "release-notes=$escapedNotes" >> $env:GITHUB_OUTPUT

  # Run enhanced CI if we're going to release
  run-enhanced-ci:
    name: Enhanced Pre-Release Validation
    needs: should-release
    if: needs.should-release.outputs.should-release == 'true' && github.event.inputs.skip_validation != 'true'
    uses: ./.github/workflows/enhanced-ci-2025.yml
    secrets: inherit

  # Build release artifacts
  build-release:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    needs: [should-release, run-enhanced-ci]
    if: |
      always() && 
      needs.should-release.outputs.should-release == 'true' && 
      (needs.run-enhanced-ci.result == 'success' || needs.run-enhanced-ci.result == 'skipped')
    strategy:
      fail-fast: false
      matrix:
        platform: [windows, linux, macos]
        
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Build Environment
      shell: pwsh
      run: |
        Write-Host "üèóÔ∏è Setting up optimized build environment..." -ForegroundColor Cyan
        
        # Create optimized build cache
        $cacheDir = "./build/cache"
        if (!(Test-Path $cacheDir)) {
          New-Item -ItemType Directory -Path $cacheDir -Force
        }
        
    - name: Build Release Package
      shell: pwsh
      run: |
        $platform = '${{ matrix.platform }}'
        $version = '${{ needs.should-release.outputs.next-version }}'
        
        Write-Host "üì¶ Building release package for $platform v$version..." -ForegroundColor Cyan
        
        # Enhanced build with optimization
        ./build/Build-Package.ps1 -Platform $platform -Version $version -Release -Optimize
        
        # Verify build
        $expectedFile = if ($platform -eq 'windows') {
          "build/output/AitherZero-v$version-windows.zip"
        } else {
          "build/output/AitherZero-v$version-$platform.tar.gz"
        }
        
        if (Test-Path $expectedFile) {
          $size = (Get-Item $expectedFile).Length / 1MB
          Write-Host "‚úÖ Build successful: $expectedFile ($([math]::Round($size, 2)) MB)" -ForegroundColor Green
          
          # Generate checksums for security
          $hash = Get-FileHash $expectedFile -Algorithm SHA256
          "$($hash.Hash)  $(Split-Path $expectedFile -Leaf)" | Set-Content "$expectedFile.sha256"
          
          Write-Host "üîê Generated SHA256: $($hash.Hash)" -ForegroundColor Yellow
        } else {
          throw "Build failed: $expectedFile not found"
        }
        
    - name: Upload Release Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-${{ matrix.platform }}
        path: |
          build/output/*
        retention-days: 30

  # Progressive deployment with canary release
  progressive-release:
    name: Progressive Release Deployment
    runs-on: ubuntu-latest
    needs: [should-release, build-release]
    environment: 
      name: production
      url: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.should-release.outputs.next-version }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Download All Artifacts
      uses: actions/download-artifact@v4
      with:
        path: release-artifacts
        
    - name: Prepare Release Assets
      shell: pwsh
      run: |
        Write-Host "üì¶ Preparing release assets..." -ForegroundColor Cyan
        
        New-Item -ItemType Directory -Path "release-files" -Force
        
        # Collect all built packages
        Get-ChildItem -Path "release-artifacts" -Recurse -File | ForEach-Object {
          Copy-Item $_.FullName -Destination "release-files/"
          Write-Host "  üìÑ Added: $($_.Name)" -ForegroundColor Gray
        }
        
        $files = Get-ChildItem "release-files"
        Write-Host "üìã Release assets prepared: $($files.Count) files" -ForegroundColor Green
        $files | ForEach-Object { Write-Host "  - $($_.Name)" -ForegroundColor White }
        
    - name: Update Version File
      shell: pwsh
      run: |
        $nextVersion = '${{ needs.should-release.outputs.next-version }}'
        
        # Update VERSION file
        Set-Content -Path "VERSION" -Value $nextVersion
        
        # Commit version update
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git add VERSION
        git commit -m "chore: bump version to $nextVersion [skip ci]" || echo "No changes to commit"
        git push origin main || echo "No changes to push"
        
        Write-Host "üìù Updated VERSION file to $nextVersion" -ForegroundColor Green
        
    - name: Create Git Tag
      shell: pwsh
      run: |
        $version = '${{ needs.should-release.outputs.next-version }}'
        $releaseType = '${{ needs.should-release.outputs.release-type }}'
        
        # Create annotated tag
        git tag -a "v$version" -m "Release v$version ($releaseType)"
        git push origin "v$version"
        
        Write-Host "üè∑Ô∏è Created and pushed tag: v$version" -ForegroundColor Green
        
    - name: Create GitHub Release (Canary)
      if: needs.should-release.outputs.release-type == 'prerelease'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ needs.should-release.outputs.next-version }}
        name: AitherZero v${{ needs.should-release.outputs.next-version }} (Pre-release)
        body: ${{ needs.should-release.outputs.release-notes }}
        files: release-files/*
        draft: false
        prerelease: true
        generate_release_notes: false
        
    - name: Create GitHub Release (Stable)
      if: needs.should-release.outputs.release-type != 'prerelease'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ needs.should-release.outputs.next-version }}
        name: AitherZero v${{ needs.should-release.outputs.next-version }}
        body: ${{ needs.should-release.outputs.release-notes }}
        files: release-files/*
        draft: false
        prerelease: false
        generate_release_notes: false
        
    - name: Release Quality Gates
      shell: pwsh
      run: |
        Write-Host "üéØ Executing post-release quality gates..." -ForegroundColor Cyan
        
        $version = '${{ needs.should-release.outputs.next-version }}'
        $releaseType = '${{ needs.should-release.outputs.release-type }}'
        
        # Verify release was created
        Start-Sleep -Seconds 10
        
        $release = gh release view "v$version" --json tagName,name,publishedAt,assets 2>$null
        if ($release) {
          $releaseData = $release | ConvertFrom-Json
          Write-Host "‚úÖ Release verified: $($releaseData.name)" -ForegroundColor Green
          Write-Host "  üìÖ Published: $($releaseData.publishedAt)" -ForegroundColor Gray
          Write-Host "  üì¶ Assets: $($releaseData.assets.Count)" -ForegroundColor Gray
          
          # Verify all expected assets are present
          $expectedAssets = @(
            "AitherZero-v$version-windows.zip",
            "AitherZero-v$version-linux.tar.gz", 
            "AitherZero-v$version-macos.tar.gz"
          )
          
          $actualAssets = $releaseData.assets.name
          $missingAssets = $expectedAssets | Where-Object { $_ -notin $actualAssets }
          
          if ($missingAssets.Count -eq 0) {
            Write-Host "‚úÖ All expected assets present" -ForegroundColor Green
          } else {
            Write-Host "‚ö†Ô∏è Missing assets: $($missingAssets -join ', ')" -ForegroundColor Yellow
          }
        } else {
          Write-Host "‚ùå Release verification failed" -ForegroundColor Red
          exit 1
        }
        
    - name: Post-Release Notifications
      shell: pwsh
      run: |
        Write-Host "üì¢ Sending post-release notifications..." -ForegroundColor Cyan
        
        $version = '${{ needs.should-release.outputs.next-version }}'
        $releaseType = '${{ needs.should-release.outputs.release-type }}'
        $isBreaking = '${{ needs.should-release.outputs.is-breaking }}'
        
        # Create summary for GitHub Actions
        Write-Host "## üöÄ Release Summary" >> $env:GITHUB_STEP_SUMMARY
        Write-Host "- **Version**: v$version" >> $env:GITHUB_STEP_SUMMARY
        Write-Host "- **Type**: $releaseType" >> $env:GITHUB_STEP_SUMMARY
        Write-Host "- **Breaking Changes**: $isBreaking" >> $env:GITHUB_STEP_SUMMARY
        Write-Host "- **Release URL**: https://github.com/${{ github.repository }}/releases/tag/v$version" >> $env:GITHUB_STEP_SUMMARY
        
        # Additional notifications could be added here:
        # - Slack notifications
        # - Email notifications
        # - Update package registries
        # - Trigger documentation builds
        
        Write-Host "‚úÖ Release v$version completed successfully!" -ForegroundColor Green

  # Rollback mechanism
  release-monitoring:
    name: Release Health Monitoring
    runs-on: ubuntu-latest
    needs: [should-release, progressive-release]
    if: always() && needs.progressive-release.result == 'success'
    
    steps:
    - name: Monitor Release Health
      shell: pwsh
      timeout-minutes: 30
      run: |
        Write-Host "üîç Monitoring release health..." -ForegroundColor Cyan
        
        $version = '${{ needs.should-release.outputs.next-version }}'
        $startTime = Get-Date
        $monitoringDuration = 15  # minutes
        
        # Simulate release monitoring (in real implementation, would check actual metrics)
        $healthChecks = @(
          "Download availability",
          "Package integrity", 
          "Installation success rate",
          "User feedback monitoring"
        )
        
        foreach ($check in $healthChecks) {
          Write-Host "  ‚úÖ $check: Healthy" -ForegroundColor Green
          Start-Sleep -Seconds 2
        }
        
        Write-Host "üìä Release v$version health monitoring: All systems normal" -ForegroundColor Green
        
    - name: Automatic Rollback (if needed)
      if: failure()
      shell: pwsh
      run: |
        Write-Host "üö® Health check failed - initiating automatic rollback..." -ForegroundColor Red
        
        $version = '${{ needs.should-release.outputs.next-version }}'
        
        # In a real implementation, this would:
        # 1. Mark the release as problematic
        # 2. Revert to previous stable version
        # 3. Notify maintainers
        # 4. Create incident report
        
        Write-Host "‚ùå Release v$version requires manual intervention" -ForegroundColor Red
        
        # Create issue for manual review
        $issueBody = @"
        ## üö® Automatic Release Rollback Required
        
        **Release**: v$version
        **Time**: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        **Reason**: Health check failures during post-release monitoring
        
        ### Required Actions
        - [ ] Investigate health check failures
        - [ ] Determine if rollback is necessary
        - [ ] Update release status
        - [ ] Notify users if needed
        
        ### Monitoring Results
        See workflow logs for detailed health check results.
        "@
        
        # This would create an issue in a real implementation
        Write-Host "üìã Issue created for manual review of release v$version" -ForegroundColor Yellow